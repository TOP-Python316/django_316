[
{
  "model": "cards.card",
  "pk": 1,
  "fields": {
    "question": "Пайтон или Питон?",
    "answer": "```python\r\nprint(\"Пайтон!\")\r\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 17,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 2,
  "fields": {
    "question": "Жава Скрипт или Джаба Скрипт?",
    "answer": "Джава Скрипт!",
    "category": 4,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 3,
  "fields": {
    "question": "Что такое python?",
    "answer": "Python - это язык программирования высокого уровня, интерпретируемый, с динамической типизацией и автоматическим управлением памятью. Он был разработан в конце 1980-х годов Гвидо ван Россумом и имеет широкую популярность среди разработчиков благодаря своей простоте и эффективности. Python широко применяется в различных областях, включая науку о данных, машинное обучение, веб-разработку, игровую индустрию, GIS и многие другие.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 4,
  "fields": {
    "question": "В каком году написана первая статья про python",
    "answer": "Автором Python является голландец Гвидо Ван Россум. Этот язык он начал проектировать в конце 1980-х годов, во время работы в голландском институте CWI. За основу он взял язык программирования ABC, в разработке которого он когда участвовал.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 5,
  "fields": {
    "question": "Какие типы данных есть в python? На какие классы делятся?",
    "answer": "Python поддерживает множество различных встроенных типов данных, включая:\n\n- Числа: int, float, и complex.\n- Строки: str.\n- Списки: list.\n- Кортежи: tuple.\n- Словари: dict.\n- Множества: set.\n- Булевы значения: bool.\n\nЭти типы данных можно разделить на несколько классов:\n\n- Числовые типы данных: int, float, и complex.\n- Строковые типы данных: str.\n- Коллекции: list, tuple, dict, и set.\n- Булевы типы данных: bool.\n\nКаждый тип предоставляет свои собственные методы и функции для работы с данными, а также поддерживает операции, которые могут выполняться на них, такие как арифметические и логические операции.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 2,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 6,
  "fields": {
    "question": "Что такое лямбда-функция? Какое у неё назначение?",
    "answer": "Лямбда-функция (tакже известна как \"анонимная функция\") - это функция, которая определяется в одной строке кода без использования ключевого слова def. Она может быть использована вместо обычной функции, когда требуется быстрое определение небольшой функции.\n\nВ Python лямбда-функция определяется с помощью ключевого слова lambda, за которым следует список аргументов через запятую, затем символ :, и наконец, тело функции.\n\nНапример, чтобы определить лямбда-функцию, которая удваивает свой аргумент, можно написать:\n\n```pythonthon\ndouble = lambda x: x * 2\n```\n\nЛямбда-функции в основном используются в качестве аргументов функций высшего порядка , которые принимают другие функции в качестве аргументов. Также они могут использоваться для создания более читаемого и компактного кода.\n\nНапример, можно использовать лямбда-функцию вместо объявления обычной функции для преобразования списка:\n\n```pythonthon\nnumbers = [1, 2, 3, 4, 5]\nsquares = list(map(lambda x: x**2, numbers))\n```\n\nЭтот пример создает список квадратов чисел в списке numbers с помощью функции map(), принимающей лямбда-функцию в качестве аргумента.\n\nТаким образом, лямбда-функция в Python позволяет определять небольшие функции быстро и использовать их в качестве аргументов для других функций.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 1,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 7,
  "fields": {
    "question": "Что такое PEP 8?",
    "answer": "PEP 8 (Python Enhancement Proposal 8) - это документ, который содержит рекомендации по написанию кода на языке Python. Он содержит стилевые соглашения, которые, следуя практике, повышают читабельность кода, делая его более понятным, расширяемым и поддерживаемым. Документ был опубликован в 2001 году и рекомендуется как основной стандарт написания кода Python. PEP 8 охватывает такие темы, как именование переменных, расположение отступов, длина строк, комментарии, импорты и многое другое.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 8,
  "fields": {
    "question": "Как получить документацию по атрибутам объекта?",
    "answer": "В Python вы можете получить документацию по атрибутам объекта с помощью атрибута doc. Например, если у вас есть объект с атрибутом attribute_name, то вы можете получить его документацию следующим образом:\n\n```pythonthon\nprint(attribute_name.__doc__)\n```\n\nВы также можете использовать встроенную функцию help() для получения подробной информации о любом объекте, включая его атрибуты. Просто передайте объект в функцию help(), чтобы получить всю доступную документацию:\n\n```pythonthon\nhelp(attribute_name)\n```\n\nНебольшое уточнение: doc отображает документацию для конкретного атрибута или метода. Если вы хотите получить общую документацию для объекта, вызовите help() без параметров (т.е. help(object_name)).\n\nНапример, если у вас есть класс с атрибутом attribute_name, вы можете получить его документацию следующим образом:\n\n```pythonthon\nclass MyClass:\n    \"\"\"This is the docstring for MyClass.\"\"\"\n    attribute_name = \"value\"\n\nprint(MyClass.attribute_name.__doc__)\n```\n\nЭтот код выведет документацию для атрибута attribute_name, которая будет равна None, так как мы не определили документацию для него в классе. Теперь мы можем использовать функцию help() для получения документации для самого класса:\n\n```pythonthon\nhelp(MyClass)\n```\n\nЭто приведет к выводу всей доступной документации для MyClass, включая документацию для его атрибута attribute_name.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 9,
  "fields": {
    "question": "Что такое docstring?",
    "answer": "Docstring в Python - это строка документации, которая описывает, что делает функция, метод, модуль или класс Python. Данная строка располагается в начале определения объекта и используется для генерации документации автоматически. В других словах, docstring используется для создания описания API и содержит информацию о том, как использовать функцию или метод, какие аргументы они принимают и какие значения возвращают.\n\nНапример:\n\n```pythonthon\ndef add_numbers(a, b):\n    \"\"\"\n    This function takes in two numbers and returns their sum\n    \"\"\"\n    return a + b\n```\n\nВ данном примере, docstring - это строка между тройными кавычками, после имени функции. Она описывает, что делает функция и как ее использовать.\n\nDocstring является важным инструментом в Python разработке, так как важно документировать ваш код для себя и для других разработчиков. Документированный код легче поддерживать и понимать, что облегчает разработку и сотрудничество.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 10,
  "fields": {
    "question": "В чём разница между типами list и tuple?",
    "answer": "В Python, список (list) и кортеж (tuple) являются двумя различными типами данных, которые предоставляют набор элементов в определенном порядке. Основная разница между ними заключается в том, что список может быть изменен (мутабельный тип), а кортеж является неизменяемым (иммутабельным типом).\n\nТо есть, после создания кортежа, вы не можете изменять его содержимое, добавлять или удалять элементы. Это делает кортежи более эффективными по памяти и дает гарантию того, что их содержимое не будет изменено случайно в коде. В то время как список может быть изменен, что было бы очень полезно, если вам нужна коллекция элементов, которые вы можете изменять по ходу выполнения кода.\n\nДругая разница между списком и кортежем заключается в скорости доступа к элементам. За счет того, что кортежи являются неизменным типом данных, они обрабатываются быстрее, чем списки.\n\nНапример, для создания списка в Python используется квадратная скобка, а для создания кортежа используется круглая скобка. Вот примеры использования списков и кортежей:\n\n```pythonthon\nmy_list = [1, 2, 3, 4, 5] # Это список\nmy_tuple = (1, 2, 3, 4, 5) # Это кортеж\n```\n\nCписок может быть изменен, например, можно добавить элемент в список:\n\n```pythonthon\nmy_list.append(6)\n```\n\nНо не можем добавить элемент в кортеж, так как он неизменяем:\n\n```pythonthon\nmy_tuple.append(6) # Эта строка вызовет ошибку\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 1,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 11,
  "fields": {
    "question": "Может ли быть индекс списка отрицательным?",
    "answer": "Да, индекс списка может быть отрицательным. В таком случае, отрицательное значение считается от конца списка, где -1 соответствует последнему элементу, -2 - предпоследнему элементу и так далее.\n\nНапример, чтобы получить последний элемент списка my_list в Python, можно использовать следующую команду:\n\n```pythonthon\nlast_element = my_list[-1]\n```\n\nТакже можно использовать отрицательные значения для срезов (slicing) списка, например:\n\n```pythonthon\nmy_list[-3:] # вернет последние три элемента списка\nmy_list[:-2] # вернет все элементы списка, кроме последних двух\nmy_list[::-1] # вернет список в обратном порядке\n```\n\nНо следует учесть, что если индекс отрицательный и его абсолютное значение больше или равно длине списка, будет возбуждено исключение IndexError.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 12,
  "fields": {
    "question": "Что значит конструкция pass?",
    "answer": "В Python, pass является пустым оператором. Он используется там, где синтаксически требуется оператор, но никаких действий выполнять не нужно. Например, это может быть полезно при написании заглушки функции, которая будет реализована позже, или в цикле, который ничего не должен делать на данной итерации. Пример использования конструкции pass:\n\n```pythonthon\ndef my_function():\n    pass # заглушка для функции, которая будет реализована позже\n\nfor i in range(10):\n    if i < 3:\n        pass # ничего не делать на первых трёх итерациях\n    else:\n        print(i) # вывести значения на всех остальных итерациях\n```\n\nВ обоих случаях pass играет роль пустого оператора, который не выполняет никаких действий, но позволяет синтаксически корректно описать код.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 13,
  "fields": {
    "question": "Что такое python?",
    "answer": "Python - это язык программирования высокого уровня, интерпретируемый, с динамической типизацией и автоматическим управлением памятью. Он был разработан в конце 1980-х годов Гвидо ван Россумом и имеет широкую популярность среди разработчиков благодаря своей простоте и эффективности. Python широко применяется в различных областях, включая науку о данных, машинное обучение, веб-разработку, игровую индустрию, GIS и многие другие.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 14,
  "fields": {
    "question": "В каком году написана первая статья про python",
    "answer": "Автором Python является голландец Гвидо Ван Россум. Этот язык он начал проектировать в конце 1980-х годов, во время работы в голландском институте CWI. За основу он взял язык программирования ABC, в разработке которого он когда участвовал.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 2,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 15,
  "fields": {
    "question": "Какие типы данных есть в python? На какие классы делятся?",
    "answer": "Python поддерживает множество различных встроенных типов данных, включая:\n\n- Числа: int, float, и complex.\n- Строки: str.\n- Списки: list.\n- Кортежи: tuple.\n- Словари: dict.\n- Множества: set.\n- Булевы значения: bool.\n\nЭти типы данных можно разделить на несколько классов:\n\n- Числовые типы данных: int, float, и complex.\n- Строковые типы данных: str.\n- Коллекции: list, tuple, dict, и set.\n- Булевы типы данных: bool.\n\nКаждый тип предоставляет свои собственные методы и функции для работы с данными, а также поддерживает операции, которые могут выполняться на них, такие как арифметические и логические операции.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 16,
  "fields": {
    "question": "Что такое лямбда-функция? Какое у неё назначение?",
    "answer": "Лямбда-функция (tакже известна как \"анонимная функция\") - это функция, которая определяется в одной строке кода без использования ключевого слова def. Она может быть использована вместо обычной функции, когда требуется быстрое определение небольшой функции.\n\nВ Python лямбда-функция определяется с помощью ключевого слова lambda, за которым следует список аргументов через запятую, затем символ :, и наконец, тело функции.\n\nНапример, чтобы определить лямбда-функцию, которая удваивает свой аргумент, можно написать:\n\n```pythonthon\ndouble = lambda x: x * 2\n```\n\nЛямбда-функции в основном используются в качестве аргументов функций высшего порядка , которые принимают другие функции в качестве аргументов. Также они могут использоваться для создания более читаемого и компактного кода.\n\nНапример, можно использовать лямбда-функцию вместо объявления обычной функции для преобразования списка:\n\n```pythonthon\nnumbers = [1, 2, 3, 4, 5]\nsquares = list(map(lambda x: x**2, numbers))\n```\n\nЭтот пример создает список квадратов чисел в списке numbers с помощью функции map(), принимающей лямбда-функцию в качестве аргумента.\n\nТаким образом, лямбда-функция в Python позволяет определять небольшие функции быстро и использовать их в качестве аргументов для других функций.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 17,
  "fields": {
    "question": "Что такое PEP 8?",
    "answer": "PEP 8 (Python Enhancement Proposal 8) - это документ, который содержит рекомендации по написанию кода на языке Python. Он содержит стилевые соглашения, которые, следуя практике, повышают читабельность кода, делая его более понятным, расширяемым и поддерживаемым. Документ был опубликован в 2001 году и рекомендуется как основной стандарт написания кода Python. PEP 8 охватывает такие темы, как именование переменных, расположение отступов, длина строк, комментарии, импорты и многое другое.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 18,
  "fields": {
    "question": "Как получить документацию по атрибутам объекта?",
    "answer": "В Python вы можете получить документацию по атрибутам объекта с помощью атрибута doc. Например, если у вас есть объект с атрибутом attribute_name, то вы можете получить его документацию следующим образом:\n\n```pythonthon\nprint(attribute_name.__doc__)\n```\n\nВы также можете использовать встроенную функцию help() для получения подробной информации о любом объекте, включая его атрибуты. Просто передайте объект в функцию help(), чтобы получить всю доступную документацию:\n\n```pythonthon\nhelp(attribute_name)\n```\n\nНебольшое уточнение: doc отображает документацию для конкретного атрибута или метода. Если вы хотите получить общую документацию для объекта, вызовите help() без параметров (т.е. help(object_name)).\n\nНапример, если у вас есть класс с атрибутом attribute_name, вы можете получить его документацию следующим образом:\n\n```pythonthon\nclass MyClass:\n    \"\"\"This is the docstring for MyClass.\"\"\"\n    attribute_name = \"value\"\n\nprint(MyClass.attribute_name.__doc__)\n```\n\nЭтот код выведет документацию для атрибута attribute_name, которая будет равна None, так как мы не определили документацию для него в классе. Теперь мы можем использовать функцию help() для получения документации для самого класса:\n\n```pythonthon\nhelp(MyClass)\n```\n\nЭто приведет к выводу всей доступной документации для MyClass, включая документацию для его атрибута attribute_name.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 19,
  "fields": {
    "question": "Что такое docstring?",
    "answer": "Docstring в Python - это строка документации, которая описывает, что делает функция, метод, модуль или класс Python. Данная строка располагается в начале определения объекта и используется для генерации документации автоматически. В других словах, docstring используется для создания описания API и содержит информацию о том, как использовать функцию или метод, какие аргументы они принимают и какие значения возвращают.\n\nНапример:\n\n```pythonthon\ndef add_numbers(a, b):\n    \"\"\"\n    This function takes in two numbers and returns their sum\n    \"\"\"\n    return a + b\n```\n\nВ данном примере, docstring - это строка между тройными кавычками, после имени функции. Она описывает, что делает функция и как ее использовать.\n\nDocstring является важным инструментом в Python разработке, так как важно документировать ваш код для себя и для других разработчиков. Документированный код легче поддерживать и понимать, что облегчает разработку и сотрудничество.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 20,
  "fields": {
    "question": "В чём разница между типами list и tuple?",
    "answer": "В Python, список (list) и кортеж (tuple) являются двумя различными типами данных, которые предоставляют набор элементов в определенном порядке. Основная разница между ними заключается в том, что список может быть изменен (мутабельный тип), а кортеж является неизменяемым (иммутабельным типом).\n\nТо есть, после создания кортежа, вы не можете изменять его содержимое, добавлять или удалять элементы. Это делает кортежи более эффективными по памяти и дает гарантию того, что их содержимое не будет изменено случайно в коде. В то время как список может быть изменен, что было бы очень полезно, если вам нужна коллекция элементов, которые вы можете изменять по ходу выполнения кода.\n\nДругая разница между списком и кортежем заключается в скорости доступа к элементам. За счет того, что кортежи являются неизменным типом данных, они обрабатываются быстрее, чем списки.\n\nНапример, для создания списка в Python используется квадратная скобка, а для создания кортежа используется круглая скобка. Вот примеры использования списков и кортежей:\n\n```pythonthon\nmy_list = [1, 2, 3, 4, 5] # Это список\nmy_tuple = (1, 2, 3, 4, 5) # Это кортеж\n```\n\nCписок может быть изменен, например, можно добавить элемент в список:\n\n```pythonthon\nmy_list.append(6)\n```\n\nНо не можем добавить элемент в кортеж, так как он неизменяем:\n\n```pythonthon\nmy_tuple.append(6) # Эта строка вызовет ошибку\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 21,
  "fields": {
    "question": "Может ли быть индекс списка отрицательным?",
    "answer": "Да, индекс списка может быть отрицательным. В таком случае, отрицательное значение считается от конца списка, где -1 соответствует последнему элементу, -2 - предпоследнему элементу и так далее.\n\nНапример, чтобы получить последний элемент списка my_list в Python, можно использовать следующую команду:\n\n```pythonthon\nlast_element = my_list[-1]\n```\n\nТакже можно использовать отрицательные значения для срезов (slicing) списка, например:\n\n```pythonthon\nmy_list[-3:] # вернет последние три элемента списка\nmy_list[:-2] # вернет все элементы списка, кроме последних двух\nmy_list[::-1] # вернет список в обратном порядке\n```\n\nНо следует учесть, что если индекс отрицательный и его абсолютное значение больше или равно длине списка, будет возбуждено исключение IndexError.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 22,
  "fields": {
    "question": "Что значит конструкция pass?",
    "answer": "В Python, pass является пустым оператором. Он используется там, где синтаксически требуется оператор, но никаких действий выполнять не нужно. Например, это может быть полезно при написании заглушки функции, которая будет реализована позже, или в цикле, который ничего не должен делать на данной итерации. Пример использования конструкции pass:\n\n```pythonthon\ndef my_function():\n    pass # заглушка для функции, которая будет реализована позже\n\nfor i in range(10):\n    if i < 3:\n        pass # ничего не делать на первых трёх итерациях\n    else:\n        print(i) # вывести значения на всех остальных итерациях\n```\n\nВ обоих случаях pass играет роль пустого оператора, который не выполняет никаких действий, но позволяет синтаксически корректно описать код.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 23,
  "fields": {
    "question": "Чем отличаются многопоточное и многопроцессорное приложение?",
    "answer": "Многопоточное и многопроцессорное приложения отличаются друг от друга в том, как они используют ресурсы компьютера. В многопроцессорных приложениях каждый процесс имеет свой собственный набор ресурсов, включая память, открытые файлы, сетевые соединения и другие системные ресурсы. В многопоточных приложениях несколько потоков выполняются в рамках одного процесса, используя общие ресурсы. Это означает, что все потоки имеют доступ к общим данным.\n\nРеализация многопоточности в Python выполняется за счет стандартной библиотеки threading. Многопроцессорность в Python может быть достигнута с помощью библиотек multiprocessing и concurrent.futures.\n\nПри правильном использовании оба подхода могут ускорить выполнение программы и улучшить управляемость ею, однако многопоточное приложение может иметь проблемы с блокировками и условиями гонки при доступе к общим ресурсам. В многопроцессорных приложениях каждый процесс защищен от других процессов и обеспечивает более высокую степень изоляции.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 24,
  "fields": {
    "question": "Как просмотреть методы объекта?",
    "answer": "Чтобы посмотреть все методы и атрибуты, связанные с определенным объектом в Python, можно использовать функцию dir(). Она принимает объект в виде аргумента и возвращает список имен всех атрибутов и методов объекта. Например, если нужно увидеть все методы и атрибуты, связанные с объектом my_list, следующее:\n\n```pythonthon\nmy_list = [1, 2, 3]\nprint(dir(my_list))\n```\n\nЭто выведет список всех методов и атрибутов, которые можно использовать с объектом my_list.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 25,
  "fields": {
    "question": "Что такое \\*args и \\*\\*kwargs в определении функции?",
    "answer": "*args и \\*\\*kwargs - это специальные параметры в Python, которые позволяют передавать переменное количество аргументов в функцию. Параметр *args используется для передачи переменного количества аргументов без ключевого слова. Он представляет собой кортеж из всех дополнительных аргументов, переданных функции. Параметр \\*\\*kwargs используется для передачи переменного количества именованных аргументов. Он представляет собой словарь из всех дополнительных именованных аргументов, переданных функции.\n\nCимвол \\* и \\*\\* могут использоваться в определении функций для указания переменного числа аргументов, которые могут быть переданы в функцию.\n\nСимвол * перед именем параметра означает, что все позиционные аргументы, которые не были использованы при определении других параметров, будут собраны в кортеж, который можно будет использовать внутри функции. Такой параметр называется *args. Например:\n\n```pythonthon\ndef my_fun(a, b, *args):\n    print(a, b, args)\n```\n\nВызов функции my_fun(1, 2, 3, 4, 5) выведет на экран следующее:\n\n```pythonthon\n1 2 (3, 4, 5)\n```\n\nСимвол ** перед именем параметра означает, что все именованные аргументы, которые не были использованы при определении других параметров, будут собраны в словарь, который можно будет использовать внутри функции. Такой параметр называется **kwargs. Например:\n\n```pythonthon\ndef my_fun(a, b, **kwargs):\n    print(a, b, kwargs)\n```\n\nВызов функции my_fun(1, 2, x=3, y=4, z=5) выведет на экран следующее:\n\n```pythonthon\n1 2 {'x': 3, 'y': 4, 'z': 5}\n```\n\nИспользование \\*args и \\*\\*kwargs позволяет создавать более гибкие функции, которые могут принимать любое количество аргументов.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 26,
  "fields": {
    "question": "Python полностью поддерживает ООП?",
    "answer": "Да, Python является полностью объектно-ориентированной языковой средой. Он поддерживает все основные принципы объектно-ориентированного программирования (ООП), такие как наследование, инкапсуляция и полиморфизм.\n\nВ Python все объекты в явном виде являются экземплярами классов, и даже типы данных, такие как список или словарь, являются классами со своими методами и атрибутами.\n\nКроме того, Python поддерживает множественное наследование, который позволяет создавать новые классы, которые наследуют методы и атрибуты от нескольких родительских классов одновременно.\n\nВ целом, Python предоставляет множество инструментов для написания кода в объектно-ориентированном стиле, и это один из главных его преимуществ, особенно для написания крупных и сложных приложений.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 27,
  "fields": {
    "question": "Что такое globals() и locals()?",
    "answer": "globals() и locals() - это встроенные функции в Python, которые возвращают словари глобальных и локальных переменных соответственно.\n\nglobals() возвращает словарь, содержащий все глобальные переменные, доступные в текущей области видимости, включая встроенные переменные.\n\nlocals() возвращает словарь, содержащий все локальные переменные, определенные в текущей области видимости. Это включает аргументы функции и переменные, которым присвоено значение внутри функции.\n\nНапример, вот как можно использовать эти функции:\n\n```pythonthon\nx = 5\ny = 10\n\ndef my_func(z):\n    a = 3\n    print(globals())  # выводит все глобальные переменные\n    print(locals())   # выводит все локальные переменные\n\nmy_func(7)\n```\n\nВ этом примере функция my_func() принимает один аргумент и определяет две локальные переменные (a и z). Когда она вызывается, она выводит на экран словари глобальных и локальных переменных.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 28,
  "fields": {
    "question": "Что хранится в атрибуте **dict**?",
    "answer": "Атрибут **dict** содержит словарь, который хранит атрибуты объекта в виде пар ключ-значение. Этот словарь заполняется значениями при создании объекта и может быть изменен позже. Например, если у вас есть объект класса Person, и вы создаете его экземпляр person1, то вы можете добавить новый атрибут age и присвоить ему значение 25 следующим образом:\n\n```pythonthon\nclass Person:\n    def __init__(self, name):\n        self.name = name\n    def say_hello(self):\n        print(\"Hello, my name is\", self.name)\n\nperson1 = Person(\"Alice\")\nperson1.age = 25\nprint(person1.__dict__)\n```\n\nЭто выведет словарь, содержащий пару ключ-значение `{'name': 'Alice', 'age': 25}`.\n\nВы можете обратиться к любому атрибуту объекта, используя либо обычную запись `person1.name`, либо запись, использующую словарь `python person1.__dict__[\"name\"]`.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 29,
  "fields": {
    "question": "Как проверить файл .py на синтаксические ошибки, не запуская его?",
    "answer": "Утилита py_compile, позволит проверить файл .py на наличие синтаксических ошибок без его запуска.\n\nВы можете использовать командную строку или терминал для проверки файла .py на наличие синтаксических ошибок, не запуская его, используя флаг -m с модулем py_compile. Вот как это сделать:\n\nОткройте командную строку или терминал.\nПерейдите в каталог, содержащий файл .py, который вы хотите проверить.\nВыполните следующую команду:\n\n```pythonthon\npython -m py_compile yourfile.py\n```\n\nгде yourfile.py - это имя файла, который вы хотите проверить.\n\nЭта команда выполнит проверку файла и выведет описание любых синтаксических ошибок, которые были найдены, или пустой вывод, если ошибок нет.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 30,
  "fields": {
    "question": "Зачем в python используется ключевое слово self?",
    "answer": "В Python ключевое слово self используется для обращения к текущему объекту класса. Оно передается как первый аргумент в методы класса и позволяет работать с атрибутами и методами объекта класса внутри этих методов.\n\nК примеру, рассмотрим класс Person, который имеет атрибут name и метод say_hello:\n\n```pythonthon\nclass Person:\n    def __init__(self, name):\n        self.name = name\n\n    def say_hello(self):\n        print(f\"Hello, my name is {self.name}\")\n```\n\nЗдесь мы можем обратиться к атрибуту name объекта класса Person с помощью ключевого слова self. Аналогично, мы можем вызвать метод say_hello, который также использует self для доступа к атрибуту name:\n\n```pythonthon\nperson = Person(\"Alice\")\nperson.say_hello() # выведет \"Hello, my name is Alice\"\n```\n\nТаким образом, self позволяет нам работать с атрибутами и методами объекта класса внутри его методов.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 31,
  "fields": {
    "question": "Что такое декоратор? Как написать собственный?",
    "answer": "Декоратор в Python - это функция, которая принимает другую функцию в качестве аргумента и расширяет ее функциональность без изменения ее кода. Декораторы могут использоваться для добавления логирования, проверки аутентификации, тайминга выполнения и других аспектов.\n\nВот пример создания декоратора:\n\n```pythonthon\ndef my_decorator(func):\n    def wrapper():\n        print(\"Дополнительный код, который исполняется перед вызовом функции\")\n        func()\n        print(\"Дополнительный код, который исполняется после вызова функции\")\n    return wrapper\n\n@my_decorator\ndef say_hello():\n    print(\"Привет!\")\n\nsay_hello()\n```\n\nЭтот код создает декоратор my_decorator, который добавляет дополнительный код до и после выполнения функции say_hello(). Декоратор применяется к say_hello() с помощью синтаксиса @my_decorator.\n\nВыходные данные:\n\n```pythonthon\nДополнительный код, который исполняется перед вызовом функции\nПривет!\nДополнительный код, который исполняется после вызова функции\n```\n\nТаким образом, написав свой собственный декоратор, вы можете расширить функциональность функций, не изменяя их исходный код.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 32,
  "fields": {
    "question": "Что может быть ключом в словаре?",
    "answer": "В Python ключом в словаре может быть любой неизменяемый объект, такой как число, строка или кортеж. Например:\r\n\r\n```python\r\nmy_dict = {1: 'one', 'two': 2, (3, 4): 'three four'}\r\n```\r\n\r\nВ этом примере ключами словаря являются число 1, строка 'two' и кортеж (3, 4). Однако, если вы попытаетесь использовать изменяемый объект, такой как список, как ключ словаря, вы получите TypeError:\r\n\r\n```python\r\nmy_dict = {[1, 2]: 'one two'}\r\n# this will raise a TypeError: unhashable type: 'list'\r\n```\r\n\r\nТакже, если вы попытаетесь добавить два ключа в словарь с одинаковым хеш-кодом, то второй ключ перезапишет первый:\r\n\r\n```python\r\nmy_dict = {1: 'one', '1': 'one again'}\r\n# this will result in {1: 'one again'}\r\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 2,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 33,
  "fields": {
    "question": "В чём разница между пакетами и модулями?",
    "answer": "Модуль - это файл, содержащий код Python, который может быть повторно использован в других программах.\n\nПакет - это директория, содержащая один или несколько модулей (или пакетов внутри пакетов), а также специальный файл **init**.py, который выполняется при импорте пакета. Он может содержать код, который инициализирует переменные, функции и классы, и становится доступным для использования внутри модулей, находящихся внутри этого пакета.\n\nТаким образом, основная разница между модулем и пакетом заключается в том, что модуль - это файл с кодом, который можно использовать повторно, а пакет - это директория, которая может содержать один или несколько модулей. Код, находящийся в файле **init**.py, может инициализировать переменные, функции и классы, что обеспечивает общую функциональность для всех модулей, находящихся внутри пакета.\n\nНапример, если у нас есть пакет mypackage, в нем может находится несколько модулей, таких как module1.py, module2.py. В файле **init**.py определяются функции и переменные, которые могут использоваться внутри module1 и module2.\n\nНекоторые примеры импорта:\n\n```pythonthon\nimport mymodule # импортируем модуль\nfrom mypackage import mymodule # импортируем модуль из пакета\nfrom mypackage.mymodule import myfunction # импортируем функцию из модуля в пакете\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 34,
  "fields": {
    "question": "Как перевести строку, содержащую двоичный код (1 и 0), в число?",
    "answer": "Для того, чтобы перевести строку, содержащую двоичный код, в целое число в Python, нужно воспользоваться функцией int(), передав ей вторым аргументом основание системы счисления - в данном случае 2. Например:\n\n```pythonthon\nbinary_str = '110101'\ndecimal_num = int(binary_str, 2)\nprint(decimal_num)\n```\n\nВывод:\n\n```pythonthon\n53\n```\n\nТакже можно использовать цикл для прохода по символам строки и вычисления двоичного числа. Вот пример такого цикла:\n\n```pythonthon\nbinary_str = '110101'\ndecimal_num = 0\nfor i in range(len(binary_str)):\n    decimal_num += int(binary_str[i]) * 2**(len(binary_str)-i-1)\n\nprint(decimal_num)\n```\n\nЭтот код также выведет 53.\nВывод:\n\n```pythonthon\n53\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 35,
  "fields": {
    "question": "Для чего используется функция **init**?",
    "answer": "Функция **init** является конструктором класса, и она вызывается автоматически при создании нового экземпляра класса. Эта функция используется для инициализации атрибутов, которые будут принадлежать объектам, создаваемым с помощью класса. Внутри функции **init** определяются атрибуты объекта, которые будут доступны через ссылку на экземпляр, на который ссылается переменная self.\n\nПример:\n\n```pythonthon\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\nperson1 = Person(\"John\", 30)\nperson2 = Person(\"Alice\", 25)\n\nprint(person1.name)  # output: John\nprint(person2.age)   # output: 25\n```\n\nВ этом примере функция **init** устанавливает два атрибута экземпляра для каждого объекта, создаваемого с помощью класса Person: name и age. Когда мы создаем новый объект, мы передаем эти аргументы в функцию **init**, чтобы инициализировать соответствующие атрибуты.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 36,
  "fields": {
    "question": "Что такое слайс(slice)?",
    "answer": "Слайс (slice) - это способ извлечения определенной части последовательности (например, строки, списка, кортежа) с использованием индексации.\n\nСинтаксис для создания слайса:\n\n```pythonthon\nsequence[start:end:step]\n```\n\nгде `start` - индекс, с которого начинается извлечение (включительно), end - индекс, на котором заканчивается извлечение (не включая его), и `step` - шаг для извлечения элементов (по умолчанию равен 1). Обратите внимание, что если не указывать `start`, то по умолчанию он равен 0, а если не указывать `end`, то по умолчанию он равен длине последовательности.\n\nВот пример использования слайса для выбора подряд идущих элементов списка (list):\n\n```pythonthon\nmy_list = [0, 1, 2, 3, 4, 5]\nmy_slice = my_list[1:4] # выбираем элементы с индексами от 1 до 3 включительно\nprint(my_slice) # выведет [1, 2, 3]\n```\n\nВ этом примере мы использовали слайс `my_list[1:4]` для выбора элементов списка с индексами от 1 до 3 включительно.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 37,
  "fields": {
    "question": "Как проверить, что один кортеж содержит все элементы другого кортежа?",
    "answer": "Для проверки того, содержит ли один кортеж все элементы другого кортежа в Python, можно воспользоваться встроенной функцией all(), передав ей выражение генератора списков, которое проверяет наличие каждого элемента из второго кортежа в первом кортеже. Например:\n\n```pythonthon\nfirst_tuple = (1, 2, 3, 4, 5)\nsecond_tuple = (2, 4, 5)\n\ncontains_all = all(elem in first_tuple for elem in second_tuple)\n\nprint(contains_all)  # True\n```\n\nЭтот код создает два кортежа first_tuple и second_tuple и затем использует генератор списка, чтобы проверить, содержит ли first_tuple все элементы из second_tuple. Результат будет True, если все элементы второго кортежа содержатся в первом кортеже, и False в противном случае.\n\nЕсли вам нужно проверить, содержит ли кортеж все элементы из другой последовательности, не обязательно кортежа, вы можете использовать преобразование типа set() для сравнения их элементов, как показано ниже:\n\n```pythonthon\nfirst_tuple = (1, 2, 3, 4, 5)\nsome_list = [2, 4, 5]\n\ncontains_all = set(some_list).issubset(set(first_tuple))\nprint(contains_all)  # True\n```\n\nЭтот код дает тот же результат, что и предыдущий пример, но здесь мы преобразуем элементы some_list и first_tuple в множество и используем метод issubset() для проверки, содержит ли первое множество все элементы второго множества.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 38,
  "fields": {
    "question": "Почему пустой список нельзя использовать как аргумент по умолчанию?",
    "answer": "Значения по умолчанию для аргументов функции вычисляются только один раз, когда функция определяется, а не каждый раз, когда она вызывается. Таким образом, если вы попытаетесь использовать изменяемый тип данных (например, список) как аргумент по умолчанию для функции, то каждый вызов функции, который изменяет это значение, также изменит значение по умолчанию для всех последующих вызовов функции. Это может привести к неожиданным поведениям.\n\nПустой список - это изменяемый тип данных в Python, поэтому его использование в качестве аргумента по умолчанию не рекомендуется. Вместо этого лучше использовать None в качестве значения по умолчанию и создавать новый пустой список внутри функции, если требуется список. Например:\n\n```pythonthon\ndef my_function(my_list=None):\n    if my_list is None:\n        my_list = []\n    # do something with my_list\n```\n\nТаким образом, вы всегда можете быть уверены, что получаете новый объект списка при каждом вызове функции.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 39,
  "fields": {
    "question": "Что такое @classmethod, @staticmethod, @property?",
    "answer": "`@classmethod, @staticmethod, and @property` - это декораторы методов класса в языке Python.\n\n`@classmethod` декоратор используется для создания методов, которые будут работать с классом в целом, а не с отдельным экземпляром. В качестве первого параметра этот метод принимает класс, а не экземпляр объекта, и часто используется для создания фабричных методов и методов, которые работают с класс-уровнем методов.\n\n`@staticmethod` декоратор работает подобно @classmethod, но он не получает доступ к классу в качестве первого параметра.\n\n`@property` декоратор используется для создания свойств объекта, которые можно получить и задать, но выглядят как обычные атрибуты объекта. Это позволяет управлять доступом к атрибутам объекта, установив условиями доступа и возможностью заложить дополнительную логику при чтении, установке или удалении атрибута.\n\nНапример, явное использование декораторов может выглядеть так:\n\n```pythonthon\nclass MyClass:\n    def __init__(self, value):\n        self._value = value\n\n    @classmethod\n    def from_string(cls, input_string):\n        value = process_input_string(input_string)\n        return cls(value)\n\n    @staticmethod\n    def process_input_string(input_string):\n        # implementation details\n\n    @property\n    def value(self):\n        return self._value\n\n    @value.setter\n    def value(self, new_value):\n        if new_value < 0:\n            raise ValueError(\"Value must be positive\")\n        self._value = new_value\n```\n\nДекорированные методы могут быть использованы для достижения различных целей, таких как доступ к класс-уровню, расширение функциональности объекта и управление доступом к атрибутам.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 40,
  "fields": {
    "question": "Что такое синхронный код?",
    "answer": "Синхронный код - это код, который выполняется последовательно, один за другим, и блокирует выполнение других задач до его завершения. Это означает, что если у вас есть функция, которая занимает много времени на выполнение, и вы вызываете ее в основной программе, то выполнение программы заблокируется до завершения этой функции.\n\nПримером синхронного кода в Python может служить следующий фрагмент, который содержит цикл while, обрабатывающий список элементов:\n\n```pythonthon\nitems = [1, 2, 3, 4, 5]\nfor item in items:\n    print(item)\n```\n\nЗдесь цикл for будет обрабатывать каждый элемент в списке items последовательно, один за другим, и не будет переходить к следующему элементу, пока не завершится обработка текущего элемента.\n\nВыполнение синхронного кода может занять много времени и может вызвать проблемы с производительностью, особенно когда код выполняет блокирующие операции, такие как чтение и запись файлов, обращение к сети, или поиск значений в базе данных. Для решения этой проблемы в Python используют асинхронное программирование с использованием конструкций async/await и библиотеки asyncio. Они позволяют выполнять несколько задач асинхронно, не блокируя выполнение других задач, и добиваться более высокой производительности.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 41,
  "fields": {
    "question": "Что такое асинхронный код? Приведите пример.",
    "answer": "Асинхронный код - это подход к написанию кода, который позволяет выполнять несколько задач одновременно в рамках одного процесса. Это достигается за счет использования асинхронных функций и корутин. В отличие от синхронного кода, который выполняет каждую задачу последовательно, асинхронный код может запустить несколько задач \"параллельно\" и организовать их выполнение с помощью итераций и вызовов коллбеков.\n\nПримером использования асинхронного кода является библиотека asyncio в Python. Например, вот простой пример кода, который использует asyncio для запуска нескольких задач одновременно и ожидания их завершения:\n\n```pythonthon\nimport asyncio\n\nasync def hello():\n    await asyncio.sleep(1)\n    print(\"Hello\")\n\nasync def world():\n    await asyncio.sleep(2)\n    print(\"World\")\n\nasync def main():\n    await asyncio.gather(hello(), world())\n\nif __name__ == '__main__':\n    asyncio.run(main())\n```\n\nВ этом примере мы определяем 3 асинхронные функции: hello(), world() и main(). Функции hello() и world() печатают соответствующие сообщения и ждут 1 и 2 секунды соответственно. Функция main() запускает эти две функции одновременно с помощью asyncio.gather() и ждет, пока они завершат свою работу. Затем мы запускаем функцию main() с помощью asyncio.run(). В результате мы получим сообщения \"Hello\" и \"World\", каждое через 1 и 2 секунды соответственно, при этом результаты двух задач были получены почти одновременно.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 42,
  "fields": {
    "question": "Каким будет результат следующего выражения?",
    "answer": "```pythonthon\n    >>> -30 % 10\n    ```\n\nРезультатом выражения \"-30 % 10\" будет - 0. Это происходит потому, что оператор % возвращает остаток от деления первого числа на второе, и в данном случае -30 можно разбить на целое количество десяток и остаток 0. Поэтому -30 % 10 равно 0.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 43,
  "fields": {
    "question": "Для чего нужен метод id()?",
    "answer": "Метод id() используется для получения уникального целочисленного идентификатора (адреса в памяти) объекта. Этот идентификатор может быть использован для сравнения объектов, поскольку два объекта будут иметь одинаковый идентификатор только в том случае, если это один и тот же объект в памяти.\n\nНапример, если у вас есть две переменные, которые ссылаются на один и тот же объект, то их идентификаторы будут равны:\n\n```pythonthon\na = [1, 2, 3]\nb = a\nprint(id(a))  # выведет адрес в памяти объекта a\nprint(id(b))  # выведет адрес в памяти объекта b\n```\n\nОднако, если у вас есть две переменные, которые ссылаются на разные объекты, их идентификаторы будут отличаться:\n\n```pythonthon\na = [1, 2, 3]\nb = [1, 2, 3]\nprint(id(a))  # выведет адрес в памяти объекта a\nprint(id(b))  # выведет адрес в памяти объекта b (отличный от идентификатора a)\n```\n\nИспользование метода id() может быть полезно при отладке или проверке, какие переменные ссылаются на один и тот же объект. Однако, в общем случае, использование метода id() не рекомендуется, поскольку это может быть неэффективным при работе с большим количеством объектов в памяти.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 44,
  "fields": {
    "question": "Что такое итератор?",
    "answer": "Итератор (Iterator) — это объект, который возвращает свои элементы по одному за раз. Он должен иметь метод **next**(), который возвращает следующий элемент и вызывает исключение StopIteration, когда элементы закончились. Итератор также может быть написан с помощью генераторов.\n\nПример использования итератора в Python:\n\n```pythonthon\n# Создаем список\nmy_list = [1, 2, 3, 4, 5]\n\n# Получаем итератор из списка\nmy_iterator = iter(my_list)\n\n# Выводим элементы итератора\nprint(next(my_iterator))   # выведет 1\nprint(next(my_iterator))   # выведет 2\nprint(next(my_iterator))   # выведет 3\n```\n\nВ этом примере мы создаем список и получаем из него итератор. Затем мы выводим элементы итератора с помощью функции next(), которая вызывает метод **next**() объекта итератора. Каждый вызов функции next() выводит следующий элемент, пока не закончатся элементы списка, после чего будет вызвано исключение StopIteration.\n\nЕще один способ создания итераторов в Python — использование генераторов. Генератор — это функция, которая возвращает итерируемый объект (такой, как список или кортеж). Вместо того, чтобы возвращать все элементы сразу, генератор возвращает элементы по одному по мере необходимости.\n\nНапример:\n\n```pythonthon\n# Определяем генератор\ndef my_generator():\n    yield 1\n    yield 2\n    yield 3\n    yield 4\n    yield 5\n\n# Получаем итератор из генератора\nmy_iterator = my_generator()\n\n# Выводим элементы итератора\nprint(next(my_iterator))   # выведет 1\nprint(next(my_iterator))   # выведет 2\nprint(next(my_iterator))   # выведет 3\nprint(next(my_iterator))   # выведет 4\nprint(next(my_iterator))   # выведет 5\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 45,
  "fields": {
    "question": "Что такое генератор? Чем отличается от итератора?",
    "answer": "Генератор - это функция, которая использует ключевое слово yield для возврата итератора. Генератор может быть использован для создания последовательности значений, которые генерируются в момент обращения к ним, что позволяет эффективно использовать память и ускоряет выполнение программы.\n\nОтличие генератора от итератора заключается в том, что итератор используется для обхода коллекции (например, списка) до тех пор, пока все элементы не будут перебраны, а генератор используется для создания последовательности значений. Итераторы также могут быть созданы как классы, которые реализуют методы **iter**() и **next**(), в то время как генераторы создаются при помощи функций и используют ключевое слово yield.\n\nПример использования генератора, который генерирует последовательность чисел от 0 до n включительно:\n\n```pythonthon\ndef my_generator(n):\n    for i in range(n + 1):\n        yield i\n\nmy_gen = my_generator(5)\n\nfor i in my_gen:\n    print(i)\n```\n\nЭтот код создаст объект генератора my_gen, который можно использовать для последовательного получения каждого из значений, произведенных генератором при помощи ключевого слова yield.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 46,
  "fields": {
    "question": "Для чего используется ключевое слово yield?",
    "answer": "Ключевое слово \"yield\" используется для создания генераторов. Генератор - это функция, которая может возвращать последовательность значений используя инструкции yield вместо return. При каждом вызове инструкции yield генератор возвращает значение, после чего сохраняет свое состояние и приостанавливает свое выполнение до следующего вызова. Это позволяет генерировать последовательности значений без необходимости создания и хранения всех значений в памяти, что может быть особенно полезно при работе с большими объемами данных. Кроме того, генераторы являются итерируемыми и могут использоваться в циклах for.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 47,
  "fields": {
    "question": "Чем отличаются **iter** и **next**?",
    "answer": "**iter** и **next** являются методами специальных методов в Python, которые обеспечивают поддержку итерации для объектов.\r\n\r\nМетод **iter** возвращает объект, который может быть использован для итерации по элементам контейнера. Объект, возвращаемый **iter**, должен содержать метод **next**.\r\n\r\nМетод **next** должен вернуть следующий элемент в итерации или вызвать исключение StopIteration, если элементов больше нет.\r\n\r\nТаким образом, метод **iter** используется для создания итератора, а метод **next** используется для перехода к следующему элементу в итерации.\r\n\r\nВ общем случае, класс должен определять метод **iter**, который возвращает сам объект класса, и метод **next**, который определяет, какие элементы будут возвращены при итерации.\r\n\r\nНапример:\r\n\r\n```python\r\nclass MyIterator:\r\n    def __init__(self, data):\r\n        self.index = 0\r\n        self.data = data\r\n\r\n    def __iter__(self):\r\n        return self\r\n\r\n    def __next__(self):\r\n        if self.index >= len(self.data):\r\n            raise StopIteration\r\n        result = self.data[self.index]\r\n        self.index += 1\r\n        return result\r\n```\r\n\r\nМетод **iter** возвращает сам объект, а метод **next** возвращает следующий элемент data каждый раз, когда вызывается.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 2,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 48,
  "fields": {
    "question": "Что такое контекстный менеджер?",
    "answer": "Контекстный менеджер в Python - это объект, который определяет вход и выход из контекста с помощью методов **enter**() и **exit**(). Контекстный менеджер может быть использован в блоке with для выполнения конкретных действий при входе и выходе из блока. Например, контекстный менеджер может устанавливать и закрывать соединение с базой данных, блокировать и разблокировать файлы или временно изменять настройки системы.\n\nВот простой пример, демонстрирующий использование контекстного менеджера для работы с файлом:\n\n```pythonthon\nwith open('file.txt', 'r') as f:\n    data = f.read()\n```\n\nВ этом примере open() возвращает контекстный менеджер f. Когда блок with начинается, вызывается метод **enter**() контекстного менеджера, который открывает файл. Затем выполняется код в блоке, который использует f для чтения данных из файла. При завершении блока with вызывается метод **exit**() контекстного менеджера, который закрывает файл.\n\nКонтекстные менеджеры в Python используются для обращения с ресурсами, которые должны быть корректно открыты и закрыты, включая файлы, сетевые соединения, блокировки и базы данных. Кроме того, их можно использовать для временной модификации состояния системы или окружения в блоках with.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 49,
  "fields": {
    "question": "Как сделать python-скрипт исполняемым в различных операционных системах?",
    "answer": "Для того чтобы сделать Python-скрипт исполняемым в различных операционных системах, можно воспользоваться утилитой PyInstaller, которая позволяет упаковать скрипт в исполняемый файл для Windows, Linux и macOS.\n\nЧтобы установить PyInstaller, можно выполнить следующую команду в командной строке:\n\n```pythonthon\npip install pyinstaller\n```\n\nПосле установки PyInstaller необходимо перейти в директорию с Python-скриптом и запустить утилиту с соответствующими параметрами для создания исполняемого файла. Например:\n\n```pythonthon\npyinstaller myscript.py --onefile\n```\n\nЭта команда создаст единый исполняемый файл myscript.exe (для Windows) или myscript (для Linux/macOS), который можно запустить на соответствующих операционных системах.\n\nЕсли нужно создать исполняемый файл с определенными параметрами, можно воспользоваться другими параметрами PyInstaller, такими как --icon для добавления иконки, --name для задания имени исполняемого файла и т.д.\n\nНо стоит отметить, что PyInstaller не является универсальным решением и возможна потребность в использовании других инструментов в зависимости от конкретной задачи и требований к исполняемому файлу.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 50,
  "fields": {
    "question": "Как сделать копию объекта? Как сделать глубокую копию объекта?",
    "answer": "Метод copy() создает поверхностную копию объекта, то есть создает новый объект, который содержит ссылки на те же объекты, что и исходный объект. Если вы измените какой-либо из этих объектов, изменения отразятся и на копии, и на исходном объекте.\n\nМетод deepcopy() создает глубокую копию объекта, то есть создает новый объект, который содержит копии всех объектов, на которые ссылаются элементы исходного объекта. Если вы измените какой-либо из этих объектов, изменения не отразятся на копии или на исходном объекте.\n\nВот примеры использования этих методов:\n\n```pythonthon\nimport copy\n\n# создание копии объекта\nnew_list = old_list.copy()\n\n# создание глубокой копии объекта\nnew_list = copy.deepcopy(old_list)\nгде old_list - исходный список, а new_list - его копия.\n```\n\nПримечание: для выполнения глубокого копирования объектов, сами объекты также должны поддерживать копирование. Если объекты в ваших данных не поддерживают копирование, deepcopy() вернет исходный объект, а не его копию.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 51,
  "fields": {
    "question": "Опишите принцип работы сборщика мусора в python.",
    "answer": "Python использует автоматическое управление памятью, что означает, что разработчику не нужно явно выделять или освобождать память в своем коде. Вместо этого в Python есть встроенный сборщик мусора, который автоматически управляет памятью для объектов, на которые больше нет ссылок.\n\nСборщик мусора запускается периодически и ищет объекты, на которые больше не ссылается ни одна переменная в коде. Затем эти объекты идентифицируются как мусор и удаляются из памяти. Сборщик мусора работает, отслеживая ссылки на объекты в памяти, используя механизм подсчета ссылок. Каждый раз, когда создается новая ссылка на объект, счетчик ссылок для этого объекта увеличивается. Точно так же, когда ссылка удаляется, счетчик ссылок уменьшается.\n\nОднако одного подсчета ссылок недостаточно для обработки всех случаев управления памятью. В некоторых случаях могут быть циклические ссылки, когда два или более объекта ссылаются друг на друга и больше не нужны. Для обработки этих случаев сборщик мусора Python использует вторичный механизм, называемый «обнаружение циклов». Этот механизм периодически ищет циклические ссылки среди объектов, и если они найдены, он знает, что нужно удалить циклическую ссылку и освободить память.\n\nВ целом, сочетание подсчета ссылок и обнаружения циклов позволяет Python автоматически управлять памятью и обеспечивать очистку объектов, когда они больше не нужны. Это приводит к более эффективному использованию памяти и снижает риск нехватки памяти в приложениях, которые долго работают или интенсивно используют память.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 52,
  "fields": {
    "question": "Как использовать глобальные переменные? Это хорошая идея?",
    "answer": "Для использования глобальных переменных достаточно объявить их за пределами функций и классов. Например:\n\n```pythonthon\n# объявляем глобальную переменную\nglobal_var = 42\n\ndef my_func():\n    # можно использовать глобальную переменную\n    global global_var\n    print(global_var)\n\n# вызываем функцию\nmy_func()\n```\n\nОднако, использование глобальных переменных не всегда считается хорошей практикой программирования, так как это может привести к ошибкам при изменении значения переменной в разных частях программы. Вместо этого, рекомендуется использовать локальные переменные внутри функций или передавать значения между функциями через параметры и возвращаемые значения.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 53,
  "fields": {
    "question": "Для чего в классе используется атрибут **slots**?",
    "answer": "Атрибут **slots** в классе Python используется для оптимизации памяти и ускорения работы с объектами класса. Он позволяет явно указать, какие атрибуты объекта будут использоваться, а какие нет.\n\nКогда вы определяете класс, Python создает для каждого экземпляра этого класса словарь, который содержит все его атрибуты. Это может быть выгодным в том случае, если у вас много различных атрибутов, но может привести к большому расходу памяти, если вы создаете много экземпляров класса с небольшим количеством атрибутов.\n\nАтрибут **slots** позволяет определить, какие атрибуты должны быть на самом деле созданы для каждого экземпляра класса, и в какой момент их можно будет получить. Если вы используете атрибут **slots**, Python уже не будет создавать словарь для каждого экземпляра класса, а будет использовать непосредственно массив атрибутов, что может ускорить работу программы и уменьшить использование памяти.\n\nНапример, если у вас есть класс Person с атрибутами name и age, вы можете определить **slots** следующим образом:\n\n```pythonthon\nclass Person:\n    __slots__ = ['name', 'age']\n\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n```\n\nТаким образом, каждый экземпляр класса Person будет содержать только атрибуты name и age, и никакие другие атрибуты не будут созданы.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 54,
  "fields": {
    "question": "Какие пространства имен существуют в python?",
    "answer": "Пространство имен — это совокупность определенных в настоящий момент символических имен и информации об объектах, на которые они ссылаются.\n\nPython имеет множество встроенных пространств имен. Некоторые из них включают:\n\nbuiltins: содержит встроенные функции и типы, которые доступны в любой области видимости по умолчанию.\n\nmain: это специальное пространство имен, которое содержит определения, которые были выполнены на верхнем уровне скрипта или интерактивной оболочки Python.\n\nname: это атрибут, который содержит имя текущего модуля. Если модуль импортирован, то значение name будет именем модуля. Если модуль запускается как скрипт, то значение name будет \"main\".\n\nglobals(): это функция, которая возвращает словарь, содержащий все имена в глобальной области видимости.\n\nlocals(): это функция, которая возвращает словарь, содержащий все имена в локальной области видимости.\n\nЭто далеко не полный список, но это некоторые из наиболее распространенных пространств имен в Python.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 55,
  "fields": {
    "question": "Как реализуется управление памятью в python?",
    "answer": "Управление памятью осуществляется автоматически с помощью механизма сборки мусора (Garbage collector). Когда объект в Python больше не нужен (например, после того как на него уже нет ссылок), он помечается как garbage (мусор), после чего он будет автоматически удален при следующем запуске сборщика мусора.\n\nИспользуется метод подсчета ссылок для отслеживания того, когда объект уже не нужен, и этот объект должен быть освобожден. Кроме того, Python также использует циклический сборщик мусора (Cycle detector), который может определить и удалить объекты, на которые ссылается другой объект, на который уже нет ссылок.\n\nСборка мусора в Python использует алгоритм под названием \"reference counting\", который подсчитывает количество ссылок на каждый объект в памяти. Когда количество ссылок на объект становится равным нулю, он помечается как мусор и память автоматически освобождается. В Python также реализованы другие алгоритмы сборки мусора, такие как \"generational garbage collection\", который разбивает объекты на несколько \"поколений\" и собирает мусор с различной частотой в зависимости от поколения, в котором они находятся, но reference counting является основой управления памятью в Python.\n\nМодуль gc в Python также предлагает дополнительный функционал для управления памятью. Например, метод gc.collect() позволяет сделать принудительную сборку мусора.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 56,
  "fields": {
    "question": "Что такое метаклассы и в каких случаях их следует использовать?",
    "answer": "Метаклассы - это классы, которые определяют поведение других классов. Они используются для изменения способа, которым Python создает и обрабатывает классы.\n\nМетаклассы могут быть полезны в следующих случаях:\n\n- При необходимости динамического изменения поведения класса, например, если вы хотите добавить или удалить атрибут или метод класса во время выполнения программы.\n\n- При создании классов из данных, которые не заранее известны. Например, вы можете создавать классы на основе определенных условий во время выполнения программы.\n- Для создания фреймворков и библиотек, которые нужно настраивать под конкретные требования и при этом сохранить простоту интерфейса.\n\nОни также могут использоваться для создания классов с определенными свойствами, например, классов, которые автоматически регистрируются в библиотеке или классов, которые автоматически сериализуются и десериализуются для совместимости с другими системами.\n\nПример использования метакласса для добавления атрибута к классу:\n\n```pythonthon\nclass MyMeta(type):\n    def __new__(cls, name, bases, dct):\n        dct['my_attribute'] = 42\n        return super(MyMeta, cls).__new__(cls, name, bases, dct)\n\nclass MyClass(metaclass=MyMeta):\n    pass\n\nprint(MyClass.my_attribute)\n```\n\nВ этом примере создается метакласс MyMeta, который добавляет атрибут my_attribute к любому классу, который использует данный метакласс для своего создания. Затем создается класс MyClass, который использует метакласс MyMeta. При вызове print(MyClass.my_attribute) выводится значение 42, так как этот атрибут был добавлен в момент создания класса.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 57,
  "fields": {
    "question": "Зачем нужен pdb?",
    "answer": "pdb - это интерактивный отладчик для Python, с помощью которого можно перемещаться по коду во время запуска вашей программы, смотреть и изменять значения переменных, построчно навигироваться по коду (в том числе углубляться во вложенности кода), назначать брейкпоинты и все прочие операции присущие отладчику.\n\nМодуль pdb предоставляет интерфейс командной строки, который можно использовать для взаимодействия с кодом Python во время его выполнения. Вы можете войти в режим pdb в своей программе Python, вставив следующую строку кода там, где вы хотите остановить отладчик: импортировать PDB;\n\n```pythonthon\nimport pdb;\npdb.set_trace()\n```\n\nКогда интерпретатор дойдет до этой строки, он приостановится, и можно использовать команды pdb для проверки состояния вашей программы. Таким образом, pdb — это полезный инструмент для отладки кода Python, поскольку он позволяет в интерактивном режиме проверять состояние кода и выявлять проблемы.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 58,
  "fields": {
    "question": "Каким будет результат следующего выражения?",
    "answer": "```pythonthon\n    >>> [0, 1][10:]\n```\n\nВыражение >>> [0, 1][10:] возвращает пустой список [], так как срез [10:] означает извлечение элементов начиная с индекса 10 и до конца списка [0, 1], но таких элементов нет.\n\nТаким образом, результатом выражения >>> [0, 1][10:] является пустой список [].",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 59,
  "fields": {
    "question": "Как создать класс без слова class?",
    "answer": "Kласс можно создать без использования ключевого слова class, используя типы type или metaclass. Например, следующий код определяет класс MyClass без использования ключевого слова class:\n\n```pythonthon\nMyClass = type('MyClass', (), {'x': 42, 'foo': lambda self: self.x})\n```\n\nЭтот код эквивалентен определению класса с использованием ключевого слова class:\n\n```pythonthon\nclass MyClass:\n    x = 42\n\n    def foo(self):\n        return self.x\n```\n\nОба определения класса эквивалентны и создают объект класса MyClass. Однако, использование ключевого слова class обычно является более явным и удобным.\n\nJбратите внимание, что использование типов type или metaclass для создания класса может быть менее читабельным и более сложным для понимания, чем использование ключевого слова class.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 60,
  "fields": {
    "question": "Как перезагрузить импортированный модуль?",
    "answer": "Чтобы перезагрузить импортированный модуль в Python, вы можете использовать функцию reload() из модуля importlib. Вот как это сделать:\n\n```pythonthon\nfrom importlib import reload\nimport module_name\n\nreload(module_name)\n```\n\nЗамените module_name на фактическое имя модуля, который вы хотите перезагрузить.\n\nЭто может быть полезно при разработке и тестировании модулей, но не рекомендуется использовать в производственном коде без серьезных причин.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 61,
  "fields": {
    "question": "Напишите декоратор, который будет перехватывать ошибки и повторять функцию максимум N раз.",
    "answer": "Вот пример декоратора на Python, который будет перехватывать ошибки и повторять функцию максимум N раз:\n\n```pythonthon\nimport functools\n\ndef retry(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        max_retries = 3\n        for i in range(max_retries):\n            try:\n                result = func(*args, **kwargs)\n                return result\n            except Exception as e:\n                print(f'Error occurred: {e}. Retrying ({i+1}/{max_retries})...')\n        raise Exception(f'Function {func.__name__} failed after {max_retries} attempts.')\n    return wrapper\n\n```\n\nДля использования декоратора вам нужно добавить @retry перед определением функции, которую вы хотите обернуть:\n\n```pythonthon\n@retry\ndef my_function(arg1, arg2):\n    # ваш код здесь\n\n```\n\nВ этом примере функция my_function будет повторно вызываться до трех раз в случае ошибки, до тех пор, пока она не выполнится успешно. Если после трех попыток функция не выполнится успешно, вы получите исключение.\n\nВы можете настроить параметр max_retries, чтобы изменить количество попыток или добавить его как аргумент декоратора, чтобы делать эти настройки динамически.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 62,
  "fields": {
    "question": "Каким будет результат следующего выражения?",
    "answer": "```pythonthon\n    >>> len(' '.join(list(map(str, [[0], [1]]))))\n```\n\nВот разбивка того, как был получен этот результат:\n\n- Внутреннее выражение map(str, [[0], [1]]) преобразует целые значения 0 и 1 в строки, в результате чего получается ['0', '1'].\n- Затем функция списка преобразует этот итератор в список.\n- Метод соединения соединяет элементы списка пробелом, в результате чего получается строка «0 1».\n- Наконец, функция len возвращает длину этой строки, которая равна 3.\n\nРезультат — 3.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 63,
  "fields": {
    "question": "Python — легкий язык. Согласны?",
    "answer": "Однозначного ответа нет.\nХотя Python обладает простым и понятным синтаксисом, его мощные возможности и богатая стандартная библиотека делают его достаточно сложным языком. Кроме того, Python используется в различных областях программирования, от web-разработки и научного моделирования до искусственного интеллекта и машинного обучения, что делает его еще более многофункциональным и ставит его в один ряд с другими языками программирования.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 64,
  "fields": {
    "question": "Какие проблемы есть в python?",
    "answer": "Python, как и любой язык программирования, имеет свой набор потенциальных проблем и ограничений. Вот некоторые из распространенных проблем, с которыми сталкиваются разработчики при работе с Python:\n\n- Глобальная блокировка интерпретатора (GIL) — это механизм в реализации Python на CPython, который предотвращает одновременное выполнение кода Python несколькими потоками. В некоторых случаях это может ограничить производительность задач, связанных с процессором.\n\n- Управление пакетами и зависимостями. Управление сторонними пакетами и зависимостями в Python иногда может быть сложным, особенно для крупных проектов или в сложных средах.\n\n- Производительность. Хотя Python обычно считается быстрым языком, он не может быть оптимальным выбором для задач, требующих высокой производительности, таких как машинное обучение или научные вычисления.\n\n- Типизация и статический анализ. Python — это язык с динамической типизацией, что может затруднить обнаружение определенных типов ошибок во время компиляции.\n\n- Управление памятью: автоматическое управление памятью в Python может в некоторых случаях привести к утечке памяти или неэффективному использованию памяти.\n\n- Документация: Хотя сообщество Python уделяет большое внимание документации, некоторые пакеты или библиотеки могут иметь неполную или устаревшую документацию, что может затруднить их эффективное использование.\n\nСтоит отметить, что многие из этих проблем не уникальны для Python, и часто существуют обходные пути или решения. Кроме того, Python имеет большое и активное сообщество пользователей и разработчиков, которые постоянно работают над улучшением языка и решением этих и других проблем.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 65,
  "fields": {
    "question": "Когда будет выполнена ветка else в конструкции try…except…else?",
    "answer": "Ветка else в конструкции try…except…else будет выполнена только в том случае, если исключения не было возбуждено в блоке try. Если в блоке try произошло исключение, то выполнение программы переходит к соответствующему блоку except, и ветка else пропускается. Если блок except не указан, то исключение будет возбуждено дальше, а программа завершится с сообщением об ошибке.\n\nПример, в котором будет выполнена ветка else:\n\n```pythonthon\ntry:\n    # some code here\nexcept:\n   # code to handle the exception\nelse:\n   # code to execute if there is no exception\n```\n\nЕсли в блоке try не возникает исключений, то выполняется код в блоке else.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 66,
  "fields": {
    "question": "Поддерживает ли python множественное наследование?",
    "answer": "Да, Python поддерживает множественное наследование. Это означает, что класс может наследовать функциональность от нескольких предков, путем указания их имен в скобках при определении класса.\n\nНапример:\n\n```pythonthon\nclass MyBaseClass1:\n    pass\n\nclass MyBaseClass2:\n    pass\n\nclass MyDerivedClass(MyBaseClass1, MyBaseClass2):\n    pass\n```\n\nВ этом случае MyDerivedClass является подклассом MyBaseClass1 и MyBaseClass2, и поэтому наследует их функциональность. Класс MyDerivedClass может использовать методы и атрибуты, определенные в MyBaseClass1 и MyBaseClass2.\n\nСуществует несколько способов объявления класса, который наследует от нескольких родительских классов, но один из распространенных способов - это просто указать несколько родительских классов в скобках при определении класса-потомка.\n\nCледующий код определяет класс MyClass, который наследует от классов Parent1 и Parent2:\n\n```pythonthon\nclass Parent1:\n    def method1(self):\n        print(\"This is a method from Parent1\")\n\nclass Parent2:\n    def method2(self):\n        print(\"This is a method from Parent2\")\n\nclass MyClass(Parent1, Parent2):\n    pass\n\nobj = MyClass()\nobj.method1() # outputs \"This is a method from Parent1\"\nobj.method2() # outputs \"This is a method from Parent2\"\n```\n\nПриведенный выше код создает MyClass, который наследует свойства и методы как от класса Parent1, так и от класса Parent2. Вы можете вызвать методы как от Parent1, так и от Parent2 через объект MyClass.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 67,
  "fields": {
    "question": "Как dict и set реализованы внутри? Какова сложность получения элемента? Сколько памяти потребляет каждая структура?",
    "answer": "Dict и Set реализованы в виде хэш-таблицы.\n\nХэш-таблица - это структура данных, которая использует хэш-функцию для преобразования ключа в индекс в массиве, где хранятся значения. Затем элемент добавляется в массив по соответствующему индексу.\n\nСложность получения элемента в Dict и Set в наилучшем случае составляет O(1), поскольку элемент может быть получен просто с помощью хэш-функции в качестве индекса массива. Однако в худшем случае, когда возникают хэш-коллизии, сложность может вырасти до O(n), где n - количество элементов в таблице.\n\nТакже стоит заметить, что сложность операций добавления, удаления и поиска элементов в Set и Dict также составляет O(1) в наилучшем случае и O(n) в худшем случае.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 68,
  "fields": {
    "question": "Что такое MRO? Как это работает?",
    "answer": "MRO (Method Resolution Order) - это порядок разрешения методов, который используется в языке программирования Python при наследовании классов.\n\nКогда вызывается метод на экземпляре класса, Python ищет этот метод в самом классе, а затем в его родительских классах в порядке, определенном в MRO. Таким образом, MRO управляет тем, как Python ищет методы, которые были унаследованы из нескольких родительских классов.\n\nПорядок MRO может быть определен несколькими способами, но в общем случае MRO определяется с помощью алгоритма C3, который гарантирует, что порядок разрешения методов будет соблюдать локальный порядок наследования каждого класса и не создавать циклов в определении этого порядка.\n\nНапример, если класс A наследуется от классов B и C, а класс B наследуется от класса D, а класс C наследуется от класса E, то MRO для класса A будет определен как [A, B, D, C, E, object]. Это означает, что если существует метод, определенный в классе A и в одном из его родительских классов, то метод из класса A будет вызван, а не из его родительских классов.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 69,
  "fields": {
    "question": "Как аргументы передаются в функции: по значению или по ссылке?",
    "answer": "В Python аргументы передаются по ссылке на объект. Это означает, что когда вы передаете объект в качестве аргумента функции, функция получает ссылку на этот объект, а не его копию. Если вы модифицируете объект внутри функции, эти изменения будут отражены и вне функции, так как обе переменные (внутри и вне функции) ссылаются на один и тот же объект в памяти. Однако, если внутри функции вы присваиваете новое значение аргументу, это не изменит значение переменной, которую вы использовали при вызове функции, потому что эта переменная по-прежнему ссылается на тот же объект в памяти.\n\nНапример:\n\n```pythonthon\ndef increment(x):\n    x += 1\n    return x\n\ny = 10\nprint(increment(y)) # Output: 11\nprint(y) # Output: 10\n```\n\nЗдесь модификации x внутри функции не влияют на значение переменной y, так как теперь x ссылается на новый объект в памяти (увеличенное значение на 1), но y по-прежнему ссылается на старый объект (изначальное значение 10).\n\nПри работе со изменяемыми объектами (например, списками), модификация объекта внутри функции будет отражаться вне функции. Например:\n\n```pythonthon\ndef modify_list(lst):\n    lst.append(4)\n\nmy_list = [1, 2, 3]\nmodify_list(my_list)\nprint(my_list) # Output: [1, 2, 3, 4]\n```\n\nЗдесь модификации списка lst в функции modify_list отражаются и на переменной my_list, так как обе переменные ссылаются на один и тот же список в памяти.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 70,
  "fields": {
    "question": "С помощью каких инструментов можно выполнить статический анализ кода?",
    "answer": "Для статического анализа кода есть несколько инструментов:\n\n- Pylint - это инструмент, который анализирует исходный код на соответствие PEP8, а также предупреждает о потенциальных ошибках в коде.\n\n- Flake8 - это комбинированный инструмент, который объединяет в себе Pylint, PyFlakes и множество других правил, обеспечивающих соответствие стиля написания кода и обнаруживающих ошибки в исходном коде.\n\n- Mypy - это статический типизатор для Python, который позволяет находить ошибки в типах переменных в исходном коде.\n\n- Bandit - это инструмент для поиска уязвимостей в исходном коде Python.\n\n- Black - это инструмент для автоматического форматирования кода Python, который придерживается только одного стиля написания кода.\n- Pycodestyle — это простая консольная утилита для анализа кода Python, а именно для проверки кода на соответствие PEP8. Один из старейших анализаторов кода, до 2016 года носил название pep8, но был переименован по просьбе создателя языка Python Гвидо ван Россума.\n- Vulture — это небольшая утилита для поиска “мертвого” кода в программах Python. Она использует модуль ast стандартной библиотеки и создает абстрактные синтаксические деревья для всех файлов исходного кода в проекте. Далее осуществляется поиск всех объектов, которые были определены, но не используются. Vulture полезно применять для очистки и нахождения ошибок в больших базовых кодах.\n\nЭти инструменты могут улучшить качество кода, облегчить его чтение и поддержку, а также помочь избежать ошибок, связанных с типами переменных и уязвимостями безопасности.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 71,
  "fields": {
    "question": "Что будет напечатано в результате выполнения следующего кода?",
    "answer": "```pythonthon\n    import sys\n    arr_1 = []\n    arr_2 = arr_1\n    print(sys.getrefcount(arr_1))\n```\n\nВ результате выполнения данного кода будет напечатано число, равное количеству ссылок на объект arr_1, которые существуют в настоящий момент времени. Так как мы создаем две переменные, arr_1 и arr_2, которые ссылаются на один и тот же пустой список [], то количество ссылок на него будет равно 2. Поэтому в результате выполнения данного кода будет напечатано число 2. Эта величина может быть немного больше, чем ожидается, из-за внутренней оптимизации CPython, которая добавляет временные ссылки на объекты.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 72,
  "fields": {
    "question": "Что такое GIL? Почему GIL всё ещё существует?",
    "answer": "GIL (Global Interpreter Lock) - это механизм в интерпретаторе CPython , который гарантирует, что только один поток исполнения может выполнять байт-код Python в любой момент времени. Это было добавлено в Python для обеспечения безопасности потоков в многопоточной среде и для упрощения реализации интерпретатора.\n\nGIL всё ещё существует, потому что он является важной частью интерпретатора CPython и его логики работы с потоками. Однако, недавние версии Python имеют некоторые механизмы для обхода ограничений GIL, такие как использование многопроцессных вычислений вместо многопоточных и использование асинхронного программирования. Кроме того, есть и другие реализации языка Python, такие как Jython и IronPython, которые не используют GIL.\n\nТаким образом, вопрос насколько существование GIL ограничивает производительность Python в настоящее время является разногласием в сообществе.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 73,
  "fields": {
    "question": "Опишите процесс компиляции в python.",
    "answer": "Python — это интерпретируемый язык, а это значит, что он не требует компиляции, как C или C++. Вместо этого интерпретатор Python читает и выполняет исходный код напрямую. Однако Python использует форму компиляции, называемую компиляцией байт-кода.\n\nКогда сценарий Python запускается в первый раз, интерпретатор компилирует его в байтовый код, представляющий собой низкоуровневое представление исходного кода. Затем этот байт-код выполняется виртуальной машиной Python (PVM), которая представляет собой интерпретатор, который считывает байт-код и выполняет его.\n\nБайт-код хранится в каталоге **pycache** с расширением .pyc. Python проверяет, есть ли у файла .py уже соответствующий файл .pyc, и, если файл .pyc старше файла .py, он компилирует файл .py в новый файл .pyc.\n\nТаким образом, процесс «компиляции» в Python включает интерпретатор, который компилирует исходный код в байтовый код, который затем выполняется PVM. Однако этот процесс происходит автоматически и за кулисами, без необходимости пользователю явно вызывать отдельный шаг компиляции.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 74,
  "fields": {
    "question": "Как тиражировать python код?",
    "answer": "Реплицировать (т.е. создавать копии) Python кода, то можно воспользоваться различными инструментами и техниками, такими как использование систем контроля версий, например, Git или SVN, или создание образов виртуальных машин с помощью Docker, VirtualBox, Vagrant и т.д. Это позволит вам легко скопировать и развернуть копии вашего приложения на других устройствах или серверах. Вы также можете использовать специальные инструменты для сборки вашего приложения в исполняемый файл, такие как pyinstaller или cx_Freeze, что позволит запускать ваше приложение на других машинах без установки Python.\n\nЕсли вам нужно повторно использовать код в вашей программе, в Python есть несколько способов эффективного переиспользования кода, таких как функции, модули, классы и библиотеки. Вы можете создавать свои собственные функции и модули, которые могут быть использованы в вашем приложении, и использовать сторонние библиотеки для решения определенных задач.\n\nНапример, для копирования файлов в Python вы можете использовать модуль shutil, который позволяет легко копировать, перемещать и удалять файлы:\n\n```pythonthon\nimport shutil\n\n# copy file from source to destination\nshutil.copy('/path/to/source/file.txt', '/path/to/destination')\nОбратите внимание, что для использования этого модуля необходимо импортировать его в ваш код.\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 75,
  "fields": {
    "question": "Что такое дескрипторы? Есть ли разница между дескриптором и декоратором?",
    "answer": "Дескрипторы - это объекты Python, которые определяют, как другие объекты должны вести себя при доступе к атрибуту. Дескрипторы могут использоваться для реализации протоколов, таких как протокол доступа к атрибутам, протокол дескрипторов и протокол методов.\n\nДекораторы - это функции Python, которые принимают другую функцию в качестве аргумента и возвращают новую функцию. Декораторы обычно используются для изменения поведения функции без изменения ее исходного кода.\n\nРазница между дескриптором и декоратором заключается в том, что дескрипторы используются для определения поведения атрибутов объекта, в то время как декораторы используются для изменения поведения функций. Однако, декораторы могут использоваться для реализации протоколов дескрипторов.\n\nНапример, декоратор @property можно использовать для создания дескриптора доступа к атрибутам. Он преобразует метод класса в дескриптор, который позволяет получать, устанавливать и удалять значение атрибута как обычный атрибут объекта.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 76,
  "fields": {
    "question": "Почему всякий раз, когда python завершает работу, не освобождается вся память?",
    "answer": "Python использует автоматическое управление памятью с помощью механизма сборки мусора, который освобождает память, занятую объектами, которые больше не используются в программе. Однако, до того как механизм сборки мусора может освободить память объекта, все ссылки на этот объект должны быть удалены. Если в программе остаются ссылки на объекты, которые больше не нужны, то эти объекты не будут удалены до окончания работы приложения.\n\nТакже может случиться, что размер объектов, которые использует программа, слишком велик для доступной оперативной памяти. В этом случае операционная система может начать использовать файл подкачки, что может замедлить работу программы.\n\nЕсли вы столкнулись с проблемой утечки памяти, то можно воспользоваться инструментами, такими как memory_profiler для Python, которые помогут выявить места, где память не освобождается, и найти способы ее оптимизации.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 77,
  "fields": {
    "question": "Что будет напечатано в результате выполнения следующего кода?",
    "answer": "```pythonthon\n    class Variable:\n\n    def __init__(self, name, value):\n        self._name = name\n        self._value = value\n\n    @property\n    def value(self):\n        print(self._name, 'GET', self._value)\n        return self._value\n\n    @value.setter\n    def value(self, value):\n        print(self._name, 'SET', self._value)\n        self._value = value\n\n    var_1 = Variable('var_1', 'val_1')\n    var_2 = Variable('var_2', 'val_2')\n    var_1.value, var_2.value = var_2.value, var_1.value\n```\n\nПри выполнении этого кода будет выведено следующее:\n\n```pythonthon\nvar_2 GET val_2\nvar_1 GET val_1\nvar_2 SET val_1\nvar_1 SET val_2\n```\n\nВ этом коде определяется класс Variable со свойствами \"name\" и \"value\". Метод @property используется для определения свойства значения, которое можно прочитать с помощью \"getter\" (функция, используемая для получения значения свойства) и установить новое значение с помощью \"setter\" (функция, используемая для установки нового значения свойства). Затем создаются два экземпляра класса, и значения их свойств \"value\" меняются по очереди с помощью кортежа. При каждом вызове метода 'value' класса Variable выводится сообщение о том, что происходит (GET - когда значение свойства читается, SET - когда устанавливается новое значение свойства).",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 78,
  "fields": {
    "question": "Что такое интернирование строк? Почему это есть в python?",
    "answer": "Интернирование строк - это процесс, при котором две или более строковые переменные, содержащие одинаковое значение, ссылаются на один и тот же объект в памяти. В Python интернирование строк происходит автоматически при создании строковых констант в исходном коде программы. Это означает, что если две или более строковые константы содержат одинаковое значение, они будут ссылаются на один и тот же объект в памяти.\n\nИнтернирование строк применяется для оптимизации использования памяти и ускорения выполнения программы. Поскольку операция сравнения двух строк, ссылающихся на один и тот же объект в памяти, выполняется быстрее, чем сравнение двух строк, которые хранятся в разных объектах в памяти.\n\nВ Python интернирование строк применяется для строковых констант, которые состоят из символов ASCII и имеют длину не более 20 символов. Это объясняется тем, что длинные строки могут занимать слишком много места в памяти, что может привести к проблемам производительности.\n\nИнтернирование строк является одним из многих способов оптимизации производительности, доступных в Python. Оно позволяет ускорить выполнение программы за счет сокращения использования памяти и оптимизации операций сравнения строк.\n\nПример кода, который демонстрирует интернирование строк в Python:\n\n```pythonthon\na = 'hello'\nb = 'hello'\nprint(a is b) # True, потому что обе переменные ссылаются на один и тот же объект в памяти\n\nc = 'hello world'\nd = 'hello world'\nprint(c is d) # False, потому что строка \"hello world\" длиннее 5 символов и не является интернированной\n\ne = '_123'\nf = '_123'\nprint(e is f) # True, потому что строка содержит только цифры и символ '_'\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 79,
  "fields": {
    "question": "Как упаковать бинарные зависимости?",
    "answer": "Для упаковки бинарных зависимостей в проект следует использовать менеджеры пакетов. Для Python наиболее распространены pip и conda. Для Java - Maven или Gradle.\n\nПример для Python с использованием pip:\n\n- Установите необходимые библиотеки и зависимости в проекте:\n\n```pythonthon\npip install requests numpy pandas\n```\n\n- Создайте файл requirements.txt с полным списком зависимостей:\n\n```pythonthon\nrequests\nnumpy\npandas\n```\n\n- Упакуйте зависимости в архив:\n\n```pythonthon\npip freeze > requirements.txt\n```\n\nМожно передать файл requirements.txt другим пользователям вашего проекта, которые могут установить все зависимости одной командой:\n\n```pythonthon\npip install -r requirements.txt\n```\n\nДля упаковки бинарных зависимостей можно использовать инструмент wheel. Wheel-файлы - это zip-архивы, содержащие установочные файлы для Python-пакетов, и могут содержать бинарные расширения (например, скомпилированные модули C), которые необходимо собрать и установить на целевой машине.\n\nДля создания wheel-файла для Python-пакета можно использовать команду pip wheel. Например, если есть файл с требованиями requirements.txt, содержащий список зависимостей вашего проекта, можете создать wheel-файлы для всех зависимостей с помощью следующей команды:\n\n```pythonthon\npip wheel -r requirements.txt\n```\n\nВы также можете установить wheel-файлы с помощью pip install, указав имя файла:\n\n```pythonthon\npip install mypackage-1.0.0-py3-none-any.whl\n```\n\nТаким образом, вы можете создавать и распространять бинарные зависимости в виде wheel-файлов и использовать их при установке пакетов на других устройствах.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 80,
  "fields": {
    "question": "Почему в python нет оптимизации хвостовой рекурсии? Как это реализовать?",
    "answer": "В Python хвостовая рекурсия не оптимизируется автоматически, поскольку она может привести к переполнению стека вызовов. В связи с этим, используется итеративный подход для написания функций, которые могут быть написаны с использованием хвостовой рекурсии в других языках.\n\nОднако вы можете использовать декоратор sys.setrecursionlimit() для установки максимальной глубины стека вызовов. Однако это не рекомендуется, поскольку установка слишком большого лимита может привести к проблемам с производительностью, а слишком маленький лимит - к ошибкам переполнения стека вызовов.\n\nВот пример того, как можно установить максимальную глубину стека вызовов до 4000:\n\n```pythonthon\nimport sys\nsys.setrecursionlimit(4000)\n```\n\nВы также можете изменить код функции, чтобы использовать итеративный подход вместо хвостовой рекурсии. Один пример такого изменения может выглядеть следующим образом:\n\n```pythonthon\ndef factorial(n):\n    result = 1\n    for i in range(1, n+1):\n        result *= i\n    return result\n```\n\nэто вместо использования рекурсивного подхода с вызовом factorial(n-1) внутри функции factorial(n).\n\nИзменение рекурсивно написанной функции на итеративный код не всегда легко, но может существенно повысить производительность и устранить проблемы с переполнением стека вызовов.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 81,
  "fields": {
    "question": "Что такое wheels и eggs? В чём разница?",
    "answer": "В Python wheels и eggs - это форматы пакетов для установки и дистрибуции пакетов с помощью утилиты управления пакетами pip.\n\nEgg был первоначально разработан как формат дистрибуции пакетов для Python, но был заменен wheels. В отличие от wheels, eggs могут содержать .pyc файлы, что может привести к проблемам при установке на другой платформе или версии Python.\n\nWheels - это новый формат дистрибуции пакетов, который был введен в Python 2.7. Он поддерживается большинством пакетов на PyPI и имеет множество преимуществ, например:\n\nОн не содержит .pyc файлов, что снижает вероятность конфликтов.\n\nОн легко переносится между платформами и версиями Python.\n\nОн поддерживает сжатие библиотек и упрощает установку требований.\n\nВ целом, wheels считается более продвинутой и предпочтительной формой дистрибуции пакетов в Python.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 82,
  "fields": {
    "question": "Как получить доступ к модулю, написанному на python из C и наоборот?",
    "answer": "Для того чтобы получить доступ к модулю, написанному на Python из C, можно использовать библиотеку Python/C API, которая позволяет вызывать Python функции и работать с объектами Python из C программы. Для того чтобы получить доступ к модулю, сначала нужно получить указатель на объект модуля с помощью функции PyImport_ImportModule(). Затем можно получить указатель на функции или объекты модуля с помощью функции PyObject_GetAttrString().\n\nНапример, вот пример кода на C, который вызывает функцию \"hello\" из модуля \"example\" на Python:\n\n```C++\n#include <Python.h>\n\nint main() {\n    Py_Initialize();\n    PyObject* module = PyImport_ImportModule(\"example\");\n    PyObject* func = PyObject_GetAttrString(module, \"hello\");\n    PyObject* result = PyObject_CallObject(func, NULL);\n    printf(\"Result: %s\\n\", PyUnicode_AsUTF8(result));\n    Py_DECREF(func);\n    Py_DECREF(module);\n    Py_DECREF(result);\n    Py_Finalize();\n    return 0;\n}\n```\n\nАналогичным образом можно вызвать функции из библиотек, написанных на C из Python, используя библиотеку ctypes. Например, вот пример кода на Python, который вызывает функцию sqrt из библиотеки math:\n\n```pythonthon\nfrom ctypes import cdll\nlibm = cdll.LoadLibrary('libm.so')\nprint(libm.sqrt(4.0))\n```\n\nЗдесь мы загружаем библиотеку libm.so (которая содержит функцию sqrt) и вызываем её с помощью атрибута dot-notation.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 83,
  "fields": {
    "question": "Как ускорить существующий код python?",
    "answer": "Чтобы ускорить существующий код на Python, можно использовать несколько подходов:\n\n- Векторизация: векторизация позволяет оптимизировать код, который выполняет большое количество операций над массивами данных, например, использование библиотеки NumPy.\n\n- Выбор правильных структур данных: выбор правильных структур данных и алгоритмов может значительно ускорить выполнение кода. Например, использование словарей может быть более эффективным, чем использование списков.\n\n- Компиляция: компиляция Python-кода в байт-код или в машинный код может ускорить выполнение кода. Для этого можно использовать Cython, Nuitka или PyPy.\n\n- Многопоточность: использование многопоточности может ускорить выполнение задач, которые можно разделить на несколько независимых частей.\n\n- Параллелизм: параллельное выполнение задач на нескольких ядрах процессора может ускорить выполнение кода.\n\n- Оптимизация: такие инструменты, как cProfile и line_profiler, могут помочь оптимизировать код, выявляя узкие места в его выполнении и предоставляя информацию о времени выполнения каждой строки кода.\n\nКомпромиссы: если выполнение кода нельзя ускорить до приемлемого уровня, можно рассмотреть возможность использования компромиссов, например, уменьшить количество данных, обрабатываемых кодом, или упростить логику выполнения задачи.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 84,
  "fields": {
    "question": "Что такое **pycache**? Что такое файлы .pyc?",
    "answer": "В Python, когда вы запускаете программу, интерпретатор сначала компилирует ее в байт-код и сохраняет в папке **pycache** Это делается для того, чтобы в следующий раз выполнить программу быстрее, поскольку байт-код можно напрямую загрузить в память, а не приходится компилировать заново. Файлы байт-кода имеют расширение .pyc и обычно хранятся в подкаталоге каталога, содержащего соответствующие файлы .py. Каталог **pycache** автоматически создается интерпретатором Python и используется для хранения скомпилированных файлов байт-кода. Каталог содержит скомпилированные версии импортированных сценариев Python, а также любые модули, импортированные этими сценариями. Этот каталог обычно находится в том же каталоге, что и файлы .py, но может также находиться во временном каталоге системы, если исходный каталог доступен только для чтения. Как правило, вам не нужно напрямую взаимодействовать с каталогом **pycache** или файлами .pyc в нем, поскольку они автоматически управляются интерпретатором Python. Однако вы можете удалить файлы .pyc, если хотите заставить интерпретатор перекомпилировать соответствующие скрипты Python.\n\nФайлы .pyc - это скомпилированные байт-коды Python, которые создаются при импорте модулей. Когда вы импортируете модуль в Python, интерпретатор компилирует его и создает файл .pyc, который содержит байт-коды для модуля. Этот файл будет использоваться для ускорения повторных импортов модуля, так как он может быть загружен вместо повторной компиляции каждый раз.\n\nКроме того, файлы .pyc также могут использоваться для распространения скомпилированных версий модулей или приложений. Они представляют собой скомпилированные версии исходных файлов Python, которые можно предоставить пользователям без необходимости предоставления исходного кода.\n\nВажно отметить, что файлы .pyc являются специфичными для версии Python, так что файлы, созданные для одной версии Python, не будут работать с другой версией.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 85,
  "fields": {
    "question": "Что такое виртуальное окружение?",
    "answer": "Виртуальное окружение - это механизм, который позволяет создавать изолированные окружения для установки и использования пакетов Python. Это полезно, когда вам нужно установить определенную версию пакета или когда вам нужно иметь одновременный доступ к разным версиям библиотек в зависимости от проекта.\n\nСоздание виртуального окружения позволяет изолировать зависимости проекта от системных зависимостей и других проектов, работающих на той же машине. Это помогает избежать конфликтов зависимостей, что может привести к ошибкам и сбоям.\n\nВы можете создать виртуальное окружение Python с помощью модуля venv, который поставляется в стандартной библиотеке Python. Например, вы можете создать виртуальное окружение в текущей директории, выполнитив следующую команду в терминале:\n\n```pythonthon\npython3 -m venv myenv\n```\n\nгде myenv - имя виртуального окружения.\n\nПосле создания виртуального окружения вы можете активировать его, выполнив команду (для Unix-системы):\n\n```pythonthon\nsource myenv/bin/activate\n```\n\nили (для Windows):\n\n```pythonthon\nmyenv\\Scripts\\activate\n```\n\nПосле активации виртуального окружения вы можете устанавливать и использовать пакеты Python без влияния на глобальное окружение вашего компьютера.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 86,
  "fields": {
    "question": "Python — это императивный или декларативный язык?",
    "answer": "Python является императивным языком программирования. В императивном программировании программист составляет последовательность команд, которые выполняются компьютером. Python также поддерживает некоторые функциональные и объектно-ориентированные концепции программирования, однако основной подход в языке является императивный.\n\n\"Императивный язык\" это термин, который относится к классу языков программирования, использующих прямые команды для управления компьютером, в отличие от декларативных языков. В императивных языках программист явно описывает действия, которые нужно выполнить компьютеру, а не просто описывает желаемый результат. Примеры императивных языков программирования это Java, C, C++, Python и JavaScript.\n\nДекларативный язык - это язык программирования, который назначает техническую реализацию системы или программы для достижения определенной цели, но не указывает конкретных шагов для ее выполнения. Вместо этого вы определяете, какая информация должна быть обработана, а система сама определяет, как решить эту проблему. Примерами декларативных языков являются SQL для работы с базами данных и HTML для создания веб-страниц. Такие языки обычно используются в случаях, когда важнее задать желаемый результат, чем указать, как добиться этого результата.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 87,
  "fields": {
    "question": "Что такое менеджер пакетов? Какие менеджеры пакетов вы знаете?",
    "answer": "Менеджер пакетов - это инструмент, который позволяет управлять установкой, обновлением и удалением библиотек и зависимостей в проектах на языке Python. Некоторые из наиболее популярных менеджеров пакетов Python:\n\n- pip - это стандартный менеджер пакетов Python. Он позволяет устанавливать пакеты из Python Package Index (PyPI) и других источников, а также управлять зависимостями проекта.\n\n- conda - это менеджер пакетов и среда управления, который позволяет управлять пакетами и зависимостями для проектов на Python, а также для других языков программирования и платформ.\n\n- easy_install - инструмент для установки и управления пакетами Python, который был стандартным до выпуска Python 3. Используется редко в настоящее время.\n\n- poetry - новый менеджер пакетов, предназначенный для замены в некоторой степени pip и virtualenv.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 88,
  "fields": {
    "question": "В чём преимущества массивов numpy по сравнению с (вложенными) списками python?",
    "answer": "Основное преимущество массивов NumPy перед списками Python заключается в том, что NumPy использует более оптимизированную память и имеет более эффективные методы работы с массивами, что делает его подходящим выбором для работы с большими объемами данных и научных вычислений. Например, с NumPy вы можете выполнять бродкастинг (broadcasting), матричные операции и другие векторизованные вычисления с более высокой производительностью, чем при использовании вложенных списков.\n\nНекоторые из основных преимуществ NumPy:\n\n- Более оптимизированная память, что позволяет NumPy работать быстрее с большим объемом данных\n\n- Встроенные методы для выполнения арифметических операций, таких как сумма и произведение, которые могут работать сразу над всеми элементами массивов.\n\n- Возможность выполнять матричные операции и другие векторизованные вычисления.\n\n- Простой синтаксис для выполнения операций над массивами.\n\n- Возможность конвертировать массивы NumPy в другие формы данных, такие как списки Python или таблицы Pandas.\n\nEсли вы работаете с массивами данных, над которыми нужно выполнять научные вычисления, то использование NumPy будет более предпочтительным вариантом, чем использование списков Python.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 89,
  "fields": {
    "question": "Вам нужно реализовать функцию, которая должна использовать статическую переменную. Вы не можете писать код вне функции и у вас нет информации о внешних переменных (вне вашей функции). Как это сделать?",
    "answer": "Вам нужно использовать замыкание. Замыкание - это функция, которая сохраняет ссылку на переменные из своей внешней области видимости, даже когда эта область видимости больше не существует. Это позволяет функции работать с переменной, которая является статической, даже если она была определена вне функции.\n\nВот пример использования замыкания для создания функции, которая использует статическую переменную:\n\n```pythonthon\ndef my_function():\n    static_var = 0\n    def inner_function():\n        nonlocal static_var\n        static_var += 1\n        return static_var\n    return inner_function\n\n# создаем объект функции, который использует статическую переменную\nf = my_function()\n\n# вызываем функцию несколько раз, чтобы увидеть изменение значения статической переменной\nprint(f())  # выводит 1\nprint(f())  # выводит 2\nprint(f())  # выводит 3\n```\n\nЭтот код определяет функцию my_function, которая содержит внутри себя функцию inner_function, которая использует статическую переменную static_var. Каждый раз, когда inner_function вызывается через f(), значение static_var увеличивается на единицу и возвращается новое значение. Таким образом, каждый вызов f() возвращает увеличенное значение статической переменной.\n\nВажно, чтобы вы использовали ключевое слово nonlocal, чтобы объявить static_var как статическую переменную внутри inner_function, иначе Python будет считать ее локальной переменной и создает новую переменную каждый раз, когда inner_function вызывается.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 90,
  "fields": {
    "question": "Что будет напечатано в результате выполнения следующего кода?",
    "answer": "```pythonthon\n    def f_g():\n    yield 43\n    return 66\n\n    print(f_g())\n```\n\nРезультат выполнения кода будет объект генератора (generator object). Когда мы вызываем функцию с yield, то это создает генератор, который возвращает объект-итератор. Так как print(f_g()) вызывает только генератор, а не запускает его выполнение, то мы получим объект-итератор в качестве результата, а не значение, возвращенное посредством yield или return. Если мы хотим получить значение из генератора, мы должны использовать ключевое слово next, чтобы продвинуть генератор на следующее значение или использовать цикл for для извлечения всех значений из итератора. Вот пример вызова генератора с помощью цикла for:\n\n```pythonthon\ndef f_g():\n    yield 43\n    return 66\nfor i in f_g():\n    print(i)\n```\n\nЭтот код выведет только 43, потому что выполнение генератора останавливается после первого вызова yield.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 91,
  "fields": {
    "question": "Как имплементировать словарь с нуля?",
    "answer": "Для имплементации словаря можно использовать хэш-таблицу. Хэш-таблица - это структура данных, которая обеспечивает эффективный поиск, вставку и удаление элементов. Ключи преобразуются в индексы с помощью функции хэширования, и значения хранятся в соответствующих ячейках памяти.\n\nНапример, можно создать класс, который будет имитировать словарь:\n\n```pythonthon\nclass MyDictionary:\n    def __init__(self):\n        self.size = 10 # размер таблицы\n        self.keys = [None] * self.size\n        self.values = [None] * self.size\n\n    def __setitem__(self, key, value):\n        index = hash(key) % self.size # вычисляем индекс\n        self.keys[index] = key\n        self.values[index] = value\n\n    def __getitem__(self, key):\n        index = hash(key) % self.size\n        return self.values[index]\n```\n\nТеперь можно создавать экземпляры этого класса и использовать их, как обычный словарь:\n\n```pythonthon\nd = MyDictionary()\nd['apple'] = 'red'\nd['banana'] = 'yellow'\nprint(d['apple']) # выведет 'red'\nprint(d['banana']) # выведет 'yellow'\n```\n\nЭто простой пример, и на практике словари в Python имеют более сложную реализацию, чтобы обеспечить высокую производительность и эффективность использования памяти.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 92,
  "fields": {
    "question": "Напишите однострочник, который будет подсчитывать количество заглавных букв в файле.",
    "answer": "Для подсчета количества заглавных букв в файле можно использовать следующий однострочник:\n\n```pythonthon\nnum_uppercase = sum(1 for line in open('filename.txt') for character in line if character.isupper())\n```\n\nВ этом однострочнике мы открываем файл 'filename.txt' и пробегаемся по всем его строкам и символам в каждой строке. Для каждого символа, который является заглавной буквой метод isupper() возвращает True, и мы добавляем 1 к счетчику с помощью функции sum(). В конце, num_uppercase будет содержать количество заглавных букв в файле.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 93,
  "fields": {
    "question": "Что такое файлы .pth?",
    "answer": "Файлы с расширением .pth - это файлы, которые могут быть использованы для добавления директорий в путь поиска модулей Python. Директивы .pth выполняются при запуске интерпретатора Python и добавляют определенные каталоги в переменную sys.path. Это удобно, когда нужно импортировать модули из нестандартных директорий без необходимости переноса файлов в директории по умолчанию. Использование директив .pth достаточно распространено в мире Python и они встречаются в различных средах разработки и фреймворках, таких как PyTorch.\n\nФайлы .pth могут быть также использованы злоумышленниками для внедрения вредоносного кода в систему Python, так как они могут изменять список каталогов, в которых выполняется поиск модулей Python. Поэтому необходимо быть внимательными при работе с такими файлами и использовать только те файлы .pth, которые вы знаете и доверяете.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 94,
  "fields": {
    "question": "Какие функции из collections и itertools вы используете?",
    "answer": "В модулях collections и itertools в Python есть множество полезных функций, которые могут использоваться в различных задачах. Некоторые из наиболее часто используемых функций включают:\n\n- defaultdict: это удобный способ создания словаря с заданным значением по умолчанию для любого ключа, который еще не был добавлен в словарь.\n\n- Counter: это удобный способ подсчета количества встречаемых элементов в списке или другом итерируемом объекте. Он возвращает объект, который можно использовать как словарь, где ключами являются элементы, а значения - количество их вхождений.\n\n- namedtuple: можно создать именованный кортеж с заданными полями, что может быть удобно для работы с данными, которые имеют структуру, но не требуют создания класса.\n\n- itertools.chain: позволяет конкатенировать несколько итерируемых объектов в единый итератор.\n\n- itertools.groupby: позволяет группировать элементы итерируемого объекта по заданному ключу.\n\n- itertools.combinations и itertools.permutations: генерируют все различные комбинации или перестановки элементов из заданного множества.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 95,
  "fields": {
    "question": "Что делает флаг PYTHONOPTIMIZE?",
    "answer": "Флаг -O или PYTHONOPTIMIZE в Python используется для оптимизации скомпилированного кода, что может привести к ускорению выполнения программы. Этот флаг удаляет отладочную информацию, отключает asset checks, asserts и отладочные проверки.\n\nСтандартная оптимизация -O удаляет docstrings из скомпилированного byte-code, а также удаляет assert statements. С флагом -OO удаляются все docstrings в модулю (включая те, которые не соответствуют многострочным строкам) и также удаляются assert statements.\n\nЗапуск интерпретатора Python с флагом -O может уменьшить размер скомпилированного кода и сократить потребление памяти, что может привести к ускорению работы программы. Однако, для большинства приложений, эта оптимизация может не иметь значимого влияния на производительность.\n\nНапример, для запуска скрипта с флагом -O, можно использовать следующую команду в командной строке:\n\n```pythonthon\npython -O my_script.py\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 96,
  "fields": {
    "question": "Что будет напечатано в результате выполнения следующего кода?",
    "answer": "```pythonthon\narr = [[]] * 5\narr_1, arr_2 = arr, arr\nfor k, arr in enumerate((arr_1, arr_2)):\n   arr[0].append(k)\narr = (arr_1, 5, arr_2)\nprint(arr)\n```\n\nВывод в консоли: ([0, 1], 5, [0, 1]).\n\nПервоначально arr представляет собой список из одного пустого списка, который умножается на 5, в результате чего arr представляет собой список из 5 ссылок на один и тот же внутренний пустой список. Затем arr_1 и arr_2 устанавливаются в этот же список. Функция enumerate() вызывается для кортежа, содержащего arr_1 и arr_2, который перебирает обе переменные одновременно с переменной цикла k. Для каждой итерации цикла arr присваивается текущей переменной в кортеже, это означает, что на первой итерации arr присваивается arr_1, а на второй итерации arr присваивается arr_2. Текущий внутренний список, присвоенный arr, затем модифицируется путем добавления значения переменной цикла k к его первому элементу. Наконец, arr переназначается кортежу, содержащему arr_1, целое число 5 и arr_2. Когда этот кортеж печатается, он показывает модифицированный внутренний список, на который ссылаются как arr_1, так и arr_2, целое число 5 и снова модифицированный внутренний список, на который ссылаются как arr_1, так и arr_2.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 97,
  "fields": {
    "question": "Какие переменные среды, влияющие на поведение интерпретатора python, вы знаете?",
    "answer": "Несколько известных переменных среды, влияющих на поведение интерпретатора Python:\n\nPYTHONPATH - определяет список каталогов, в которых интерпретатор Python будет искать модули.\n\nPYTHONDONTWRITEBYTECODE - если установлено в любое ненулевое значение, интерпретатор Python не будет создавать файлы .pyc для скомпилированного байт-кода.\n\nPYTHONSTARTUP - определяет путь к файлу, который содержит инициализационный код Python, он выполняется в начале каждой сессии интерпретатора.\n\nPYTHONIOENCODING - задает кодировку, которую интерпретатор Python должен использовать для обработки ввода / вывода.\n\nPYTHONLEGACYWINDOWSSTDIO - если установлено в любое ненулевое значение, указывает интерпретатору Python использовать режим Windows для ввода-вывода вместо UNIX-стиля.\n\nВ зависимости от операционной системы, может быть и другие переменные среды, которые влияют на поведение интерпретатора Python. Чтобы увидеть все переменные среды, которые влияют на вашу систему, вы можете использовать команду \"env\" в терминале, если вы используете UNIX-подобную систему, или команду \"set\" в командной строке Windows.\n\nЭти альтернативные реализации продолжают существовать, поскольку каждая из них предлагает уникальные функции и преимущества по сравнению со стандартной реализацией Python (CPython). Например, Cython может обеспечить значительное повышение производительности по сравнению со стандартным кодом Python, а IronPython позволяет коду Python легко взаимодействовать с другими приложениями .NET. PyPy также может обеспечить значительное повышение производительности по сравнению со стандартным кодом Python, особенно при работе с задачами, требующими большого количества вычислений. В целом эти альтернативные реализации Python расширяют функциональные возможности языка и предоставляют больше возможностей разработчикам, решившим использовать Python в своих проектах.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 98,
  "fields": {
    "question": "Что такое Cython? Что такое IronPython? Что такое PyPy? Почему они до сих пор существуют и зачем?",
    "answer": "Cython - это язык программирования, нацеленный на увеличение производительности Python-кода. Cython позволяет использовать возможности языка Python и C/C++ для эффективного написания расширений модулей на языке Python. Он позволяет вам писать код на Python, который доступен из C/C++, и наоборот. Cython обеспечивает скорость выполнения, сравнимую со скоростью выполнения на языке C/C++, при этом сохраняя простоту и удобство использования языка Python. Cython compiler компилирует исходный код в C/C++ и затем переводит его в машинный код, что дает быстрый доступ к низкоуровневым ресурсам операционной системы, таким как память и ввод-вывод. Cython также предоставляет возможность использовать дополнительные функции, такие как статическая типизация и параллельное программирование, для дополнительного увеличения производительности.\n\nIronPython - это реализация языка программирования Python, которая работает в контексте платформы .NET. IronPython предоставляет возможность использовать Python в качестве языка .NET. Он может использоваться для написания .NET-приложений, а также для расширения приложений, написанных на других языках .NET. IronPython является открытым и свободно распространяемым программным обеспечением.\n\nPyPy — это высокопроизводительная реализация языка программирования Python. Он был создан с целью предоставления более быстрой и эффективной альтернативы стандартному интерпретатору CPython. PyPy включает компилятор Just-In-Time (JIT), который может оптимизировать выполнение кода Python во время выполнения, что может привести к значительному повышению производительности по сравнению с CPython, особенно для определенных типов рабочих нагрузок. PyPy также поддерживает многие из тех же функций и модулей, что и CPython, включая объектно-ориентированное программирование, динамическую типизацию и стандартную библиотеку Python.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 99,
  "fields": {
    "question": "Как перевернуть генератор?",
    "answer": "Можно перевернуть генератор в Python, используя функцию reversed(). Вот пример, который демонстрирует это:\n\n```pythonthon\nmy_list = [1, 2, 3, 4, 5]\nmy_generator = (x**2 for x in my_list)\n\nfor item in reversed(list(my_generator)):\n    print(item)\n```\n\nВ этом примере мы используем функцию reversed() вместе с функцией list(), чтобы создать обратный список элементов, сгенерированных генератором. Затем мы используем этот список с циклом for для перебора элементов в обратном порядке. Если вы работаете с большими наборами данных, может быть полезно использовать обратное итерирование без использования list(), чтобы избежать создания полной копии. Вот пример, который демонстрирует это:\n\n```pythonthon\nmy_list = [1, 2, 3, 4, 5]\nmy_generator = (x**2 for x in my_list)\n\nfor item in reversed(tuple(my_generator)):\n    print(item)\n```\n\nЗдесь мы используем функцию reversed() вместе с функцией tuple() для обратного итерирования через генератор без создания полной копии.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 100,
  "fields": {
    "question": "Приведите пример использования filter и reduce над итерируемым объектом.",
    "answer": "Пример использования filter() и reduce() над итерируемым объектом в Python:\n\n```pythonthon\nfrom functools import reduce\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n# Пример использования filter() для отфильтровывания четных чисел\neven_numbers = list(filter(lambda x: x % 2 == 0, numbers))\nprint(even_numbers) # выводит [2, 4, 6, 8, 10]\n\n# Пример использования reduce() для нахождения суммы чисел от 1 до 10\nsum_of_numbers = reduce(lambda x, y: x + y, numbers)\nprint(sum_of_numbers) # выводит 55\n```\n\nВ этом примере мы использовали filter() для отбора только четных чисел в списке numbers, и reduce() для нахождения суммы всех чисел в списке от 1 до 10.\n\nfilter() принимает два аргумента - функцию-предикат и итерируемый объект. Он возвращает новый итератор, содержащий только те элементы итерируемого объекта, которые удовлетворяют условиям, заданным функцией-предикатом.\n\nreduce() также принимает два аргумента - функцию и итерируемый объект. Он выполняет функцию на каждой паре элементов из итерируемого объекта, образуя редуцированное значение, которое в конечном итоге становится результатом функции. В примере мы использовали reduce() для нахождения суммы всех чисел в итерируемом объекте.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 101,
  "fields": {
    "question": "Что будет напечатано в результате выполнения кода",
    "answer": "```pythonthon\n>>> print(_)\n```\n\n(\\_) можно использовать подчеркивание в качестве переменной в цикле. Примеры ниже:\n\n```pythonthon",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 102,
  "fields": {
    "question": "## lopping ten times using _\nfor _ in range(5):\n    print(_)",
    "answer": "",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 103,
  "fields": {
    "question": "## iterating over a list using _",
    "answer": "",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 104,
  "fields": {
    "question": "## you can use _ same as a variable\nlanguages = [\"Python\", \"JS\", \"PHP\", \"Java\"]\nfor _ in languages:\n    print(_)",
    "answer": "_ = 5\nwhile _ < 10:\n    print(_, end = ' ') # default value of 'end' id '\\n' in python. we're changing it to space\n    _ += 1\n```\n\n```pythonthon\n0\n1\n2\n3\n4\nPython\nJS\nPHP\nJava\n5 6 7 8 9\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 105,
  "fields": {
    "question": "Чем фреймворк отличается от библиотеки?",
    "answer": "Фреймворк и библиотека - это два разных подхода к организации кода, которые используются для упрощения разработки программного обеспечения.\n\nБиблиотека представляет собой коллекцию модулей или функций, предназначенных для использования другими приложениями. Она содержит набор готовых решений для различных задач и обеспечивает функциональность, которую можно использовать в своём приложении. Пользователь сам выбирает, какие модули или функции использовать, и какую логику реализовывать самостоятельно.\n\nФреймворк представляет собой интегрированный набор компонентов и инструментов, который предоставляет готовое решение для решения определенной задачи. Его основная цель - упростить разработку приложений, обеспечивая заранее заданную структуру и логику работы. В отличие от библиотеки, фреймворк накладывает определенные ограничения на структуру, логику и процесс разработки приложения, но при этом предоставляет готовый инструментарий для работы.\n\nВ целом, библиотека дает большую свободу в выборе логики и реализации приложения, но требует больше написания кода. Фреймворк же облегчает начало разработки и создает более унифицированный код, но может ограничивать возможности программиста по изменению поведения и структуры приложения.",
    "category": 6,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 106,
  "fields": {
    "question": "Расположите функции в порядке эффективности, объясните выбор.",
    "answer": "```pythonthon\ndef f1(arr):\n   l1 = sorted(arr)\n   l2 = [i for i in l1 if i < .5]\n   return [i * i for i in l2]\n\ndef f2(arr):\n   l1 = [i for i in arr if i < .5]\n   l2 = sorted(l1)\n   return [i * i for i in l2]\n\ndef f3(arr):\n   l1 = [i * i for i in arr]\n   l2 = sorted(l1)\n   return [i for i in l1 if i < (.5 * .5)]\n```\n\nНаиболее эффективной функцией из трех предоставленных, вероятно, будет f2. Это связано с тем, что он избегает сортировки всего списка, вместо этого сортируется только меньший предварительно отфильтрованный список. Вот почему:\n\n- f1 сортирует весь список с помощью функции sorted, которая имеет временную сложность O(n log n), где n — длина входного списка. После сортировки он отфильтровывает все элементы, большие или равные 0,5, и вычисляет квадраты оставшихся элементов. Фильтрация списка занимает время O(n), а окончательное вычисление занимает время O(m), где m — длина отфильтрованного списка. Следовательно, общая временная сложность этой функции равна O(n log n + n + m).\n- f2 сначала фильтрует входной список, чтобы включить только элементы меньше 0,5, что занимает O(n) времени. Затем он сортирует этот отфильтрованный список с помощью функции sorted, которая имеет временную сложность O(m log m), где m — длина отфильтрованного списка. Наконец, он вычисляет квадраты отсортированных элементов. Вычисление квадратов занимает O(m) времени. Поэтому, общая временная сложность этой функции составляет O (n + m log m + m).\n- f3 вычисляет квадраты всех элементов во входном списке, что занимает O(n) времени. Затем он сортирует список в квадрате с помощью функции sorted, которая имеет временную сложность O(n log n). Наконец, он отфильтровывает все элементы, большие или равные 0,25, что занимает время O(n). Таким образом, общая временная сложность этой функции равна O(n log n).\n\nТаким образом, f2 имеет наилучшую временную сложность, поскольку сортирует наименьший список, который является только отфильтрованным. Имейте в виду, что это может быть несущественным в небольших списках, и всегда ключевым фактором является бенчмаркинг.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 107,
  "fields": {
    "question": "Произошла утечка памяти в рабочем приложении. Как бы вы начали отладку?",
    "answer": "Для отладки утечек памяти в Python можно использовать инструменты, такие как Memory Profiler или objgraph. Вот пример использования Memory Profiler для отслеживания утечек памяти:\n\nУстановите Memory Profiler с помощью pip:\n\n```pythonthon\npip install memory-profiler\n```\n\nИспользуйте декоратор @profile перед функцией, которая может вызывать утечки памяти.\n\n```pythonthon\nfrom memory_profiler import profile\n\n@profile\ndef my_func():\n    # Some code that may cause a memory leak\n```\n\nЗапустите вашу программу с помощью команды python -m memory_profiler my_script.py. Будет выведен подробный отчет о том, сколько памяти используется в каждой строке программы, а также общее использование памяти и любые утечки.\n\nТакже можно использовать objgraph для визуализации объектов, которые находятся в оперативной памяти и могут вызывать утечки. Вот пример:\n\n```pythonthon\nimport objgraph\nmy_list = [1, 2, 3]\nobjgraph.show_refs([my_list], filename='my_list.png')\n```\n\nЭтот код создаст изображение my_list.png, на котором будут показаны все объекты, на которые ссылается my_list, а также все объекты, которые ссылается на них. Это может помочь вам понять, какие объекты держат ссылки на ваши объекты и могут вызывать утечки памяти.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 108,
  "fields": {
    "question": "В каких ситуациях возникает исключение NotImplementedError?",
    "answer": "Исключение NotImplementedError возникает, когда метод или функция должны быть реализованы в подклассе, но не были. Это может произойти, когда родительский класс определяет метод, но не реализует его сам, а оставляет это для подклассов. В этом случае, если подкласс не реализует метод, он будет вызывать исключение NotImplementedError. Это может быть полезно для отладки, чтобы убедиться, что все необходимые методы реализованы в подклассах. Это также может возникнуть в других ситуациях, например, если вы пытаетесь использовать неопределенную функцию или метод.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 109,
  "fields": {
    "question": "Что не так с этим кодом? Зачем это нужно?",
    "answer": "```pythonthon\nif __debug__:\nassert False, (\"error\")\n```\n\nЭтот код вызывает ошибку утверждения assert с сообщением \"error\", если **debug** равен True. **debug** - это встроенная переменная Python, которая является истинной, если к интерактивной консоли или скрипту был присоединен флаг оптимизации -O. Для типичных скриптов в режиме отладки эта переменная равна True. Если оптимизация включена, то интерпретатор Python игнорирует все операторы утверждения assert, поэтому этот код не вызовет ошибку в optimized mode.\n\nТакой код может быть использован для проверки инвариантов в программе или для отладки кода. Если утверждение не выполняется и вызывается AssertionError, это означает, что в программе произошло что-то непредвиденное, что нарушило заданное утверждение, и программа остановится с сообщением об ошибке.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 110,
  "fields": {
    "question": "Что такое магические методы(dunder)?",
    "answer": "Магические методы, также известные как \"dunder\" (double underscore) методы в Python, это специальные методы, которые начинаются и заканчиваются двойным подчеркиванием. Они позволяют определить, как объекты этого класса будут вести себя в различных контекстах, например, при использовании операторов Python, таких как +, -, \\*, / и т.д., при вызове функций и методов, при сериализации и многое другое.\n\nНекоторые примеры магических методов в Python включают:\n\n- **init**: инициализирует новый экземпляр объекта\n\n- **str**: определяет, как объект будет представлен в строковом формате\n\n- **add**: определяет, что происходит при использовании оператора +\n\n- **len**: определяет, как объект будет представлен при вызове функции len()\n\n- **getitem**: позволяет получать доступ к элементам объекта, как к элементам списка\n\nМагические методы могут быть очень полезными при создании пользовательских классов в Python, так как они позволяют управлять поведением объектов в различных контекстах и создавать более понятный и гибкий код.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 111,
  "fields": {
    "question": "Объясните, почему такое возможно?",
    "answer": "```pythonthon\n_MangledGlobal__mangled = \"^_^\"\n\nclass MangledGlobal:\n\n   def test(self):\n       return __mangled\n\nassert MangledGlobal().test() == \"^_^\"\n```\n\nЭто возможно из-за того, что Python имеет функцию под названием \"name mangling\", которая изменяет имена атрибутов класса или методов путем добавления двойного подчеркивания \"\\_\\_\" в начале их имен. Это сделано для того, чтобы предотвратить случайное переименование атрибутов в подклассах, которые будут унаследованы суперклассом.\n\nВ этом примере, \"**mangled\" является приватным и скрытым атрибутом, и он был переименован в \"\\_MangledGlobal**mangled\" во время исполнения. Это означает, что вы можете обращаться к атрибуту с исходным именем \"**mangled\" только внутри определения класса. Если вы попытаетесь обратиться к атрибуту с исходным именем \"**mangled\" извне класса, вы получите ошибку \"AttributeError\" потому что атрибут фактически был переименован.\n\nВ нашем коде, метод \"test\" возвращает значение приватного атрибута \"**mangled\", но мы успешно можем обратиться к этому значению снова, используя измененное имя атрибута \"\\_MangledGlobal**mangled\". Поэтому у нас нет ошибки и утверждение \"assert\" успешно проходит.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 112,
  "fields": {
    "question": "Что такое monkey patching? Приведите пример использования.",
    "answer": "Monkey patching - это техника изменения поведения кода во время выполнения путем динамической замены или добавления методов или атрибутов в существующем объекте. Эта техника может быть полезна в том случае, когда изменения не могут быть внесены в существующий код, и требует минимальных изменений в существующем коде.\n\nНапример, можно добавить новый метод в класс в runtime, который наследуется от базового класса:\n\n```pythonthon\nclass MyBaseClass:\n    def my_method(self):\n        print('Hello from MyBaseClass')\n\ndef monkey_patch():\n    def new_method(self):\n        print('Hello from new_method')\n    MyBaseClass.my_method = new_method\n\nmonkey_patch()\nobj = MyBaseClass()\nobj.my_method()  # выведет \"Hello from new_method\"\n```\n\nВ этом примере мы добавляем новый метод new_method() в класс MyBaseClass, используя функцию monkey_patch(). После этого, вызов метода obj.my_method() выведет строку\n\n```pythonthon\n Hello from new_method\n```\n\nВажно учитывать, что использование monkey patching может усложнить отладку и поддержку в будущем, поэтому следует использовать эту технику с осторожностью и только при необходимости.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 113,
  "fields": {
    "question": "Как работать с транзитивными зависимостями?",
    "answer": "Для работы с транзитивными зависимостями можно использовать систему управления зависимостями, например, pipenv, poetry или pip. Эти системы позволяют устанавливать зависимости и их транзитивные зависимости, а также контролировать версии зависимостей. Например, при использовании pipenv для установки и работы с зависимостями можно использовать следующие команды:\n\n```bash\npipenv install <имя пакета>\n```\n\nЭта команда установит пакет и его транзитивные зависимости и создаст файл Pipfile с перечнем зависимостей и версиями.\n\n```bash\npipenv shell\n```\n\nЭта команда позволит активировать виртуальное окружение, в котором установлены зависимости.\n\n```bash\npipenv install --dev <имя пакета>\n```\n\nЭта команда установит пакет в качестве зависимости разработки.\n\n```bash\npipenv uninstall <имя пакета>\n```\n\nЭта команда удалит пакет и его транзитивные зависимости.\n\nТакже можно использовать файлы requirements.txt или setup.py для установки зависимостей и их транзитивных зависимостей.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 114,
  "fields": {
    "question": "Что будет напечатано в окне браузера?",
    "answer": "```html\r\n<html>\r\n   <link rel=\"stylesheet\" href=\"https://pyscript.net/alpha/pyscript.css\" />\r\n   <script defer src=\"https://pyscript.net/alpha/pyscript.js\"></script>\r\n   <body>\r\n      <py-script>\r\n         print(__name__)\r\n         print(__file__)\r\n      </py-script>\r\n   </body>\r\n</html>\r\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 4,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 115,
  "fields": {
    "question": "Какие новые функции добавлены в python 3.10?",
    "answer": "Python 3.10 включает несколько новых функций и улучшений, в том числе:\n\n- Структурное сопоставление с шаблоном: новый синтаксис для сопоставления значений с шаблонами и выполнения различных путей кода на основе совпадения.\n- Менеджеры контекста в скобках: новый синтаксис, который позволяет использовать произвольные выражения в качестве менеджеров контекста в операторах with.\n- Улучшенные сообщения об ошибках: Python 3.10 включает множество улучшений сообщений об ошибках, которые отображаются при возникновении ошибок, обеспечивая более полезную и информативную обратную связь.\n- Новые и улучшенные функции производительности: в Python 3.10 было сделано несколько улучшений производительности, в том числе более быстрое время запуска и уменьшенное использование памяти.\n- Другие языковые функции. Python 3.10 включает ряд других языковых функций и улучшений, таких как улучшенная поддержка объединений в аннотациях типов, новые параметры форматирования строк и улучшенная поддержка информации о часовых поясах.\n\nЭто лишь некоторые из многих новых функций и улучшений в Python 3.10. Для большего информации, вы можете ознакомиться с официальной документацией Python или различными онлайн-ресурсами, которые более подробно освещают новые изменения.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 116,
  "fields": {
    "question": "Почему иногда python так долго запускается (в Windows)?",
    "answer": "Запуск Python может занимать длительное время на компьютерах с операционной системой Windows по нескольким причинам. Вот некоторые из них:\n\n- Перезагрузка компьютера может занять длительное время и затормозить работу Python.\n\n- Некоторые антивирусные программы и брандмауэры могут занимать ресурсы и замедлять выполнение команд в Python.\n\n- Операционная система Windows может использовать много ресурсов, когда запускаются приложения, и это может сказаться на производительности Python.\n\n- Зависимости и модули Python, которые используются в приложении, могут занимать много времени на импорт и загрузку.\n\n- Неэффективный код Python может приводить к значительным задержкам и замедлениям.\n\n- Другие приложения, работающие на компьютере, могут занимать много времени на выполнение задач и затруднять работу Python.\n\n- Наличие большого количества файлов и папок в директории проекта, а также наличие многочисленных процессов в фоновом режиме, могут приводить к замедлению работы с Питоном.\n\nЭто не полный список, но рассмотрение этих причин может помочь выяснить, почему Python работает медленно в операционной системе Windows. Если проблема сохраняется, можно также попробовать улучшить производительность Python, реорганизовав код или запустив его на качественном аппаратном обеспечении.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 117,
  "fields": {
    "question": "Когда использование Python является «правильным выбором» для проекта?",
    "answer": "Использование Python может быть правильным выбором для проекта в следующих случаях:\n\n- Когда нужен быстрый прототип или быстрое решение, которое будет работать достаточно быстро без оптимизации производительности.\n\n- Когда нужен простой и понятный синтаксис языка программирования, который позволит быстрее писать код и делать его более читабельным.\n\n- Когда нужен доступ к большому количеству сторонних библиотек и фреймворков в области машинного обучения, науки о данных, веб-разработки и многих других областях.\n\n- Когда необходимо использование «кляузы batteries included», определяющей высокоуровневый язык программирования с широким спектром интегрированных библиотек и модулей.\n\nОднако следует учитывать, что Python может не быть оптимальным выбором для тех приложений, где требуется высокая производительность или многоуровневая безопасность. В этих случаях может быть предпочтительнее использование языков, таких как C++, Java, или C#.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 118,
  "fields": {
    "question": "Каковы некоторые недостатки языка Python?",
    "answer": "Хотя язык Python является мощным и гибким инструментом, у него все же есть некоторые недостатки, которые могут затруднить работу в определенных ситуациях. Некоторые из них:\n\n- Низкая производительность: Python может быть медленнее, чем другие языки, такие как C++, особенно при работе с большими объемами данных.\n\n- Глобальный интерпретатор блокирует поток: из-за особенностей работы интерпретатора Python может быть трудно создать высокопроизводительные приложения с блокирующей ввод/вывод операцией.\n\n- Некоторые ограничения при работе с многопоточностью: например, использование глобальной блокировки (Global Interpreter Lock) может приводить к неоптимальному использованию нескольких ядер процессора.\n\n- Проблемы с управлением памятью: Python имеет автоматическое управление памятью, что делает его более удобным, но это также может приводить к проблемам производительности и утечкам памяти.\n\n- Излишняя гибкость: Python допускает много способов выполнения одной и той же задачи, что может приводить к трудностям с читаемостью и поддержкой кода.\n\n- Отсутствие строгой типизации может приводить к ошибкам в коде, которые могут быть трудно обнаружить.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 119,
  "fields": {
    "question": "Мы знаем, что Python сейчас в моде. Но чтобы по-настоящему принять великую технологию, вы должны знать и ее подводные камни?",
    "answer": "Xотя Python является очень популярным языком программирования, он также имеет свои недостатки и подводные камни, которые могут влиять на процесс разработки и успешное выполнение проекта. Некоторые из подводных камней Python включают в себя:\n\n- Низкая производительность при обработке больших данных и вычислений.\n\n- Проблемы с многопоточностью и синхронизацией при работе с несколькими потоками.\n\n- Некоторые несовместимости между Python 2 и Python 3, что может вызвать проблемы при переносе кода с одной версии на другую.\n\n- Некоторые проблемы безопасности, такие как возможность инъекций SQL и других уязвимостей веб-приложений.\n\nЭти проблемы не означают, что Python не является хорошим языком программирования. Он имеет множество преимуществ, включая читаемость кода, обширную библиотеку и большую поддержку сообщества. Однако наличие некоторых недостатков может повлиять на выбор языка программирования для конкретной задачи, поэтому важно понимать как преимущества, так и недостатки каждого языка программирования.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 120,
  "fields": {
    "question": "Каковы основные различия между Python 2 и 3?",
    "answer": "Один из основных различий между Python 2 и 3 заключается в том, что Python 3 является более современной и поддерживаемой версией языка. В Python 3 было сделано много изменений, направленных на улучшение языка и его исправление, что привело к некоторым несовместимостям между Python 2 и 3. Некоторые из основных различий это:\n\n- Синтаксис: Python 3 вводит некоторые изменения в синтаксис языка, такие как использование функций print() и input(), которые в Python 2 были операторами.\n\n- Unicode: В Python 3 все строки по умолчанию являются строками Unicode, в то время как в Python 2 строки представляются как байты.\n\n- Исправления ошибок: Python 3 исправляет многие ошибки, которые были найдены в Python 2.\n\n- Улучшенная библиотека: Python 3 имеет более совершенную стандартную библиотеку, например, изменения в работе с модулем urllib, и введение новых библиотек, таких как asyncio.\n\nЕсли вы переходите на Python 3 из Python 2, то возможно, вам придется адаптировать свой код, чтобы он работал в новой версии.\n\n5. Какие ключевые отличия следует учитывать при написании кода на Python и Java?\n\nСуществуют ряд ключевых отличий между Python и Java:\n\n- Python - интерпретируемый язык программирования, тогда как Java - компилируемый язык.\n\n- Python использует динамическую типизацию, в то время как Java - статическая типизация.\n\n- Python обычно позволяет писать более лаконичный код, в то время как Java обычно более строго организован и требует более формального синтаксиса.\n\n- В сравнении с Java, Python обычно предлагает более простую и быструю разработку благодаря своим сокращениям кода и быстрой обработке данных.\n\n- Python обычно используется в научных вычислениях, анализе данных и машинном обучении, тогда как Java широко используется для разработки крупномасштабных приложений, серверных систем и мобильных приложений.\n\nВ целом, выбор между Python и Java в значительной степени зависит от конкретной задачи. Если вы работаете с большими проектами, требующими высокой производительности, Java может быть предпочтительнее. Если вы работаете с научными вычислениями, анализом данных или машинным обучением, Python может быть более подходящим выбором. Кроме того, Python-программы обычно написаны быстрее благодаря своей простоте, но Java-программы, как правило, более удобны в поддержке и имеют лучшую масштабируемость.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 121,
  "fields": {
    "question": "Что такое метод?",
    "answer": "Методы в Python - это функции, определенные внутри класса, которые могут быть вызваны на экземпляре этого класса или на самом классе. Методы предоставляют способ для объектов класса взаимодействовать с данными, хранящимися внутри объекта, а также для выполнения действий, которые связаны с этими данными.\r\n\r\nНапример, если у вас есть класс Person с атрибутами name и age, атрибут name будет хранить имя объекта Person, а атрибут age будет хранить возраст. Вы можете определить методы, такие как get_name и get_age, которые могут быть вызваны на экземпляре класса для получения значения хранящихся в атрибутах name и age соответственно.\r\n\r\nВот пример определения класса Person с методами get_name и get_age:\r\n\r\n```python\r\nclass Person:\r\n    def __init__(self, name, age):\r\n        self.name = name\r\n        self.age = age\r\n\r\n    def get_name(self):\r\n        return self.name\r\n\r\n    def get_age(self):\r\n        return self.age\r\n\r\n```\r\n\r\nЗдесь метод **init** - это конструктор класса, который инициализирует атрибуты name и age, а методы get_name и get_age предоставляют доступ к их значениям.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 2,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 122,
  "fields": {
    "question": "Как вызвать метод, определенный в базовом классе, из производного класса, который переопределяет его?",
    "answer": "Для вызова метода, определенного в базовом классе, из производного класса, который переопределяет его, можно использовать функцию super(). Вот пример:\n\n```python\nclass MyBaseClass:\n    def my_method(self):\n        print(\"Hello from MyBaseClass\")\n\nclass MyDerivedClass(MyBaseClass):\n    def my_method(self):\n        super().my_method()   # вызываем родительский метод\n        print(\"Hello from MyDerivedClass\")\n\nobj = MyDerivedClass()\nobj.my_method()\n```\n\nВ этом примере, при вызове метода my_method() у объекта MyDerivedClass, сначала будет вызван метод из родительского класса MyBaseClass с помощью функции super(), а затем будет выполнен код в методе my_method() класса MyDerivedClass. Результат выполнения этого кода будет следующим:\n\n```bash\nHello from MyBaseClass\nHello from MyDerivedClass\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 123,
  "fields": {
    "question": "Как организовать код, чтобы упростить изменение базового класса?",
    "answer": "Для того, чтобы упростить изменение базового класса в Python, рекомендуется использовать наследование. Создайте новый класс, который наследует функциональность базового класса, и внесите необходимые изменения в новый класс, оставляя базовый класс без изменений. Другие классы, которые используют базовый класс, могут использовать новый класс с измененной функциональностью.\n\nНапример, предположим, что у вас есть базовый класс Animal, который имеет метод speak():\n\n```python\nclass Animal:\n    def speak(self):\n        print(\"The animal makes a sound\")\n```\n\nДля изменения функциональности speak() в новой версии класса, вы можете создать новый класс, который наследует Animal и переопределяет метод speak():\n\n```python\nclass Dog(Animal):\n    def speak(self):\n        print(\"The dog barks\")\n```\n\nТеперь вы можете использовать Dog вместо Animal, где требуется функциональность базового класса, но с изменениями:\n\n```python\na = Animal()\na.speak()  # выводит \"The animal makes a sound\"\n\nd = Dog()\nd.speak()  # выводит \"The dog barks\"\n```\n\nТаким образом, при необходимости изменения функциональности базового класса вам не нужно изменять код во всех местах, где используется базовый класс. Вам нужно изменить только новый класс, который наследует базовый класс.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 124,
  "fields": {
    "question": "Как узнать текущее имя модуля?",
    "answer": "Для получения имени текущего модуля можно использовать переменную **name**. Эта переменная имеет значение \"**main**\", если код выполняется как главный модуль, или имя модуля, если его импортировали. Например:\n\n```python\n# Пример кода в файле example.py\n\nprint(__name__)\n```\n\nЕсли выполнить этот код как главный модуль, то будет выведено \"**main**\". Если этот файл был импортирован из другого файла, то будет выведено \"example\", которое является именем данного модуля.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 125,
  "fields": {
    "question": "Как мне получить доступ к модулю, написанному на Python, из C?",
    "answer": "Для того чтобы получить доступ к модулю, написанному на Python, из C, можно воспользоваться библиотеками ctypes или cffi.\n\nctypes позволяет вызывать функции, экспортированные из динамической библиотеки в формате C, написанной на других языках, включая Python. Пример использования:\n\n```python\n# Импортируем библиотеку ctypes\nimport ctypes\n\n# Загружаем библиотеку, которая экспортирует функцию add, написанную на Python\nlib = ctypes.CDLL('./libexample.so')\n\n# Вызываем функцию add\nresult = lib.add(1, 2)\nprint(result)\n```\n\ncffi работает аналогично ctypes, но предоставляет более высокоуровневый интерфейс для работы с C-кодом. Пример использования:\n\n```python\nfrom cffi import FFI\n\nffi = FFI()\n# Описываем интерфейс функции из библиотеки, написанной на Python\nffi.cdef(\"\"\"\n    int add(int a, int b);\n\"\"\")\n\n# Загружаем библиотеку, экспортирующую функцию add, написанную на Python\nlib = ffi.dlopen('./libexample.so')\n\n# Вызываем функцию add\nresult = lib.add(1, 2)\nprint(result)\n```\n\nОба этих подхода позволяют вызывать функции из Python, написанные на других языках, в том числе на C. Если необходимо создать более сложные интерфейсы между Python и C, можно ознакомиться с документацией по данным библиотекам.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 126,
  "fields": {
    "question": "Как преобразовать число в строку?",
    "answer": "Чтобы преобразовать число в строку можно использовать функцию str(). Например:\n\n```python\nnum = 123\nstr_num = str(num)\nprint(str_num)\n```\n\nЭто напечатает строку '123', которая является строковым представлением числа 123.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 127,
  "fields": {
    "question": "Как выполняется реализация словарей Python?",
    "answer": "Словари в Python реализованы как хэш-таблицы. Хэш-таблица - это структура данных, которая позволяет быстро и эффективно искать, добавлять и удалять элементы, используя хэш-функцию для определения индекса элемента в таблице. Когда вы добавляете элемент в словарь, его ключ используется для вычисления хэш-значения, которое затем используется для определения индекса, по которому элемент будет сохранен в хэш-таблице. Когда вы ищете элемент по ключу, Python сначала вычисляет хэш-значение ключа, а затем использует его для поиска индекса элемента в таблице. Если ключ найден, то функция возвращает соответствующее ему значение.\n\nХэш-таблицы в Python быстро обрабатываются благодаря хорошо подобранному алгоритму хэширования, который минимизирует коллизии (ситуации, когда два разных ключа дают одно и то же хэш-значение). Если возникает коллизия, то элементы с одинаковым хэш-значением помещаются в связанный список. При поиске элемента происходит обход этого списка.\n\nТаким образом, словари в Python представляют собой эффективные и удобные структуры данных для хранения пар ключ-значение. Они используют хэш-таблицы для обеспечения быстрого доступа к элементам.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 128,
  "fields": {
    "question": "Что используется для создания строки Unicode в Python?",
    "answer": "Для создания строки Unicode в Python можно использовать префикс \"u\". Например:\n\n```python\nunicode_str = u\"Это строка Unicode\"\n```\n\nОднако, начиная с версии Python 3.x, все строки по умолчанию являются \"Unicode strings\", так что префикс \"u\" больше не является необходимым. Просто использование двойных кавычек для создания строки будет создавать строку Unicode:\n\n```python\nunicode_str = \"Это строка Unicode\"\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 129,
  "fields": {
    "question": "Какая встроенная функция используется в Python для перебора последовательности чисел?",
    "answer": "Для перебора последовательности чисел можно использовать функцию range(). Она возвращает объект-диапазон, который представляет собой последовательность чисел. Функция range() может принимать от 1 до 3 аргументов:\n\n- range(stop) - создает диапазон от 0 до stop (не включая stop)\n\n- range(start, stop) - создает диапазон от start до stop (не включая stop)\n\n- range(start, stop, step) - создает диапазон от start до stop (не включая stop) с шагом step\n\nПример использования функции range() для перебора чисел от 1 до 10 с шагом 2:\n\n```python\nfor i in range(1, 10, 2):\n    print(i)\n```\n\nЭтот код выведет числа 1, 3, 5, 7, 9.\n\n1<div align=\"right\">\n<b><a href=\"#\">↥ вернуться к началу</a></b><br>\n<b><a href=\"#\">если вам понравилось поставьте пожалуйста ★ </a></b>\n\n</div>",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 130,
  "fields": {
    "question": "Есть ли в Python оператор switch-case?",
    "answer": "В Python нет прямого оператора switch-case, как в других языках программирования. Однако, начиная с версии Python 3.10, появилась возможность использовать оператор match-case, который является аналогом switch-case в других языках. Он позволяет проверять значения на соответствие определенным шаблонам и выполнять соответствующее действие в зависимости от того, какой шаблон соответствует значению. Пример использования оператора match-case:\n\n```python\ndef process_value(value):\n    match value:\n        case 1:\n            print(\"Value is 1\")\n        case 2:\n            print(\"Value is 2\")\n        case _:\n            print(\"Value is not 1 or 2\")\n\nprocess_value(1)  # output: Value is 1\nprocess_value(3)  # output: Value is not 1 or 2\n```\n\nОператор match-case доступен только в версии Python 3.10 и выше, поэтому если вы используете более старую версию Python, то нужно воспользоваться другими способами для решения задачи, например, использовать условные выражения if-elif-else или словари.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 131,
  "fields": {
    "question": "Поддерживает ли Python оператор switch или case в Python? Если нет, то в чем причина того же?",
    "answer": "В Python нет выражения switch/case как в других языках программирования, таких как Java или C++. Вместо этого, в Python можно использовать конструкцию if/elif/else для проверки нескольких условий. Так же существует похожая конструкция через словари вида {ключ: значение}, в которой ключи представляют собой проверяемые значения и связанные с ними значения - обработчики.\n\nОдин из основных аргументов против использования выражения switch/case в Python - это то, что конструкция if/elif/else является более читаемой и удобной для использования, особенно когда нам нужно проверить множество условий, каждое из которых может иметь различное действие.\n\nДругими словами, отсутствие оператора switch/case в Python не является недостатком языка, а скорее его особенностью, позволяющей программистам писать более компактный и читаемый код.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 132,
  "fields": {
    "question": "Какой оператор можно использовать в Python, если оператор требуется синтаксически, но программа не требует никаких действий?",
    "answer": "Можно использовать оператор pass. Он не выполняет никаких операций, однако его наличие позволяет синтаксически завершить блок кода, где его используют. Например:\n\nif some_condition: # код, который будет выполняться, если some_condition равно True\nelse:\npass\nЗдесь pass используется в блоке else, чтобы завершить блок кода, но никаких действий не выполнять. Это может быть полезно, если вы только начинаете писать программу и еще не знаете, какой код вы хотите вставить в блок else.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 133,
  "fields": {
    "question": "Поддерживает ли Python регулярные выражения?",
    "answer": "Да, Python поддерживает использование регулярных выражений. В стандартной библиотеке Python имеется модуль re, который предоставляет множество функций для работы с регулярными выражениями. Этот модуль позволяет выполнять различные операции, такие как поиск, замена, разбиение текста на подстроки и проверку совпадений с шаблоном регулярного выражения. Для работы с регулярными выражениями в Python обычно используются строковые литералы с префиксом r (raw string), которые позволяют использовать специальные символы без экранирования. Например, регулярное выражение для поиска слов, начинающихся на \"a\" и заканчивающихся на \"b\", может быть записано следующим образом:\n\n```python\nimport re\n\ntext = \"apple and banana are fruits, but apricot is not\"\npattern = r\"\\ba\\w*b\\b\"\nmatches = re.findall(pattern, text)\nprint(matches)  # output: ['apple', 'apricot']\n```\n\nЗдесь функция re.findall() выполняет поиск всех совпадений с шаблоном регулярного выражения pattern в строке text и возвращает список найденных подстрок.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 134,
  "fields": {
    "question": "Как вы выполняете сопоставление с образцом в Python? Объяснять.",
    "answer": "Сопоставление с образцом обычно происходит с помощью оператора if. Вы можете проверить, соответствует ли объект какому-то определенному образцу, используя один из нескольких способов.\n\nЕсли вы хотите проверить, является ли объект экземпляром какого-то класса, вы можете использовать оператор isinstance(). Например:\n\n```python\nclass MyClass:\n    pass\n\nobj = MyClass()\n\nif isinstance(obj, MyClass):\n    print(\"obj is an instance of MyClass\")\n```\n\nЕсли вы хотите проверить, является ли строка равной определенному значению, вы можете использовать оператор ==. Например:\n\n```python\nmy_string = \"Hello, World!\"\n\nif my_string == \"Hello, World!\":\n    print(\"my_string is equal to 'Hello, World!'\")\n```\n\nЕсли вы хотите проверить, является ли число в определенном диапазоне, вы можете использовать операторы <= и >=. Например:\n\n```python\nmy_number = 42\n\nif my_number >= 0 and my_number <= 100:\n    print(\"my_number is between 0 and 100\")\n```\n\nЭто только несколько примеров того, как можно использовать сопоставление с образцом в Python. В общем случае, сопоставление с образцом в Python может быть достигнуто с помощью множества различных выражений и операторов, в зависимости от ваших потребностей.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 135,
  "fields": {
    "question": "Напишите регулярное выражение, которое будет принимать идентификатор электронной почты. Используйте модуль re.",
    "answer": "Для написания регулярного выражения, которое будет принимать идентификатор электронной почты, вы можете использовать следующий код в Python, используя модуль re:\n\n```python\nimport re\n\nemail_regex = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n\ndef is_valid_email(email):\n    if re.match(email_regex, email):\n        return True\n    else:\n        return False\n```\n\nВ этом коде мы создаем регулярное выражение email_regex, которое проверяет, соответствует ли переданный идентификатор электронной почты заданному формату. Затем мы используем функцию re.match() для сравнения переданного идентификатора электронной почты с регулярным выражением. Если совпадение найдено, мы возвращаем True, в противном случае False.\n\nНапример, вызов is_valid_email('example@mail.com') вернет True, а вызов is_valid_email('not_valid_email') вернет False.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 136,
  "fields": {
    "question": "Что такое сборка мусора?",
    "answer": "Сборка мусора - это автоматический процесс очистки памяти от объектов, которые не используются в программе. Этот процесс осуществляется с помощью механизма управления памятью, который отслеживает объекты, на которые нет ссылок из других объектов в программе. Когда такие объекты обнаруживаются, они помечаются как мусор и затем автоматически удаляются из памяти.\n\nВ Python используется два метода для управления памятью - \"счетчик ссылок\" и \"генерационный сборщик мусора\". Счетчик ссылок - это простейший метод, который подсчитывает количество ссылок на каждый объект в памяти, и удаляет объект, когда количество ссылок на него достигает нуля. Генерационный сборщик мусора - это более сложный метод, который организует объекты в разные поколения и периодически очищает память только для тех объектов, которые не находятся в \"молодом\" поколении.\n\nВ Python существуют модули, такие как gc, которые позволяют изменять настройки механизма сборки мусора или вызывать его вручную. Но в большинстве случаев автоматический механизм управления памятью в Python работает достаточно хорошо и программистам не нужно беспокоиться о выполнении сборки мусора в своих программах.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 137,
  "fields": {
    "question": "Как в Python управляется память?",
    "answer": "В Python управление памятью осуществляется автоматически с помощью сборки мусора. Она отслеживает объекты, которые больше не используются в программе, и освобождает занятую ими память.\n\nPython также использует кэш для оптимизации использования памяти. Например, при создании одинаковых строк Python использует один и тот же объект в памяти для этих строк.\n\nКроме того, в Python есть возможность использования модуля sys для управления памятью. Например, функция sys.getsizeof() позволяет определить размер объекта в байтах.\n\nТакже существуют сторонние библиотеки, такие как memory_profiler, которые позволяют профилировать использование памяти в Python-приложениях и оптимизировать работу с памятью.\n\nВ целом, Python имеет удобную систему управления памятью и разработчикам большинства приложений не нужно беспокоиться о ней слишком много, но в случае необходимости, в языке есть инструменты для оптимизации использования памяти.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 138,
  "fields": {
    "question": "Почему не вся память освобождается при выходе из Python?",
    "answer": "При выходе из интерпретатора Python не всегда все выделенная память освобождается. Оставшаяся занятая память может быть связана с работой программы, например, с неочищенными ссылками на объекты или с использованием сторонних расширений, которые могут использовать собственную память, которая не освобождается при выходе из интерпретатора Python.\n\nPython имеет встроенный сборщик мусора, который автоматически освобождает память, которую больше не использует программа. Однако, этот процесс может занимать время, и не все память может быть освобождена немедленно.\n\nЕсли оперативная память становится критически низкой, можно вручную вызвать сборщик мусора в Python, используя функцию gc.collect() из модуля gc, это может помочь освободить память, которую больше не использует программа.\n\nТакже возможно использование сторонних утилит для отслеживания использования памяти в Python, таких как memory_profiler или objgraph, для определения, какие объекты занимают больше всего памяти и почему память не освобождается после выхода из программы.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 139,
  "fields": {
    "question": "Всякий раз, когда вы выходите из Python, освобождается ли вся память?",
    "answer": "Когда вы выходите из интерпретатора Python, все объекты и переменные, которые были созданы в этой сессии, будут удалены из оперативной памяти. Это происходит автоматически благодаря сборщику мусора, который освобождает память, занимаемую объектами, которые больше не используются в вашей программе.\n\nОднако, если вы используете сторонние модули или библиотеки, то эти модули могут сохранять данные на диск или в базе данных, которые будут сохраняться между сессиями. Если вам нужно точно контролировать управление памятью или освободить память для объектов, которые больше не нужны во время сессии, вы можете использовать метод del для удаления ссылок на объекты.\n\nНапример:\n\n```python\na = [1, 2, 3]  # создание списка\ndel a  # удаляем ссылку на список, чтобы сборщик мусора мог удалить объект из памяти\n```\n\nЭто поможет освободить память, если вы используете большие объемы данных или работаете с объектами, которые занимают много памяти.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 140,
  "fields": {
    "question": "Можно ли присвоить несколько переменных значениям в списке?",
    "answer": "Да, можно присвоить несколько переменных значениям в списке при помощи оператора распаковки. Например, если у вас есть список из трёх элементов, вы можете присвоить каждому элементу отдельную переменную следующим образом:\n\n```python\nmy_list = [1, 2, 3]\na, b, c = my_list\nprint(a) # выведет 1\nprint(b) # выведет 2\nprint(c) # выведет 3\n```\n\nТакже возможна распаковка части списка:\n\n```python\nmy_list = [1, 2, 3, 4, 5]\na, b, *rest = my_list\nprint(a) # выведет 1\nprint(b) # выведет 2\nprint(rest) # выведет [3, 4, 5]\n```\n\nЗдесь переменной a присваивается значение первого элемента списка, b получает значение второго элемента, а оставшиеся элементы распаковываются в список с помощью оператора _. Вы можете использовать любое имя переменной после оператора _, например *rest или *my_values.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 141,
  "fields": {
    "question": "Объясните механизм передачи параметров в python?",
    "answer": "В Python параметры передаются в функции как аргументы. Аргументы могут быть обязательными или необязательными, их можно передавать по позиции или по имени.\n\nОбязательные аргументы передаются по позиции без использования знака равенства, например:\n\n```python\ndef my_function(a, b):\n  # тело функции\n  pass\n\nmy_function(1, 2)\n```\n\nНеобязательные аргументы передаются с использованием знака равенства, например:\n\n```python\ndef my_function(a, b=2):\n  # тело функции\n  pass\n\nmy_function(1) # второй аргумент b будет иметь значение по умолчанию (2)\nmy_function(1, 3) # второй аргумент b будет иметь значение 3\n```\n\nАргументы, переданные по имени, указываются в вызове функции с использованием знака равенства, например:\n\n```python\ndef my_function(a, b):\n  # тело функции\n  pass\n\nmy_function(a=1, b=2)\n```\n\nМожно также передавать переменное количество аргументов, используя звездочки *args и \\*\\*kwargs. Аргументы, переданные через *args, сохраняются в кортеж, а аргументы, переданные через \\*\\*kwargs, сохраняются в словарь:\n\n```python\ndef my_function(*args, **kwargs):\n    for arg in args:\n        print(arg)\n    for key, value in kwargs.items():\n        print(key, value)\n\nmy_function(\"one\", \"two\", \"three\", a=4, b=5, c=6)\n```\n\nЭтот вызов функции выведет:\n\n```bash\none\ntwo\nthree\na 4\nb 5\nc 6\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 142,
  "fields": {
    "question": "Что такое \\*args, \\*\\*kwargs?",
    "answer": "В Python \\*args и \\*\\*kwargs - это специальные параметры, которые используются для передачи переменного количества аргументов в функцию.\n\nПри использовании \\*args функция принимает произвольное количество неименованных аргументов и сохраняет их в кортеж. Например:\n\n```python\ndef my_function(*args):\n    for arg in args:\n        print(arg)\n\nmy_function('hello', 'world', 123) # выводит 'hello', 'world', 123\n```\n\nПри использовании \\*\\*kwargs функция принимает произвольное количество именованных аргументов и сохраняет их в словарь. Например:\n\n```python\ndef my_function(**kwargs):\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\nmy_function(name='John', age=30, city='Paris') # выводит 'name: John', 'age: 30', 'city: Paris'\n```\n\nМожно также использовать \\*args и \\*\\*kwargs вместе для того, чтобы функция могла принимать и неименованные, и именованные аргументы. При этом неименованные аргументы сохраняются в кортеж, а именованные - в словарь. Например:\n\n```python\ndef my_function(*args, **kwargs):\n    for arg in args:\n        print(arg)\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\nmy_function('hello', 'world', name='John', age=30, city='Paris') # выводит 'hello', 'world', 'name: John', 'age: 30', 'city: Paris'\n```\n\nНазвание \\*args и \\*\\*kwargs не имеет отношения к Python или программированию в целом - они просто являются соглашением, которое обычно используется в Python для обозначения этого типа аргументов.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 143,
  "fields": {
    "question": "Как передать необязательные или ключевые параметры из одной функции в другую?",
    "answer": "В Python для передачи необязательных параметров в функцию используется синтаксис со знаком звездочки (\\*) и двойной звездочки (\\*\\*). Вот пример:\n\n```python\ndef my_function(required_arg, *args, **kwargs):\n    print(required_arg)\n    if args:\n        print(args)\n    if kwargs:\n        print(kwargs)\n\nmy_function('Hello, world!', 2, 3, 4, my_keyword='some_value')\n```\n\nВ этом примере required_arg - обязательный аргумент функции my_function. После этого первого аргумента мы указали символ звездочки (\\*), чтобы пометить все следующие аргументы как необязательные. В примере, это args, который преобразуется в кортеж. Далее, мы указали символ двойной звездочки (\\*\\*), чтобы пометить все следующие аргументы как необязательные с ключами. Это параметр kwargs, который преобразуется в словарь.\n\nВ вызове my_function, мы передаем обязательный аргумент 'Hello, world!', аргументы args - 2, 3, 4, и ключевой параметр my_keyword со значением 'some_value' в kwargs.\n\nТаким образом, эта функция может принимать переменное количество аргументов, как позиционных, так и именованных.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 144,
  "fields": {
    "question": "Что такое лямбда? Что такое лямбда-функции?",
    "answer": "Лямбда-функция, также известная как анонимная функция, в программировании — это функция, которая не имеет имени. Лямбда-функции часто используются в функциональном программировании, где они могут быть переданы в качестве аргументов другим функциям или использованы для создания более коротких и читаемых выражений.\n\nВ языке Python лямбда-функция представляет собой короткую функцию, которая определяется с помощью ключевого слова lambda. Она может принимать любое количество аргументов и состоит из выражения, которое возвращает значение. Вот пример определения лямбда-функции, которая возвращает сумму двух аргументов:\n\n```python\nsum = lambda x, y: x + y\nresult = sum(3, 4)\nprint(result)  # Output: 7\n```\n\nЭтот код эквивалентен такому коду с использованием обычной функции:\n\n```python\ndef sum(x, y):\n    return x + y\n\nresult = sum(3, 4)\nprint(result)  # Output: 7\n```\n\nТакже в различных языках программирования лямбда-функции могут использоваться для создания функций высшего порядка, обработки списков и многих других задач.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 145,
  "fields": {
    "question": "Как вы создаете свой собственный пакет в Python?",
    "answer": "Для создания своего собственного пакета в Python нужно выполнить следующие шаги:\n\n- Создать директорию с именем вашего пакета.\n\n- Внутри директории создать файл **init**.py, который будет пустым, но он необходим, чтобы Python распознал эту директорию как пакет.\n\n- Создать необходимые модули и скрипты внутри директории вашего пакета.\n\n- Определить файл setup.py с метаданными вашего пакета и его зависимостями, например:\n\n```python\nfrom setuptools import setup, find_packages\n\nsetup(\n    name='mypackage',\n    version='1.0',\n    packages=find_packages(),\n    install_requires=[\n        'numpy',\n        'scipy',\n    ],\n)\n\n```\n\n- Создать дистрибутив вашего пакета, выполнив команду python setup.py sdist.\n\n- Установить свой пакет с помощью pip, выполнив команду pip install dist/mypackage-1.0.tar.gz.\n\nПосле этого вы можете использовать свой пакет в своих проектах или опубликовать его на Python Package Index (PyPI) для использования другими людьми.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 146,
  "fields": {
    "question": "Объясните использование оператора with в python?",
    "answer": "Оператор with в Python используется для создания контекстного менеджера. Контекстный менеджер представляет собой блок кода, который управляет началом и концом выполнения действий с ресурсами, такими как файлы, сокеты или базы данных. Он гарантирует, что ресурсы будут правильно открыты и закрыты, даже в случае возникновения ошибок.\n\nВот пример использования оператора with для открытия файла и чтения из него:\n\n```python\nwith open('file.txt', 'r') as f:\n    data = f.read()\n    # do something with the data\n```\n\nВ этом примере файл file.txt открывается для чтения ('r') с помощью функции open(). Затем блок кода начинается после двоеточия, и внутри него мы можем читать данные из файла и выполнять любые действия, которые необходимы. Когда блок кода завершается, файл автоматически закрывается, благодаря тому, что мы использовали оператор with.\n\nЕщё один пример использования оператора with - установка соединения с базой данных. Например, вот как можно использовать with для работы с базой данных SQLite:\n\n```python\nimport sqlite3\n\nwith sqlite3.connect('mydatabase.db') as conn:\n    cursor = conn.cursor()\n    cursor.execute('SELECT * FROM mytable')\n    data = cursor.fetchall()\n    # do something with the data\n```\n\nЗдесь мы используем оператор with, чтобы установить соединение с базой данных mydatabase.db и получить курсор для выполнения запросов. Затем мы выполняем запрос SELECT из таблицы mytable и получаем все строки данных с помощью метода fetchall(). Когда блок кода завершается, соединение закрывается автоматически.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 147,
  "fields": {
    "question": "Что такое исправление Monkey? Приведи пример?",
    "answer": "Исправление Monkey (Monkey Patching) - это техника, которая позволяет изменять поведение объектов или функций на лету, без прямого внесения изменений в исходный код. Это может быть полезным, например, если вы используете стороннюю библиотеку или модуль, который не дает желаемого поведения, и вы не можете или не хотите изменять его исходный код. Вот пример использования исправления Monkey для изменения метода в стандартном модуле datetime:\n\n```python\nimport datetime\n\ndef new_method(self):\n    return \"This is a new method!\"\n\n# monkey patching the datetime module\ndatetime.datetime.new_method = new_method\n\n# using the new method\nd = datetime.datetime.now()\nresult = d.new_method()\nprint(result)\n```\n\nВ этом примере мы определяем новый метод new_method, который возвращает строку \"This is a new method!\" Затем мы используем исправление Monkey, чтобы добавить этот метод к объектам datetime. В конце мы создаем объект datetime и вызываем метод new_method(), который мы добавили, и выводим результат, который должен быть \"This is a new method!\".",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 148,
  "fields": {
    "question": "Объясните сериализацию и десериализацию/маринование и распаковку?",
    "answer": "Сериализация и десериализация - это процессы преобразования Python-объектов в поток байтов (байтовую строку) и обратно. Эти процессы иногда называют маршалингом и размаршалингом.\n\nМодуль pickle в Python используется для сериализации и десериализации объектов. Пример использования:\n\n```python\nimport pickle\n\n# объект, который мы будем сериализовать\ndata = {'name': 'John', 'age': 30}\n\n# сериализация в строку байтов\nbytes_data = pickle.dumps(data)\n\n# десериализация из строки байтов\nrestored_data = pickle.loads(bytes_data)\n\n# проверка\nprint(data == restored_data) # True\n```\n\nПри сериализации объектов с помощью pickle необходимо учитывать, что она может иметь проблемы безопасности. Например, не рекомендуется десериализовать данные из ненадежного источника.\n\nДругой модуль, json, может использоваться для сериализации и десериализации объектов Python в формат JSON. JSON является более простым, безопасным и масштабируемым языком обмена данными, который широко используется во всем мире.\n\n```python\nimport json\n\n# объект, который мы будем сериализовать\ndata = {'name': 'John', 'age': 30}\n\n# сериализация в JSON формат\njson_data = json.dumps(data)\n\n# десериализация из JSON формата\nrestored_data = json.loads(json_data)\n\n# проверка\nprint(data == restored_data) # True\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 149,
  "fields": {
    "question": "Что такое функции высшего порядка?",
    "answer": "Функции высшего порядка - это функции, которые могут принимать другие функции в качестве аргументов или возвращать функции в качестве результата. Это является важным концептом в функциональном программировании и может упростить написание кода, делая его более элегантным и модульным.\n\nВ Python встроены несколько функций высшего порядка, таких как map(), filter() и reduce().\n\nФункция map() применяет заданную функцию к каждому элементу итерируемого объекта и возвращает итератор с результатами.\n\nФункция filter() применяет заданную функцию к каждому элементу итерируемого объекта и возвращает итератор с элементами, для которых функция вернула True.\n\nФункция reduce() объединяет элементы итерируемого объекта в одно значение, используя заданную функцию.\n\nПример использования map():\n\n```python\ndef square(x):\n    return x ** 2\n\nnumbers = [1, 2, 3, 4, 5]\nsquared_numbers = map(square, numbers)\nprint(list(squared_numbers))  # [1, 4, 9, 16, 25]\n```\n\nПример использования filter():\n\n```python\ndef is_even(x):\n    return x % 2 == 0\n\nnumbers = [1, 2, 3, 4, 5]\neven_numbers = filter(is_even, numbers)\nprint(list(even_numbers))  # [2, 4]\n```\n\nПример использования reduce():\n\n```python\nfrom functools import reduce\n\ndef add(x, y):\n    return x + y\n\nnumbers = [1, 2, 3, 4, 5]\nsum_of_numbers = reduce(add, numbers)\nprint(sum_of_numbers)  # 15\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 150,
  "fields": {
    "question": "Как скопировать файл? Как скопировать объект в Python? Разница между поверхностной копией и глубокой копией?",
    "answer": "В Python вы можете использовать модуль shutil для копирования файлов или директорий, а также метод copy() для копирования объектов.\n\nВот пример копирования файла с помощью shutil:\n\n```python\nimport shutil\n\n# path to the source file\nsrc_file = '/path/to/source/file.txt'\n\n# path to the destination directory\ndst_dir = '/path/to/destination/directory/'\n\n# copy the file to the destination directory\nshutil.copy(src_file, dst_dir)\n```\n\nА вот пример копирования объекта с помощью copy():\n\n```python\nclass MyClass:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n\n# create an instance of MyClass\nobj1 = MyClass(1, 2)\n\n# make a copy of the object\nobj2 = obj1.copy()\n\n# modify the values of the copy\nobj2.a = 3\nobj2.b = 4\n\n# print the values of the original object and its copy\nprint(obj1.a, obj1.b)  # Output: 1 2\nprint(obj2.a, obj2.b)  # Output: 3 4\n```\n\nОбратите внимание, что если объект содержит ссылки на другие объекты (например, списки или словари), они также останутся ссылками, и в скопированном объекте они будут указывать на те же самые объекты, что и в оригинальном объекте. Для полного копирования объекта, включая все вложенные объекты, можно использовать функцию deepcopy() из модуля copy.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 151,
  "fields": {
    "question": "Объясните наследование в Python на примере?",
    "answer": "Концепция наследования предоставляет способ создания нового класса на основе существующего класса. В Python класс может наследовать атрибуты и методы другого класса, который называется родительским классом или суперклассом. Новый класс, который наследует родительский класс, называется дочерним классом или подклассом.\n\nПример наследования в Python:\n\n```python\nclass Animal:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def speak(self):\n        print(\"The animal speaks\")\n\nclass Cat(Animal):\n    def __init__(self, name, age):\n        super().__init__(name, age)\n\n    def speak(self):\n        print(\"Meow\")\n\nclass Dog(Animal):\n    def __init__(self, name, age):\n        super().__init__(name, age)\n\n    def speak(self):\n        print(\"Woof\")\n\ncat = Cat(\"Fluffy\", 3)\ndog = Dog(\"Buddy\", 5)\n\ncat.speak()   # Output: \"Meow\"\ndog.speak()   # Output: \"Woof\"\n```\n\nЗдесь класс Animal - это родительский класс, а классы Cat и Dog - это дочерние классы. Оба дочерних класса наследуют атрибуты и методы класса Animal, но они также переопределяют метод speak(), что позволяет изменить поведение метода в соответствии с требованиями подкласса.\n\nВ этом примере наследование облегчает повторное использование кода и позволяет создавать иерархии классов, которые отражают реальный мир.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 152,
  "fields": {
    "question": "Что такое иерархическое наследование?",
    "answer": "Иерархическое наследование - это концепция в объектно-ориентированном программировании, где один класс наследует свойства и методы от одного родительского класса, но также может иметь свои собственные уникальные свойства и методы.\n\nВ иерархическом наследовании несколько классов производных от одного базового класса, то есть структура иерархии имеет форму дерева. Каждый класс на уровне, находится в отношении наследования с классом на более низком уровне и создает связь «является» между базовым классом и производным классом. Это означает, что класс-наследник наследует все свойства и методы базового класса, а также может определять свои собственные свойства и методы.\n\nПримером может служить следующий код на Python:\n\n```python\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n\n    def eat(self, food):\n        print(self.name + \" is eating \" + food)\n\n\nclass Dog(Animal):\n    def bark(self):\n        print(\"Woof!\")\n\n\nclass Cat(Animal):\n    def purr(self):\n        print(\"Purr...\")\n\n# иерархия наследования с Animal в качестве базового класса\nmy_dog = Dog(\"Rex\")\nmy_dog.eat(\"dog food\")\nmy_dog.bark()\n\nmy_cat = Cat(\"Fluffy\")\nmy_cat.eat(\"cat food\")\nmy_cat.purr()\n```\n\nВ этом примере классы Dog и Cat наследуют свойства и методы класса Animal и имеют собственные методы bark и purr соответственно.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 153,
  "fields": {
    "question": "Какие методы/функции мы используем для определения типа экземпляра и наследования?",
    "answer": "Для определения типа экземпляра можно использовать функцию type(), например:\n\n```python\nmy_variable = \"hello\"\nprint(type(my_variable))   # Output: <class 'str'>\n```\n\nДля определения наследования можно использовать метод issubclass(), который позволяет проверить, является ли один класс наследником другого. Например:\n\n```python\nclass Animal:\n    pass\n\nclass Dog(Animal):\n    pass\n```\n\nprint(issubclass(Dog, Animal)) # Output: True\nТакже в Python есть встроенные методы, которые можно использовать для проверки типов. Например, для проверки, является ли объект экземпляром какого-то класса, можно использовать isinstance(). Для проверки, относится ли объект к определенному типу данных, можно использовать метод type() или issubclass(). Например:\n\n```python\nmy_dog = Dog()\nprint(isinstance(my_dog, Dog))   # Output: True\nprint(type(my_dog) == Dog)   # Output: True\nprint(issubclass(type(my_dog), Animal))   # Output: True\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 154,
  "fields": {
    "question": "Написать алгоритм сортировки числового набора данных на Python?",
    "answer": "",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 155,
  "fields": {
    "question": "Как вы удалите последний объект из списка?",
    "answer": "",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 156,
  "fields": {
    "question": "Что такое отрицательные индексы и для чего они используются?",
    "answer": "В Python отрицательные индексы представляют индексы, считаемые с конца списка или строки. Использование отрицательных индексов позволяет более удобно работать с последними элементами списка или символами строки, без необходимости использовать метод len().\n\nНапример, если у вас есть список my_list с элементами [0, 1, 2, 3, 4], то my_list[-1] вернет последний элемент в списке, то есть 4, my_list[-2] вернет 3, и так далее.\n\nАналогично, если у вас есть строка my_string со значением \"Hello, world!\", то my_string[-1] вернет последний символ в строке, то есть \"!\", my_string[-2] вернет \"d\", и так далее.\n\nПримеры:\n\n```python\nmy_list = [0, 1, 2, 3, 4]\nprint(my_list[-1]) # 4\nprint(my_list[-2]) # 3\n\nmy_string = \"Hello, world!\"\nprint(my_string[-1]) # \"!\"\nprint(my_string[-2]) # \"d\"\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 157,
  "fields": {
    "question": "Объясните методы split(), sub(), subn() модуля re в Python.",
    "answer": "Метод split() модуля re используется для разделения строки на список подстрок по заданному шаблону регулярного выражения. Например:\n\n```python\nimport re\ntext = \"Hello, world!\"\nresult = re.split(r\"\\W+\", text)\nprint(result)\n```\n\nЭтот код разобьет строку \"Hello, world!\" на подстроки, используя любой небуквенный символ в качестве разделителя, и выведет на экран список ['Hello', 'world', ''], где последний элемент пустой, т.к. строка заканчивается разделителем.\n\nМетод sub() модуля re используется для замены всех вхождений заданного шаблона регулярного выражения в строке на указанную подстроку. Например:\n\n```python\nimport re\ntext = \"Hello, world!\"\nresult = re.sub(r\"\\s\", \"-\", text)\nprint(result)\n```\n\nЭтот код заменит все пробельные символы в строке \"Hello, world!\" на дефис и выведет на экран строку \"Hello,-world!\".\n\nМетод subn() модуля re является аналогом метода sub(), но возвращает кортеж, состоящий из измененной строки и количества произведенных замен. Например:\n\n```python\nimport re\ntext = \"Hello, world!\"\nresult = re.subn(r\"\\s\", \"-\", text)\nprint(result)\n```\n\nЭтот код заменит все пробельные символы в строке \"Hello, world!\" на дефис и выведет на экран кортеж (\"Hello,-world!\", 1), где число 1 означает, что была произведена одна замена.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 158,
  "fields": {
    "question": "Что такое функция map в Python?",
    "answer": "Функция map() - это встроенная функция, которая принимает функцию и последовательность в качестве аргументов и возвращает новую последовательность, в которой каждый элемент получен путем применения этой функции к соответствующему элементу исходной последовательности.\n\nФункция map() имеет следующий синтаксис:\n\n```python\nmap(function, iterable, ...)\n```\n\nЗдесь function - это функция, которая будет применена к каждому элементу последовательности iterable.\n\niterable - это одна или несколько последовательностей (например, списков, кортежей и т.д.), которые будут использованы для вычисления новой последовательности.\n\nВот некоторые примеры использования функции map():\n\n```python\n# Применение функции к каждому элементу списка\nnumbers = [1, 2, 3, 4, 5]\nsquared = list(map(lambda x: x**2, numbers))\nprint(squared) # Output: [1, 4, 9, 16, 25]\n\n# Объединение двух списков с помощью функции zip()\nfirst_names = ['John', 'Emma', 'Jessica']\nlast_names = ['Doe', 'Smith', 'Thompson']\nfull_names = list(map(lambda x, y: x + ' ' + y, first_names, last_names))\nprint(full_names) # Output: ['John Doe', 'Emma Smith', 'Jessica Thompson']\n```\n\nЗдесь мы используем функцию map() для применения лямбда-функции к каждому элементу списка numbers и для объединения двух списков first_names и last_names с помощью функции zip().",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 159,
  "fields": {
    "question": "Как получить индексы N максимальных значений в массиве NumPy?",
    "answer": "Чтобы получить индексы N максимальных/минимальных значений в массиве NumPy, можно использовать метод argsort(), который возвращает индексы элементов массива, отсортированных по возрастанию или убыванию. Затем можно выбрать первые N отсортированных индексов, чтобы получить индексы N максимальных/минимальных значений.\n\nВот пример кода, показывающего, как получить индексы 3 максимальных значений в массиве arr:\n\n```python\nimport numpy as np\n\narr = np.array([3, 1, 4, 1, 5, 9, 2, 6, 5])\n\n# получение индексов отсортированных элементов\nsorted_idx = np.argsort(arr)\n\n# выбор последних 3 индексов отсортированных элементов\ntop_n_idx = sorted_idx[-3:]\n\nprint(top_n_idx) # вывод индексов 3 максимальных значений\n```\n\nЭтот код выведет [5 4 2], что соответствует индексам элементов 9, 5 и 4, являющихся тремя наибольшими значениями в массиве arr.\n\nЕсли вам нужны индексы для минимальных значений, замените sorted_idx[-3:] на sorted_idx[:3].\n\nТакже можно использовать метод argmax() для получения индекса максимального значения в массиве. Например:\n\n```python\narr = np.array([3, 1, 4, 1, 5, 9, 2, 6, 5])\nmax_idx = np.argmax(arr)\nprint(max_idx) # выводит 5\n```\n\nЗдесь метод argmax() возвращает индекс элемента с максимальным значением в массиве, который является элементом с индексом 5 в массиве arr.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 160,
  "fields": {
    "question": "Что такое модуль Python?",
    "answer": "Модуль в Python - это файл, который содержит Python код с определенным функционалом и может быть использован другими программами. Модули в Python могут содержать переменные, функции, классы и другие объекты, которые могут быть импортированы в другие программы, чтобы использовать их функциональность.\n\nPython поставляется со множеством модулей, которые можно использовать для расширения функциональности языка, таких как datetime, math, random, и т.д. Также вы можете создавать свои собственные модули для повторного использования кода в ваших приложениях.\n\nДля использования модуля в Python, нужно выполнить операцию импорта, например:\n\n```python\nimport datetime\n\nnow = datetime.datetime.now()\nprint(now)\n```\n\nЭтот код импортирует модуль datetime и использует его, чтобы получить текущую дату и время.\n\nМодули могут также иметь алиасы, которые позволяют обращаться к ним по другому имени, например:\n\n```python\nimport math as m\n\nprint(m.sqrt(4))\n```\n\nВ этом примере мы импортируем модуль math с псевдонимом m и используем его функцию sqrt для вычисления квадратного корня из 4.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 161,
  "fields": {
    "question": "Назовите модули, связанные с файлами, в Python?",
    "answer": "Некоторые модули, связанные с файлами в Python:\n\n- os — предоставляет функции для работы с операционной системой, включая операции с файлами, такие как создание, удаление и перемещение файлов.\n\n- sys — предоставляет функции для работы с системными аргументами командной строки, включая передачу параметров через консоль.\n\n- pathlib — предоставляет классы для удобной работы с путями к файлам и директориям.\n\n- io — предоставляет классы для работы с текстовыми и бинарными потоками ввода-вывода.\n\n- shutil — предоставляет функции для работы с файловой системой, включая операции с файлами, такие как копирование, перемещение и удаление файлов.\n\n- glob - позволяет осуществлять поиск файлов по шаблону",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 162,
  "fields": {
    "question": "Сколько типов последовательностей поддерживает Python? Какие они?",
    "answer": "Python поддерживает три типа последовательностей:\n\n- Строки (strings): это неизменяемые последовательности символов. Строки создаются с помощью кавычек (одинарных, двойных или тройных). Пример: \"Hello, world!\".\n\n- Списки (lists): это изменяемые последовательности элементов. Списки создаются с помощью квадратных скобок и могут содержать элементы любых типов. Пример: [1, 2, 3, \"four\"].\n\n- Кортежи (tuples): это неизменяемые последовательности элементов. Кортежи создаются с помощью круглых скобок и могут содержать элементы любых типов. Пример: (1, 2, \"three\").\n\nТакже стоит отметить, что у eсть два типа числовых последовательностей: диапазоны (ranges) и байтовые последовательности (byte arrays), но они не относятся к типу последовательностей, которые были упомянуты выше.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 163,
  "fields": {
    "question": "Как отобразить содержимое текстового файла в обратном порядке? Как перевернуть список?",
    "answer": "Для того, чтобы отобразить содержимое текстового файла в обратном порядке можно воспользоваться следующим кодом :\n\n```python\nwith open('file.txt', 'r') as f:\n    lines = f.readlines()\n    reversed_lines = reversed(lines)\n    for line in reversed_lines:\n        print(line.strip()[::-1])\n\n```\n\nЗдесь мы открываем файл 'file.txt' на чтение и считываем все его строки в список lines. Затем мы создаем новый список reversed_lines, в котором порядок элементов изменен на обратный. Наконец, мы проходимся по всем элементам списка reversed_lines и выводим их на экран в обратном порядке.\n\nДля того, чтобы перевернуть список, можно воспользоваться методом reverse() вот так:\n\n```python\nmy_list = [1, 2, 3, 4, 5]\nmy_list.reverse()\nprint(my_list)\n```\n\nЭтот код выведет список [5, 4, 3, 2, 1].\n\n4<div align=\"right\">\n<b><a href=\"#\">↥ вернуться к началу</a></b><br>\n<b><a href=\"#\">если вам понравилось поставьте пожалуйста ★ </a></b>\n\n</div>",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 164,
  "fields": {
    "question": "В чем разница между NumPy и SciPy?",
    "answer": "NumPy и SciPy - это две отдельные библиотеки для Python, которые используются для научных вычислений и работы с массивами данных.\n\nNumPy - это библиотека для работы с многомерными массивами данных, включая матрицы, и предоставляет широкий набор функций для быстрой операции с массивами и векторами. Она часто используется в математических вычислениях, научной обработке данных, машинном обучении и других областях науки и техники.\n\nSciPy - это библиотека для научных вычислений и анализа данных, основанная на NumPy. Она включает множество модулей для работы с различными задачами, такими как оптимизация, интеграция, обработка изображений, статистика, алгебра и другие научные и инженерные задачи.\n\nТаким образом, хотя NumPy используется для основных операций на многомерных массивах и матрицах, SciPy используется для решения более сложных задач научных вычислений, таких как оптимизация, интеграция и обработка изображений.\n\nНекоторые задачи, где может использоваться NumPy:\n\n- Матричные операции и операции линейной алгебры\n- Обработка изображения и видео\n- Обработка звука и аудио-файлов\n- Модули для статистики и машинного обучения, такие как scikit-learn\n\nНекоторые задачи, где может использоваться SciPy:\n\n- Решение систем нелинейных уравнений и оптимизация\n- Численное интегрирование и дифференцирование\n- Оптимизация функций\n- Работа с линейными алгебраическими системами\n- Анализ спектральных данных\n- Моделирование физических систем и оптимизация их параметров\n- Работа с сигналами и изображениями",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 165,
  "fields": {
    "question": "Предположим, что list1 равен [2, 33, 222, 14, 25]. Что такое list1[-1]?",
    "answer": "list1[-1] относится к последнему элементу списка, который в данном случае равен 25. Таким образом, -1 относится к последнему элементу, -2 относится к предпоследнему элементу и так далее.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 166,
  "fields": {
    "question": "Как открыть файл c:\\scores.txt для записи?",
    "answer": "Для того, чтобы открыть файл c:\\scores.txt для записи в Python, можно использовать встроенную функцию open() со вторым аргументом \"w\" (\"write\", \"запись\"):\n\n```python\nwith open(\"c:\\\\scores.txt\", \"w\") as f:\n    f.write(\"Это текст, который будет записан в файл\")\n```\n\nВ данном примере, файл будет открыт для записи, и все содержимое, которое было ранее в файле, будет удалено. Обратите внимание на использование \\\\ вместо одинарного обратного слеша, поскольку обратный слеш является экранирующим символом в строках Python. Кроме того, мы использовали менеджер контекста with, чтобы быть уверенными, что файл будет корректно закрыт после записи.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 167,
  "fields": {
    "question": "Назовите несколько модулей Python для статистических, числовых и научных вычислений?",
    "answer": "Ниже приведены несколько модулей Python для статистических, числовых и научных вычислений, которые могут быть полезны при выполнении таких задач:\n\n- NumPy - предоставляет поддержку для многомерных массивов и матриц, а также множество функций для работы с числами.\n\n- SciPy - это модуль, который содержит множество функций для выполнения различных задач научных вычислений, таких как оптимизация, решение уравнений, обработка сигналов и многое другое.\n\n- Pandas - предоставляет удобную работу с данными в формате таблиц и временными рядами. Содержит множество функций для фильтрации, сортировки, агрегирования данных и других операций.\n\n- Matplotlib - это библиотека для создания различных видов графиков и диаграмм.\n\n- Seaborn - библиотека для визуализации статистических данных, красивый визульные эффекты.\n\n- Statsmodels - содержит множество функций для статистических вычислений, таких как линейная регрессия, временные ряды, классификация и другие.\n\n- Scikit-learn - это библиотека для машинного обучения, содержащая множество алгоритмов машинного обучения для задач классификации, регрессии, кластеризации и других задач.\n\n- TensorFlow и PyTorch - это библиотеки для глубокого обучения и искусственного интеллекта.\n\n- SymPy - библиотека символьных математических вычислений для символьного математического",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 168,
  "fields": {
    "question": "Что такое TkInter?",
    "answer": "Tkinter — это стандартная библиотека Python для создания настольных приложений с графическим интерфейсом пользователя. Он предоставляет простой и удобный в использовании интерфейс для создания окон, диалоговых окон, кнопок, меню и других элементов графического интерфейса на кросс-платформенной основе.\n\nTkinter основан на наборе инструментов Tk GUI, который реализован на Tcl (язык команд инструментов) и предоставляет набор графических виджетов и обработчиков событий, которые можно использовать для создания интерактивных приложений.\n\nС помощью Tkinter вы можете создавать самые разные настольные приложения для Windows, Mac OS и Linux, такие как игры, калькуляторы, инструменты визуализации данных, редакторы изображений и многое другое. Приложения Tkinter управляются событиями, что означает, что приложение ожидает ввода данных пользователем и реагирует на такие события, как нажатия кнопок, выбор меню и ввод текста. Tkinter также обеспечивает поддержку различных концепций программирования с графическим интерфейсом, таких как управление компоновкой, обработка событий и объектно-ориентированное программирование.\n\nЧтобы начать работу с Tkinter, вы можете импортировать модуль Tkinter и создайте объект окна верхнего уровня, используя метод Tk(). Этот объект окна служит главным окном приложения, и вы можете добавлять к нему другие виджеты, такие как кнопки, метки и текстовые поля. Вот базовый пример программы Tkinter, которая создает окно с виджетом метки:\n\n```python\nimport tkinter as tk\n\nroot = tk.Tk()\nlabel = tk.Label(root, text=\"Hello, Tkinter!\")\nlabel.pack()\n\nroot.mainloop()\n```\n\nЭта программа создает окно верхнего уровня и виджет Label, содержащий текст «Hello, Tkinter!». Метод label.pack() упорядочивает геометрию виджета и делает его видимым в окне. Наконец, root.mainloop() входит в цикл событий tkinter, который ожидает ввода данных пользователем и обрабатывает события до тех пор, пока пользователь не закроет окно.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 169,
  "fields": {
    "question": "Является ли Python объектно-ориентированным? Что такое объектно-ориентированное программирование?",
    "answer": "Да, Python является объектно-ориентированным языком программирования.\n\nОбъектно-ориентированное программирование (ООП) - это методология программирования, которая базируется на концепции \"объектов\". Объекты - это экземпляры классов, которые имеют свои собственные атрибуты и методы, и могут взаимодействовать друг с другом для выполнения задач.\n\nВ Python, вы можете определять свои собственные классы, и создавать объекты на основе этих классов. Вы также можете использовать встроенные классы, такие как list, dict и str. Python обеспечивает поддержку основных принципов ООП, таких как наследование, инкапсуляция и полиморфизм.\n\nКонцепция ООП может помочь написать чистый и организованный код, который легче поддерживать и расширять в будущем. Однако, она не является единственным способом программирования, и в Python можно использовать и другие подходы.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 170,
  "fields": {
    "question": "Поддерживает ли Python интерфейсы, как в Java?",
    "answer": "Python не имеет концепции интерфейсов как в Java, которые определяют общие методы, которые классы должны реализовывать. Вместо этого в Python используется понятие абстрактных базовых классов (abstract base classes или ABC).\n\nABCs предоставляют набор методов-заглушек (абстрактных методов), которые описывают общий интерфейс, который должен реализовываться дочерними классами. Пример использования ABC в Python:\n\n```python\nimport abc\n\nclass MyABC(metaclass=abc.ABCMeta):\n\n    @classmethod\n    def __subclasshook__(cls, other):\n        return (hasattr(other, 'foo') and\n                callable(other.foo) and\n                hasattr(other, 'bar') and\n                callable(other.bar))\n\n    @abc.abstractmethod\n    def foo(self):\n        pass\n\n    @abc.abstractmethod\n    def bar(self):\n        pass\n\nclass MyClass:\n    def foo(self):\n        pass\n\na = MyClass()  # no 'bar', but still considered a 'MyABC' instance\n\nprint(isinstance(a, MyABC))  # Output: True\n```\n\nВ этом примере MyABC содержит два абстрактных метода foo и bar, а также метод **subclasshook**, который определяет, что объекты с методами foo и bar будут считаться дочерними классами MyABC. Класс MyClass реализует метод foo и может использоваться в качестве экземпляра класса MyABC.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 171,
  "fields": {
    "question": "Что такое аксессоры, мутаторы, @property?",
    "answer": "@property - это декоратор, который позволяет создать метод класса, который может быть использован как атрибут объекта. @property можно использовать для создания доступа чтения (геттера) и записи (сеттера) для членов класса. Метод, помеченный как @property, может быть доступен как поле класса, без вызова его как функции. Это упрощает код и облегчает чтение и понимание объектного кода.\n\nАксессоры и мутаторы - это стили префиксов методов, применяемых для чтения и записи значений параметров. Аксессор, также известный как метод доступа или геттер, используется для доступа к значению членов класса, а мутатор, также известный как метод изменения или сеттер, используется для изменения значения членов класса.\n\nЗначение @property заключается в том, что оно автоматически генерирует геттер и сеттер для члена класса одновременно при использовании этого декоратора. Это упрощает работу с данными и может сократить объем кода.\n\nВот простой пример использования @property:\n\n```python\nclass Person:\n    def __init__(self, name):\n        self._name = name\n\n    @property\n    def name(self):\n        return self._name\n\n    @name.setter\n    def name(self, value):\n        self._name = value\n\nperson = Person(\"John\")\nprint(person.name) # John\nperson.name = \"Mike\"\nprint(person.name) # Mike\n```\n\nВ этом примере мы создали класс Person с приватным полем \\_name, и использовали декоратор @property для создания геттера и сеттера для этого поля. Мы можем получить доступ к значению \\_name, используя свойство name объекта, и изменить его значение, используя сеттер, как будто это обычное поле класса.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 172,
  "fields": {
    "question": "Различия методов append() и extend().?",
    "answer": "Метод append() используется для добавления одного элемента в конец списка, в то время как метод extend() используется для объединения двух списков в один. Для примера, давайте рассмотрим следующий код:\n\n```python\na = [1, 2, 3]\nb = [4, 5, 6]\na.append(4)\nprint(a)\na.extend(b)\nprint(a)\n```\n\nВывод:\n\n```python\n[1, 2, 3, 4]\n[1, 2, 3, 4, 5, 6]\n```\n\nКак видим, после применения метода append() к списку a, он увеличился на один элемент. После применения метода extend() к списку a, элементы из списка b были добавлены в конец списка a.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 173,
  "fields": {
    "question": "Назовите несколько методов, которые используются для реализации функционально-ориентированного программирования в Python?",
    "answer": "Вот несколько методов, используемых для реализации функционально-ориентированного программирования в Python:\n\n- lambda-функции: они позволяют создавать анонимные функции, которые могут быть использованы в качестве аргументов функций.\n\n- Функции высшего порядка: функции, которые могут принимать другие функции в качестве аргументов или возвращать функции.\n\n- Функции map, filter и reduce: эти функции позволяют применять функцию к каждому элементу в коллекции, фильтровать элементы на основе условия и сводить список к одному значению соответственно.\n\n- Генераторы: они позволяют создавать итераторы, которые генерируют значения на лету, вместо того, чтобы создавать список значений заранее.\n\n- Декораторы: они позволяют изменять поведение функций или классов, добавляя дополнительную функциональность.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 174,
  "fields": {
    "question": "Каков результат следующего?",
    "answer": "```python\nx = ['ab', 'cd']\nprint(len(map(list, x)))\n```\n\nКод приведет к ошибке TypeError, поскольку функция map() возвращает объект map в Python 3, который нельзя использовать в качестве аргумента функции len(). Чтобы исправить ошибку и получить ожидаемый результат 2, вы можете преобразовать объект карты в список до получения его длины:\n\n```python\nx = ['ab', 'cd']\nlst = list(map(list, x))\nprint(len(lst))\n```\n\nЭто выведет 2, что является длиной списка списков, возвращаемых после сопоставления функции list() с каждым элементом в x.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 175,
  "fields": {
    "question": "Каков результат следующего?",
    "answer": "```python\nx = ['ab', 'cd']\nprint(len(list(map(list, x))))\n```\n\nРезультатом выполнения кода будет 4.\n\nЭто связано с тем, что функция map создаст новый список, в котором для каждого элемента списка x будет вызвана функция list. В данном случае это означает, что каждая строка из списка x будет преобразована в список символов. Результат будет выглядеть следующим образом: [['a', 'b'], ['c', 'd']]. Затем будет вызвана функция list на этом новом списке, который содержит два подсписка, и возвращено значение 4, поскольку список содержит четыре элемента.\n\nТаким образом, len(list(map(list, x))) возвращает количество элементов в списке, который содержит подсписки, созданные с помощью функции map.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 176,
  "fields": {
    "question": "Что из следующего не является правильным синтаксисом для создания множества?",
    "answer": "a) set([[1,2],[3,4]])\nb) set([1,2,2,3,4])\nc) set((1,2,3,4))\nd) {1,2,3,4}\n\nВсе варианты кроме a) являются правильным синтаксисом для создания множества. Вариант a) содержит вложенный список, который не может быть элементом множества в Python. Чтобы создать множество из списка списков, необходимо использовать цикл или генератор списка. Например, чтобы создать множество из списка [[1,2],[3,4]], можно использовать следующий код:\n\n```python\nmy_list = [[1,2],[3,4]]\nmy_set = set(tuple(i) for i in my_list)\n```\n\nЗдесь мы преобразуем вложенные списки в кортежи, потому что кортежи могут быть элементами множества в Python, в отличие от списков. Таким образом, правильный ответ на вопрос: a).",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 177,
  "fields": {
    "question": "Напишите функцию Python, которая проверяет, является ли переданная строка палиндромом или нет?",
    "answer": "Пример функции на Python, которая проверяет, является ли переданная строка палиндромом:\n\n```python\ndef is_palindrome(s):\n    return s == s[::-1]\n```\n\nЭта функция использует срезы для создания обратной копии строки и затем сравнивает ее с оригинальной строкой. Если строки равны друг другу, то переданная строка является палиндромом.\n\nВы можете вызвать эту функцию, передав строку в качестве аргумента:\n\n```python\nmy_string = \"racecar\"\nresult = is_palindrome(my_string)\nprint(result)  # True\n```\n\nВот еще один вариант сравнения строк без использования срезов, если вы хотите использовать цикл и сравнить по символьно:\n\n```python\ndef is_palindrome(s):\n    for i in range(len(s)):\n        if s[i] != s[-i-1]:\n            return False\n    return True\n```\n\nЭта функция итерирует через строку и сравнивает i-й символ строки с символом на позиции len(s)-i-1 (т.е. символом от конца строки на той же позиции). Если в какой-то момент строки не равны друг другу, функция возвращает False. Если весь цикл завершается успешно, то строка является палиндромом и функция возвращает True.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 178,
  "fields": {
    "question": "Написать программу на Python для вычисления суммы списка чисел?",
    "answer": "Для этого можно использовать функцию sum(), которая принимает список в качестве аргумента и возвращает сумму всех элементов:\n\n```python\nlst = [1, 2, 3, 4, 5]\nsummation = sum(lst)\nprint(summation)\n```\n\nВ этом примере список [1, 2, 3, 4, 5] передается в функцию sum(), которая возвращает сумму всех его элементов - 15. Данное значение затем выводится на экран.\n\nМожно также вычислить сумму элементов списка с помощью цикла for:\n\n```python\nlst = [1, 2, 3, 4, 5]\nsummation = 0\nfor i in lst:\n    summation += i\nprint(summation)\n```\n\nВ этом примере переменная summation инициализируется значением 0, а затем в цикле for проходится по всем элементам списка lst и их значения добавляются к переменной summation. Результат также выводится на экран.\n\nОба этих примера вычисляют сумму элементов списка и выводят результат на экран. Вы можете использовать любой из них в зависимости от того, что больше нравится.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 179,
  "fields": {
    "question": "Как получить данные из таблицы в базе данных MySQL с помощью кода Python?",
    "answer": "Вы можете получить данные из таблицы в базе данных MySQL с помощью библиотеки Python для работы с базами данных - mysql-connector-python. Вот пример кода, который подключается к базе данных MySQL и выполняет запрос SELECT для выборки данных из таблицы:\n\n```python\nimport mysql.connector\n\n# Подключение к базе данных\nmydb = mysql.connector.connect(\n  host=\"localhost\",\n  user=\"yourusername\",\n  password=\"yourpassword\",\n  database=\"mydatabase\"\n)\n\n# Выборка данных из таблицы\nmycursor = mydb.cursor()\nmycursor.execute(\"SELECT * FROM mytable\")\nmyresult = mycursor.fetchall()\n\n# Вывод результатов\nfor x in myresult:\n  print(x)\n```\n\nЗдесь вы можете заменить \"yourusername\", \"yourpassword\", \"mydatabase\" и \"mytable\" соответственно на имя пользователя, пароль, название базы данных и таблицы. Вы также можете изменить запрос SELECT, чтобы выбрать только нужные столбцы или добавить условия WHERE для фильтрации результатов.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 180,
  "fields": {
    "question": "Напишите программу на Python для чтения случайной строки из файла.",
    "answer": "Для чтения случайной строки из файла будет выглядеть следующим образом, при использовании модуля random:\n\n```python\nimport random\n\nwith open(\"file.txt\", \"r\") as f:\n    lines = f.readlines()\n    random_line = random.choice(lines)\n\nprint(random_line)\n```\n\nПри такой реализации, программа открывает файл \"file.txt\" и считывает все строки в переменную lines, а затем использует функцию random.choice() из модуля random, чтобы выбрать случайную строку из списка lines. Полученная строка выводится на экран. Метод with open() автоматически закрывает файл после его использования. При необходимости можно указать полный путь к файлу вместо его имени, чтобы обратиться к нужному файлу в нужной директории.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 181,
  "fields": {
    "question": "Написать программу на Python для подсчета количества строк в текстовом файле?",
    "answer": "Пример программы:\n\n```python\nwith open('filename.txt', 'r') as file:\n    line_count = 0\n    for line in file:\n        if line.strip():\n            line_count += 1\nprint(f'Количество строк в файле: {line_count}')\n```\n\nПрограмма открывает файл 'filename.txt' и читает его построчно. Так как пустые строки тоже считаются строками, программа проверяет, не является ли строка пустой, с помощью метода strip(). Если строка не пустая, программа увеличивает счетчик строк на 1. В конце программа выводит количество строк в файле.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 182,
  "fields": {
    "question": "Каковы ключевые особенности Python?",
    "answer": "Python имеет много ключевых особенностей, вот некоторые из них:\n\n- Простой синтаксис: Python использует отступы вместо фигурных скобок для организации кода, что делает его более читаемым и приятным для написания.\n\n- Интерпретируемый: Python не требует компиляции, поэтому вы можете быстро проверить свой код и исправить ошибки.\n\n- Кросс-платформенность: Python может выполняться на различных операционных системах, в том числе на Windows, macOS и Linux.\n\n- Широкий список библиотек: Python имеет большое количество библиотек для различных задач, таких как анализ данных, научные вычисления, веб-разработка и многое другое.\n\n- Объектно-ориентированное программирование: Python можно использовать как объектно-ориентированный язык программирования, что дает возможность использовать наследование, полиморфизм и инкапсуляцию.\n\n- Динамическая типизация: в Python переменные могут иметь различные типы во время выполнения программы.\n\n- Поддержка функционального программирования: Python имеет поддержку функций высшего порядка, замыканий и анонимных функций, что делает его более гибким.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 183,
  "fields": {
    "question": "Объясните тернарный оператор в Python?",
    "answer": "В Python тернарный оператор используется для написания простых конструкций if-else в одну строку. Он имеет следующий синтаксис:\n\n```python\nvalue_if_true if condition else value_if_false\n```\n\nТо есть, если условие condition истинно, то выражение вернет value_if_true, а в противном случае вернется value_if_false. Вот примеры его использования:\n\n```python\nx = 5\ny = 10\nmax_value = x if x > y else y\n```\n\nЭто эквивалентно следующему коду:\n\n```python\nif x > y:\n    max_value = x\nelse:\n    max_value = y\n```\n\nЕще один пример:\n\n```python\nallowed_age = 18\nage = 20\naccess = 'allowed' if age >= allowed_age else 'denied'\n```\n\nЕсли возраст age старше или равен allowed_age, то переменная access будет равна 'allowed'. Если возраст меньше allowed_age, то access будет равен 'denied'.\n\nТернарный оператор в Python может быть использован с любыми выражениями в качестве значений value_if_true и value_if_false, включая вызов функций и использование других операторов. Однако, иногда использование нескольких операторов в одной строке может усложнить понимание кода и снизить его читабельность.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 184,
  "fields": {
    "question": "Что такое многопоточность?",
    "answer": "Многопоточность - это возможность выполнять несколько потоков исполнения одновременно в рамках одного процесса. Это позволяет улучшить производительность программы, так как неиспользуемое время процессора может быть выделено для выполнения других задач. В Python многопоточность может быть реализована с помощью модуля threading. Этот модуль предоставляет класс Thread, который можно использовать для создания и управления потоками исполнения.\n\nНапример, вот простой пример использования модуля threading для создания двух потоков:\n\n```python\nimport threading\n\ndef function1():\n    print(\"This is function 1\")\n\ndef function2():\n    print(\"This is function 2\")\n\nt1 = threading.Thread(target=function1)\nt2 = threading.Thread(target=function2)\n\nt1.start()\nt2.start()\n\nt1.join()\nt2.join()\n\nprint(\"Both threads are done!\")\n```\n\nЭтот пример создает два потока исполнения, каждый из которых вызывает свою функцию. Затем он запускает оба потока и дожидается их завершения. Обратите внимание, что порядок вывода результатов может отличаться для каждого запуска, потому что потоки работают асинхронно.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 185,
  "fields": {
    "question": "Расскажите о функциях help() и dir() в Python?",
    "answer": "Функция help() и dir() это стандартные встроенные функции в Python, которые предоставляют информацию о модулях, классах, функциях и методах.\n\nФункция help() используется для получения помощи о любом объекет (модуль, класс, функция, метод, переменная и т. д.) в Python. Когда вы передаете объект в качестве аргумента функции help(), функция выводит детальную информацию о данном объекте, включая документацию и атрибуты.\n\nФункция dir() используется для получения списка атрибутов и методов, доступных для данного объекта в Python. Когда вы передаете объект в качестве аргумента функции dir(), функция выводит список всех доступных атрибутов и методов для данного объекта.\n\nПример использования help() и dir():\n\n```python\nimport math\n\n# Получить справку о модуле math с помощью функции help()\nhelp(math)\n\n# Получить список атрибутов и методов модуля math с помощью функции dir()\nprint(dir(math))\n```\n\nОчень полезно использовать dir() и help() для изучения функций и классов в Python, а также для нахождения методов и атрибутов, которые можно использовать с определенными объектами.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 186,
  "fields": {
    "question": "Что такое словарь в Python?",
    "answer": "Словарь (dictionary) - это структура данных, которая хранит пары \"ключ-значение\". Ключи должны быть уникальными и неизменяемыми (часто используются строки или числа), а значения могут быть любого типа данных (например, числа, строки, списки, другие словари). Словари в Python - неупорядоченные, то есть элементы в словаре не имеют определенного порядка.\n\nВы можете создать словарь с помощью фигурных скобок {} и запятых для разделения элементов ключ-значение, например:\n\n```python\nmy_dict = {'apple': 5, 'banana': 2, 'orange': 8}\n```\n\nВы можете получить значение из словаря по ключу с помощью квадратных скобок [], например:\n\n```python\nprint(my_dict['apple'])  # выведет 5\n```\n\nВы можете изменить значение по ключу, просто присвоив новое значение через квадратные скобки, например:\n\n```python\nmy_dict['orange'] = 10\n```\n\nТакже, можно добавить новый элемент в словарь следующим образом:\n\n```python\nmy_dict['grape'] = 3\n```\n\nСуществуют множество методов для работы со словарями в Python, таких как .keys(), .values(), .items(), .update() и многих других.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 187,
  "fields": {
    "question": "Как получить список всех ключей словаря?",
    "answer": "В Python можно получить список всех ключей словаря с помощью метода keys() или просто обратившись к словарю как к итерируемому объекту.\n\nВот несколько примеров:\n\n```python\n# создаем словарь\nmy_dict = {'one': 1, 'two': 2, 'three': 3}\n\n# получаем список ключей с помощью метода keys()\nkeys_list = list(my_dict.keys())\nprint(keys_list)  # ['one', 'two', 'three']\n\n# или обращаемся к словарю как к итерируемому объекту\nkeys_list_2 = list(my_dict)\nprint(keys_list_2)  # ['one', 'two', 'three']\n```\n\nОбратите внимание, что вызов keys() возвращает объект типа dict_keys, поэтому мы используем в примере функцию list() для преобразования его в список.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 188,
  "fields": {
    "question": "Написать логику Python для подсчета количества заглавных букв в файле?",
    "answer": "Для подсчета количества заглавных букв в файле вам необходимо прочитать содержимое файла в строку, затем использовать метод isupper() для каждого символа в строке и подсчитать количество символов, которые являются заглавными буквами. Вот пример реализации этой логики:\n\n```python\nfile_path = \"path/to/your/file.txt\"\ncount = 0\n\nwith open(file_path, 'r') as file:\n    content = file.read()\n    for char in content:\n        if char.isupper():\n            count += 1\n\nprint(\"Количество заглавных букв в файле: \", count)\n```\n\nЗдесь мы открываем файл file_path в режиме чтения и читаем его содержимое в переменную content. Затем мы перебираем каждый символ в этой строке и проверяем, является ли он заглавной буквой, используя метод isupper(). Если символ является заглавной буквой, мы увеличиваем счетчик count. В конце мы выводим количество найденных заглавных букв.\n\nЭтот пример предполагает, что файл содержит только текстовые данные. Если в файле есть другие виды данных, такие как изображения или бинарные данные, этот код может не работать должным образом.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 189,
  "fields": {
    "question": "Как бы вы рандомизировали содержимое списка на месте?",
    "answer": "Рандомизировать содержимое списка на месте, используя встроенную функцию shuffle() из модуля random. Вот пример кода:\n\n```python\nimport random\n\nmy_list = [1, 2, 3, 4, 5]\nrandom.shuffle(my_list)\nprint(my_list)\n```\n\nЭтот код перемешает элементы списка my_list в случайном порядке.\n\nОбратите внимание, что функция shuffle() изменяет список на месте и не возвращает копию списка. Если вы хотите сохранить исходный порядок списка, создайте его копию и примените shuffle() к этой копии.\n\n```python\nimport random\n\nmy_list = [1, 2, 3, 4, 5]\nshuffled_list = my_list.copy()\nrandom.shuffle(shuffled_list)\nprint(shuffled_list)\nprint(my_list)    # останется неизменным\n```\n\nВ этом примере функция shuffle() применяется к копии списка my_list, так что исходный порядок остается неизменным, а перемешанный список хранится в shuffled_list.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 190,
  "fields": {
    "question": "Объясните join() и split() в Python?",
    "answer": "Метод join() используется для соединения элементов списка или другой последовательности строк в единый текстовый элемент. Он возвращает строку, состоящую из всех элементов списка, соединенных строкой, на которую был вызван метод.\n\nВот пример, который объединяет элементы списка в одну строку с разделителем \",\":\n\n```python\nmy_list = ['apple', 'banana', 'orange']\nresult = ', '.join(my_list)\nprint(result)\n```\n\nНа выходе будет строка: \"apple, banana, orange\"\n\nМетод split(), наоборот, разбивает строку на список элементов. Он разбивает строку на элементы, используя указанный разделитель, и возвращает список полученных элементов.\n\nВот пример, который разбивает строку, используя пробел в качестве разделителя:\n\n```python\nmy_string = \"This is a sentence\"\nresult = my_string.split()\nprint(result)\n```\n\nНа выходе будет список: [\"This\", \"is\", \"a\", \"sentence\"]\n\nОбъединение элементов списка в строку и разбивка строки на элементы списка с помощью методов join() и split() являются часто используемыми приемами в Python, особенно при работе с текстовыми данными и файлами.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 191,
  "fields": {
    "question": "Является ли Python чувствительным к регистру?",
    "answer": "Да, Python чувствителен к регистру. Это означает, что идентификаторы, такие как имена переменных, должны быть написаны точно так же, как и при их определении. Например, переменная my_var и My_Var будут считаться разными переменными в Python.\n\nТо же самое относится и к именам функций, классов и модулей.\n\nОднако есть некоторые методы строк (например, lower(), upper(), title()) и встроенные функции (например, print()) в Python, которые не являются чувствительными к регистру. Вот пример использования функции lower() для преобразования всех символов в строке в нижний регистр:\n\n```python\nmy_string = \"Hello World\"\nlowercase_string = my_string.lower()\nprint(lowercase_string) # вывод на экран: \"hello world\"\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 192,
  "fields": {
    "question": "Как удалить начальный пробел в строке?",
    "answer": "Для удаления начального пробела в строке в Python можно использовать метод lstrip(). Например:\n\n```python\nmy_string = \"   example string\"\nmy_string = my_string.lstrip()\nprint(my_string) #Этот код выведет строку без начального пробела: \"example string\".\n```\n\nТакже можно использовать метод strip() для удаления не только начальных, но и конечных пробелов: my_string = my_string.strip().",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 193,
  "fields": {
    "question": "Что такое оператор pass в Python?",
    "answer": "Оператор pass в Python представляет собой пустой оператор, который не делает ничего. Он может использоваться в качестве заполнителя при написании кода, когда необходимо указать некоторое действие, но его реализация еще не готова, либо не требуется какое-либо действие.\n\nНапример, он может использоваться в теле функции, если на данном этапе реализация определенного блока кода не требуется, но он должен быть определен в будущем, т.к. без него код не будет компилироваться или работать некорректно.\n\nПример использования оператора pass внутри функции:\n\n```python\ndef my_func():\n    pass\n```\n\nЭта функция ничего не делает, но благодаря оператору pass код компилируется и она может быть вызвана без ошибок.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 194,
  "fields": {
    "question": "Что такое замыкание в Python?",
    "answer": "Замыкание (closure) - это функция, которая сохраняет доступ к переменным в своей внешней области видимости, даже если эта область видимости уже вышла из области действия.\n\nДругими словами, замыкание - это функция, которая запоминает значения своих свободных переменных, даже если эта функция вызывается в другой области видимости.\n\nНапример, следующий код определяет внешнюю функцию outer, внутри которой определяется внутренняя функция inner, которая возвращает строку, содержащую значение x:\n\n```python\ndef outer(x):\n  def inner():\n    return f\"x is {x}\"\n  return inner\n\nclosure = outer(5)\nprint(closure())  # output: \"x is 5\"\n```\n\nВ этом примере, closure будет замыканием, так как функция inner запоминает значение переменной x из внешней функции outer, даже после того, как outer уже закончила свою работу.\n\nЗамыкания могут быть полезными, когда вы хотите связать некоторые данные с функцией, но не хотите передавать эти данные как аргументы при каждом вызове функции.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 195,
  "fields": {
    "question": "Объясните операторы // % и \\*\\* в Python.",
    "answer": "Операторы //, % и \\*\\* это операторы целочисленного деления, остатка от деления и возведения в степень.\n\nОператор // возвращает частное от целочисленного деления двух чисел. Например, 7 // 3 вернет 2, так как 7 поделить на 3 равно 2 с остатком 1.\n\nОператор % возвращает остаток от целочисленного деления двух чисел. Например, 7 % 3 вернет 1, так как 7 поделить на 3 равно 2 с остатком 1.\n\nОператор ** возвращает результат возведения числа в степень. Например, 2 ** 3 вернет 8, так как 2 в третьей степени равно 8.\n\nВот некоторые примеры использования этих операторов:\n\n```python\na = 7\nb = 3\n\n# Целочисленное деление\nprint(a // b)  # Output: 2\n\n# Остаток от деления\nprint(a % b)   # Output: 1\n\n# Возведение в степень\nprint(2 ** 3)  # Output: 8\n\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 196,
  "fields": {
    "question": "Сколько видов операторов есть в Python? Объясните арифметические операторы.",
    "answer": "В Python есть много видов операторов, в том числе:\n\n- Арифметические операторы: + (сложение), - (вычитание), \\* (умножение), / (обычное деление), // (целочисленное деление), % (остаток от деления), \\*\\* (возведение в степень).\n\n- Операторы сравнения: == (равно), != (не равно), > (больше), < (меньше), >= (больше или равно), <= (меньше или равно).\n\n- Логические операторы: and (логическое И), or (логическое ИЛИ), not (логическое НЕ).\n\n- Операторы присваивания: = (присваивание), += (прибавление и присваивание), -= (вычитание и присваивание), \\*= (умножение и присваивание), /= (обычное деление и присваивание), //= (целочисленное деление и присваивание), %= (остаток от деления и присваивание), \\*\\*= (возведение в степень и присваивание).\n\n- Операторы идентичности: is (True, если две переменные ссылаются на один и тот же объект), is not (True, если две переменные не ссылаются на один и тот же объект).\n\n- Операторы членства: in (True, если элемент присутствует в последовательности), not in (True, если элемент отсутствует в последовательности).\n\nВ Python существует несколько арифметических операторов для выполнения различных вычислений. Они включают в себя:\n\n- - сложение\n\n* - вычитание\n\n- - умножение\n\n/ - деление\n\n% - остаток от деления\n\n\\*\\* - возведение в степень\n\nНапример, вы можете использовать их следующим образом:\n\n```python\na = 10\nb = 5\nc = a + b # сложение\nd = a - b # вычитание\ne = a * b # умножение\nf = a / b # деление\ng = a % b # остаток от деления\nh = a ** 2 # возведение числа в степень\n```\n\nВ результате выполнения этих операций соответствующие переменные будут иметь следующие значения:\n\n```python\nc = 15\nd = 5\ne = 50\nf = 2.0\ng = 0\nh = 100\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 197,
  "fields": {
    "question": "Объясните операторы сравнения (отношения) в Python?",
    "answer": "О+ператоры сравнения используются для сравнения значений и возвращают булево значение True или False в зависимости от того, выполняется ли условие или нет.\n\nОператоры сравнения в Python:\n\n- равно ==: возвращает True, если оба значения равны\n\n- не равно !=: возвращает True, если оба значения не равны\n\n- меньше <: возвращает True, если первое значение меньше второго\n\n- больше >: возвращает True, если первое значение больше второго\n\n+меньше или равно <=: возвращает True, если первое значение меньше или равно второму\n\n- больше или равно >=: возвращает True, если первое значение больше или равно второму\n\nПримеры:\n\n```python\nx = 5\ny = 10\nprint(x == y) # False\nprint(x != y) # True\nprint(x < y) # True\nprint(x > y) # False\nprint(x <= y) # True\nprint(x >= y) # False\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 198,
  "fields": {
    "question": "Что такое операторы присваивания в Python?",
    "answer": "В Python операторы присваивания используются для присвоения значений переменным. Обычно оператор присваивания имеет вид =.\n\nВот некоторые примеры:\n\n```python\nx = 5  # присваивание значения 5 переменной x\ny = \"hello\"  # присваивание строки \"hello\" переменной y\nz = some_function()  # присваивание значения, возвращаемого функцией some_function(), переменной z\n```\n\nВ Python также есть операторы присваивания в сочетании с другими операторами, такими как +=, -= и т.д., которые позволяют сократить запись некоторых выражений. Например:\n\n```python\nx += 5  # то же, что и x = x + 5\ny *= 2  # то же, что и y = y * 2\n```\n\nНаиболее новым оператором присваивания в Python является оператор \"walrus\" :=, который позволяет присваивать значение переменной внутри выражения. Например:\n\n```python\nwhile (n := len(input())) > 0:\n    # выполнять цикл до тех пор, пока длина строки input() больше нуля,\n    # и присваивать значение длины строки переменной n внутри выражения\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 199,
  "fields": {
    "question": "Объясните логические операторы в Python.",
    "answer": "Eсть три логических оператора: and, or и not.\n\n- and (и) возвращает True, если оба операнда True, иначе False:\n\n```python\nTrue and True   # True\nTrue and False  # False\nFalse and False # False\n```\n\n- or (или) возвращает True, если хотя бы один операнд True, иначе False:\n\n```python\nTrue or True    # True\nTrue or False   # True\nFalse or False  # False\n```\n\n- not (не) возвращает True, если операнд False, иначе False:\n\n```python\nnot True  # False\nnot False # True\n```\n\nТакже в Python есть побитовые логические операторы &, |, ^, ~, но они работают с битами чисел и не относятся к основным логическим операторам.\n\nЛогические операторы используют \"ленивое вычисление\" (short-circuit evaluation). Это означает, что при использовании оператора and, если первый операнд является False, второй операнд не будет вычислен, так как результат всего выражения уже известен. Аналогично, при использовании or, если первый операнд является True, второй операнд не будет вычислен, так как результат всего выражения уже известен. Это может быть полезно в тех случаях, когда второй операнд может быть невычислим в определенных условиях и может вызвать ошибку.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 200,
  "fields": {
    "question": "Что такое оператор членства?",
    "answer": "Оператор членства - это ключевые слова in и not in, которые используются для проверки на принадлежность элемента к последовательности или коллекции, такой как строка, список, кортеж, множество или словарь.\n\nСинтаксис:\n\n```python\nif x in s:\n    # код выполняется, если x принадлежит s\nif y not in lst:\n    # код выполняется, если y не принадлежит lst\n```\n\nНапример, при выполнении следующего кода:\n\n```python\nfruits = [\"apple\", \"banana\", \"cherry\"]\nif \"apple\" in fruits:\n    print(\"Yes, apple is a fruit!\")\n```\n\nРезультат выполнения программы будет: \"Yes, apple is a fruit!\", так как \"apple\" принадлежит списку fruits.\n\nОператор not in работает наоборот и возвращает True, если элемент не содержится в коллекции.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 201,
  "fields": {
    "question": "Объясните операторы идентификации в Python.",
    "answer": "Операторы идентификации используются для сравнения объектов и проверки, являются ли они одним и тем же объектом в памяти. Операторы идентификации в Python включают is и is not.\n\nОператор is возвращает True, если оба операнда ссылаются на один и тот же объект в памяти, в противном случае он возвращает False. Например:\n\n```python\nx = [1, 2, 3]\ny = x\nprint(x is y) # Output: True\n```\n\nОператор is not возвращает True, если оба операнда не ссылаются на один и тот же объект в памяти, в противном случае он возвращает False. Например:\n\n```python\na = [1, 2, 3]\nb = [1, 2, 3]\nprint(a is not b) # Output: True\n```\n\nОбратите внимание, что is и is not проверяют идентичность объектов, а не равенство их значений. Для сравнения значений объектов в Python используется оператор ==.\n\nНапример:\n\n```python\na = [1, 2, 3]\nb = [1, 2, 3]\nprint(a == b) # Output: True\n```\n\nМожно использовать операторы идентификации в условных выражениях для проверки, ссылаются ли две переменные на один и тот же объект в памяти.\n\nНапример:\n\n```python\nx = [1, 2, 3]\ny = x\nif x is y:\n    print(\"x and y refer to the same object\")\nelse:\n    print(\"x and y do not refer to the same object\")\n```\n\nЭто выражение выведет \"x and y refer to the same object\", потому что x и y имеют ссылку на один и тот же объект",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 202,
  "fields": {
    "question": "Расскажите о побитовых операторах в Python.",
    "answer": "В Python существует шесть бинарных побитовых операторов, которые работают с числами на уровне битов. Эти операторы работают так же, как и соответствующие им операторы в других языках программирования.\n\n- & (Побитовый AND) - возвращает 1 на битовую позицию, если оба бита равны 1.\n\n- | (Побитовый OR) - возвращает 1 на битовую позицию, если хотя бы один бит равен 1.\n\n- ^ (Побитовый XOR) - возвращает 1 на битовую позицию, если один из двух битов равен 1, но не оба.\n\n- ~ (Побитовый NOT) - инвертирует все биты операнда.\n\n- << (Побитовый сдвиг влево) - сдвигает биты операнда влево на указанное количество позиций, добавляя нули справа.\n\n- \">>\" (Побитовый сдвиг вправо) - сдвигает биты операнда вправо на указанное количество позиций.\n\nНапример, вот как можно использовать побитовые операторы:\n\n```python\na = 5  # 101\nb = 3  # 011\n\nc = a & b   # 001 (двоичный результат)\nd = a | b   # 111 (двоичный результат)\ne = a ^ b   # 110 (двоичный результат)\nf = ~a      # -6 (десятичный результат)\ng = a << 1  # 010 (двоичный результат)\nh = a >> 1  # 010 (двоичный результат)\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 203,
  "fields": {
    "question": "Как бы вы работали с числами, отличными от десятичной системы счисления?",
    "answer": "Для работы с числами в системах счисления, отличных от десятичной, можно использовать следующие функции и методы:\n\n- bin(), oct(), hex(): встроенные функции, которые принимают на вход целое число и возвращают его двоичное, восьмеричное или шестнадцатеричное представление соответственно:\n\n```python\nnum = 42\nprint(bin(num)) # '0b101010'\nprint(oct(num)) # '0o52'\nprint(hex(num)) # '0x2a'\n```\n\n- int(): встроенная функция, которая может преобразовывать строки, представляющие числа в разных системах счисления, в целые числа. Второй аргумент функции указывает на систему счисления и имеет значение по умолчанию 10 (десятичная система счисления):\n\n```python\nnum1 = int('101010', 2) # двоичная система счисления\nnum2 = int('52', 8) # восьмеричная система счисления\nnum3 = int('2a', 16) # шестнадцатеричная система счисления\nprint(num1) # 42\nprint(num2) # 42\nprint(num3) # 42\n```\n\n- format(): метод, который может использоваться для форматирования чисел в разных системах счисления:\n\n```python\nnum = 42\nprint('{0:b}'.format(num)) # '101010' двоичная система счисления\nprint('{0:o}'.format(num)) # '52' восьмеричная система счисления\nprint('{0:x}'.format(num)) # '2a' шестнадцатеричная система счисления\n```\n\n- Операторы побитовых сдвигов >> и <<: они могут быть использованы для сдвига числа вправо.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 204,
  "fields": {
    "question": "Почему имена идентификаторов с символом подчеркивания в начале не приветствуются?",
    "answer": "Имена идентификаторов с символом подчеркивания в начале обычно рассматриваются как \"приватные\" и их использование может привести к сложностям при поддержке кода. В Python имена, начинающиеся с символа подчеркивания, не имеют строгой защиты и могут быть вызваны из других модулей или извлечены с помощью интроспекции. Однако такие имена обычно считаются частью внутренней реализации модуля и не предназначены для использования в стороннем коде.\n\nPython рекомендует использовать имена с символом подчеркивания в начале для обозначения \"частных\" или \"внутренних\" компонентов в классах и модулях. Например, можно использовать подчеркивание в начале имени переменной, чтобы показать, что она предназначена только для внутреннего использования в классе, и не должна быть доступна извне.\n\nТакже стоит отметить, что в Python есть специальный способ определения \"частных\" методов и атрибутов с помощью двойного символа подчеркивания в начале (например, \\_\\_private_method(self)). Этот подход обеспечивает более строгую защиту и предотвращает случайную перезапись этих методов и атрибутов в подклассах или при использовании интроспекции.\n\nОднако, использование символа подчеркивания не является \"плохой\" практикой, если он используется в соответствии с рекомендациями языка.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 205,
  "fields": {
    "question": "Как можно объявить несколько присваиваний в одном операторе?",
    "answer": "Можно объявить несколько присваиваний в одной строке, разделив их запятой.\nНапример:\n\n```python\nx, y, z = 1, 2, 3\n```\n\nВ этом примере мы присваиваем переменным x, y и z значения 1, 2 и 3 соответственно. Также, вы можете использовать оператор присваивания в цепочке, где выражения вычисляются слева направо, и каждое следующее выражение использует результат предыдущего.\nНапример:\n\n```python\nx = y = z = 0\n```\n\nТеперь переменные x, y и z все будут иметь значение 0.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 206,
  "fields": {
    "question": "Что такое распаковка кортежа?",
    "answer": "Распаковка кортежа (tuple unpacking) - это процесс извлечения элементов кортежа и присваивания их значениям переменных в одной операции. Можно использовать распаковку кортежей для присвоения значения переменным одновременно с извлечением элементов из кортежа. Например, если у вас есть кортеж с двумя элементами, вы можете извлечь каждый элемент кортежа и присвоить их значениям двум переменным следующим образом:\n\n```python\na, b = (1, 2)\nprint(a) # Output: 1\nprint(b) # Output: 2\n```\n\nТакже , вы можете использовать операцию \\* во время распаковки, если вы хотите присвоить первый элемент кортежа одной переменной, а остальные - другой переменной:\n\n```python\na, *b = (1, 2, 3, 4)\nprint(a) # Output: 1\nprint(b) # Output: [2, 3, 4]\n```\n\nЭто очень удобное и мощное свойство кортежей в Python, которое помогает сделать код короче и более понятным.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 207,
  "fields": {
    "question": "Что такое slice (срез)?",
    "answer": "slice (срез) — это метод, который позволяет нам получить только часть списка, кортежа или строки. Для этого мы используем оператор среза [ ].\n\n```python\n     (1,2,3,4,5)[2:4]\n       # (3, 4)\n\n     [7,6,8,5,9][2:]\n        #[8, 5, 9]\n\n     'Hello'[:-1]\n       # 'Hell'\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 208,
  "fields": {
    "question": "Что такое именованный кортеж?",
    "answer": "Именованный кортеж (named tuple) - это структура данных, похожая на кортеж (tuple) в Python, но с возможностью обращаться к элементам не только по индексу, но и по имени. Он определен в модуле collections и представляет собой удобный способ определить класс, который может хранить несколько значений, и доступ к ним осуществляется как к атрибутам объекта.\n\nПример определения и использования именованного кортежа в Python:\n\n```python\nfrom collections import namedtuple\n\n# Определение именованного кортежа\nPerson = namedtuple('Person', ['name', 'age'])\n\n# Создание объекта типа Person\nperson1 = Person(name='John', age=25)\n\n# Обращение к значениям объекта по имени\nprint(person1.name)  # выведет 'John'\nprint(person1.age)  # выведет 25\n```\n\nИменованные кортежи часто используются в Python для представления данных, когда необходимо предоставить имя каждому элементу кортежа для более ясного понимания его содержания.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 209,
  "fields": {
    "question": "Как бы вы преобразовали строку в целое число в Python?",
    "answer": "Для преобразования строки в целое число можно использовать встроенную функцию int(). Например:\n\n```python\nstring_num = \"123\"\nint_num = int(string_num)\nprint(int_num) # Выводит 123\n```\n\nФункция int() может принимать необязательный второй аргумент, который указывает основание системы счисления. По умолчанию основание равно 10. Если передать строку в формате, отличном от десятичного, и не указать основание, то будет вызвано исключение ValueError. Например:\n\n```python\nbinary_num = \"101010\"\nint_num = int(binary_num, 2)\nprint(int_num) # Выводит 42\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 210,
  "fields": {
    "question": "Как вы вводите данные в Python?",
    "answer": "Данные можно вводить с помощью функции input(). Она позволяет ввести данные с клавиатуры в консольном приложении. Вот пример:\n\n```python\nname = input(\"Введите ваше имя: \")\nprint(\"Привет, \" + name + \"!\")\n```\n\nЭтот код запросит у пользователя ввод его имени и затем выведет приветственное сообщение с использованием этого имени.\n\nТакже можно прочитать данные из файлов, с помощью функции open(). Например:\n\n```python\nfile = open(\"example.txt\", \"r\")\ncontent = file.read()\nprint(content)\nfile.close()\n```\n\nЭтот код открывает файл с именем \"example.txt\" для чтения и затем выводит его содержимое. Метод close() используется для закрытия файла после завершения работы с ним.\n\nЕсли вам нужны более сложные механизмы ввода данных, то можно рассмотреть использование сторонних библиотек, например, tkinter для создания графических интерфейсов пользователя.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 211,
  "fields": {
    "question": "Что такое замороженный набор в Python?",
    "answer": "Замороженный набор (frozenset) - это неизменяемая версия набора (set). Он содержит уникальные и неизменяемые (хешируемые) элементы в порядке, который зависит от хеширования. Замороженный набор отлично подходит для использования в качестве ключа словаря, так как он сам является хешируемым объектом и не может быть изменен после создания. Для создания замороженного набора можно использовать функцию frozenset():\n\n```python\n>>> s = set([1, 2, 3])\n>>> fs = frozenset(s)\n>>> type(fs)\n<class 'frozenset'>\n```\n\nЗамороженный набор поддерживает большинство методов set, но не поддерживает методы, которые изменяют его содержимое, такие как add() и remove().",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 212,
  "fields": {
    "question": "Как бы вы сгенерировали случайное число в Python?",
    "answer": "Для генерации случайных чисел можно использовать модуль random. Вот пример кода, который генерирует случайное целое число в диапазоне от 0 до 9:\n\n```python\nimport random\n\nrandom_number = random.randint(0, 9)\nprint(random_number)\n```\n\nВы можете изменить аргументы randint() в соответствии с вашими потребностями. Модуль random также предоставляет множество других функций для генерации случайных чисел, таких как random(), который генерирует случайные числа с плавающей точкой в диапазоне от 0 до 1, и choice(), который выбирает случайный элемент из списка.\n\nЧтобы использовать модуль random, его нужно импортировать.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 213,
  "fields": {
    "question": "Как сделать заглавной первую букву строки?",
    "answer": "Eсть несколько способов сделать заглавной первую букву строки:\n\n- С помощью метода capitalize()\n\nМетод capitalize() сделает первую букву строки заглавной, а остальные - строчными:\n\n```python\ns = 'hello, world!'\ns = s.capitalize()\nprint(s)  # 'Hello, world!'\n```\n\n- С помощью метода title()\n\nМетод title() сделает первые буквы каждого слова в строке заглавными, а остальные - строчными:\n\n```python\ns = 'hello, world!'\ns = s.title()\nprint(s)  # 'Hello, World!'\n```\n\n- С помощью среза и метода upper()\n\nВы можете использовать срез для получения первой буквы строки, привести ее к верхнему регистру с помощью метода upper(), а затем объединить ее с остальной частью строки:\n\n```python\ns = 'hello, world!'\ns = s[0].upper() + s[1:]\nprint(s)  # 'Hello, world!'\n```\n\nНезависимо от выбранного метода, важно помнить, что строки в Python являются неизменяемыми объектами, то есть после создания строки нельзя изменить ее символы.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 214,
  "fields": {
    "question": "Как проверить, все ли символы в строке буквенно-цифровые?",
    "answer": "Можно использовать метод isalnum() для проверки, являются ли все символы в строке буквенно-цифровыми. Он возвращает значение True, если все символы являются буквенно-цифровыми и False, если в строке есть символы, которые не являются буквенно-цифровыми.\n\nВот пример использования метода isalnum():\n\n```python\nmy_string = \"abc123\"\nif my_string.isalnum():\n    print(\"All characters are alphanumeric\")\nelse:\n    print(\"There are non-alphanumeric characters in the string\")\n```\n\nЕсли нужно проверить все символы в строке на то, что они являются либо буквами, либо цифрами, то можно воспользоваться методом isalpha() для буквенных символов и методом isdigit() для цифровых символов.\n\n```python\nmy_string = \"abc123\"\nif all(c.isalpha() or c.isdigit() for c in my_string):\n    print(\"All characters are alphanumeric\")\nelse:\n    print(\"There are non-alphanumeric characters in the string\")\n```\n\nОбе функции возвращают значение типа bool, которое показывает, является ли символ буквой или цифрой. Функция all() принимает итерируемый объект, содержащий результаты проверки на то, что символы являются буквами или цифрами.\n\nНапример, при использовании вышеуказанного кода для строки my_string = \"abc123\", вывод будет All characters are alphanumeric, так как все символы являются буквенно-цифровыми. Если же строка содержит символ, который не является буквенно-цифровым, то вывод будет There are non-alphanumeric characters in the string.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 215,
  "fields": {
    "question": "Что такое конкатенация?",
    "answer": "Конкатенация - это объединение двух или более строк в одну новую строку. Для конкатенации строк можно использовать оператор \"+\" или метод join().\n\nПример с использованием оператора +:\n\n```python\nstr1 = \"Hello\"\nstr2 = \"World\"\nresult = str1 + \" \" + str2\nprint(result) #Вывод: Hello World\n```\n\nПример с использованием метода join():\n\n```python\nmy_list = [\"apple\", \"banana\", \"cherry\"]\nresult = \", \".join(my_list)\nprint(result) #Вывод: apple, banana, cherry\n```\n\nПри конкатенации строк с помощью оператора + каждая новая строка создается заново, поскольку строки в Python являются неизменяемыми объектами. Поэтому, если вам нужно объединить большое количество строк, более эффективным будет использовать метод join().",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 216,
  "fields": {
    "question": "Что такое функция?",
    "answer": "Функция в Python - это блок кода, который может выполнять определенную задачу при вызове. Функции создаются с использованием ключевого слова def, за которым следует имя функции и в скобках - аргументы функции (если они есть). Затем следует блок кода, который будет выполнен при вызове функции. Функция может возвращать значение при помощи ключевого слова return.\n\nВот простой пример функции, которая возвращает сумму двух чисел:\n\n```python\ndef sum(a, b):\n    return a + b\n```\n\nВызов этой функции может быть выполнен ожидаемо:\n\n```python\nresult = sum(1, 2)\nprint(result) # выводит 3\n```\n\nЭто довольно базовый пример, однако функции в Python могут быть более сложными, принимать списки, словари или другие функции в качестве аргументов, а также возвращать объекты более сложных типов данных.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 217,
  "fields": {
    "question": "Что такое рекурсия?",
    "answer": "Рекурсия - это процесс вызова функции, который включает в себя вызов функции изнутри самой функции. То есть функция вызывает саму себя для выполнения дополнительной задачи, которая зависит от предыдущего вызова функции.\n\nПримером рекурсии может быть функция, которая вычисляет факториал числа. Факториал числа - это произведение всех положительных целых чисел до данного числа. Он может быть выражен рекурсивно, как факториал (n) = n \\* факториал (n-1), где факториал (1) = 1. Вот пример рекурсивной функции, которая вычисляет факториал числа:\n\n```python\ndef factorial(n):\n    if n == 1:\n        return 1\n    else:\n        return n * factorial(n-1)\n```\n\nПри вызове функции factorial(5) она будет вызвана 5 раз, с каждым разом уменьшая передаваемое число, поскольку оно участвует в рекурсивной формуле.\n\nРекурсия может быть очень полезной при решении некоторых задач программирования, но важно помнить, что она может легко привести к бесконечной петле, если условие выхода не определено правильно. Поэтому, если вы пишете рекурсивную функцию, убедитесь, что вы определили условие завершения правильно.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 218,
  "fields": {
    "question": "Что делает функция zip()?",
    "answer": "Функция zip() используется для сопоставления элементов нескольких списков. Она принимает один или более итераторов и возвращает новый итератор, который возвращает кортежи из элементов каждого итератора на каждой итерации. В результате создается новый список кортежей, содержащий элементы из каждого переданного списка в соответствующих позициях.\n\nВот пример использования zip():\n\n```python\nlist1 = [1, 2, 3]\nlist2 = ['a', 'b', 'c']\nlist3 = [True, False, True]\n\nresult = list(zip(list1, list2, list3))\nprint(result)\n```\n\nЭтот код создает новый список кортежей, состоящий из элементов первого списка на позициях 1, 2 и 3, элементов второго списка на позициях 'a', 'b' и 'c', и элементов третьего списка на позициях True, False и True.\n\nРезультат будет выводить список кортежей:\n\n```python\n[(1, 'a', True), (2, 'b', False), (3, 'c', True)].\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 219,
  "fields": {
    "question": "Если вы когда-нибудь застряли в бесконечном цикле, как вы из него вырветесь?",
    "answer": "- Чтобы выйти из бесконечного цикла, вы можете остановить его, нажав Ctrl + C (в Windows) или Cmd + C (в Mac). Это отправит сигнал прерывания в вашу программу, что заставит ее остановиться.\n\n- Чтобы выйти из бесконечного цикла, вы можете использовать оператор break. Вот пример:\n\n```python\nwhile True:\n    # do some infinite loop stuff\n    if some_condition == True:\n        break\n```\n\nВ этом примере цикл while будет выполняться бесконечно, пока значение параметра some_condition не станет равным True. Как только some_condition станет истинным, будет выполнен оператор break, что приведет к завершению цикла.\n\n- Другой подход заключается в использовании сочетания клавиш ctrl + c для принудительного завершения программы в некоторых случаях. Это отправит программе сигнал KeyboardInterrupt, который можно перехватить с помощью блока try/except, что позволит вам корректно выйти из программы.\n\n```python\ntry:\n    while True:\n        # some infinite loop\nexcept KeyboardInterrupt:\n    print('Program terminated by user')\n```\n\nЭто позволяет пользователю завершить программу с помощью Ctrl + C, а также обеспечивает изящный способ обработки этого события, не вызывая сбоя программы.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 220,
  "fields": {
    "question": "Как с помощью Python узнать, в каком каталоге вы сейчас находитесь?",
    "answer": "Можно использовать библиотеку os для того, чтобы узнать имя текущего рабочего каталога. Вот пример:\n\n```python\nimport os\n\ncurrent_directory = os.getcwd()\nprint(current_directory)\n```\n\nЭтот код выведет в консоль путь к текущему рабочему каталогу. Функция os.getcwd() возвращает строку, содержащую путь к текущему рабочему каталогу.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 221,
  "fields": {
    "question": "Как найти в строке первое слово, которое рифмуется со словом «торт»?",
    "answer": "Можно использовать регулярные выражения в Python.\n\nВот код, который позволит найти такое слово:\n\n```python\nimport re\n\nstr = \"Мэри любит розы, но не любит торты.\"\nmatches = re.findall(r'\\b(\\w*орт)\\b', str)\n\nif matches:\n    print(matches[0])\nelse:\n    print(\"Совпадений не найдено.\")\n```\n\nЭтот код найдет первое слово, которое содержит буквосочетание «орт» и имеет любое количество символов перед ним (могут быть буквы, цифры или символы подчеркивания). \\b указывает на границу слова.\n\nВ данном примере код выведет «торты», так как это единственное слово в строке, которое рифмуется со словом «торт».\n\nЕсли в строке нет слов, рифмующихся с «тортом», то на консоль будет выведено сообщение «Совпадений не найдено.».",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 222,
  "fields": {
    "question": "Как вычислить длину строки?",
    "answer": "Длину строки можно вычислить с помощью функции len(). Вот пример использования len() для вычисления длины строки:\n\n```python\ns = 'Привет, мир!'\nlength = len(s)\nprint(length) # выведет 13\n```\n\nЗдесь мы создаем строку 'Привет, мир!' и сохраняем ее в переменной s. Затем мы используем функцию len() для вычисления длины строки и сохраняем результат в переменную length. Наконец, мы выводим значение переменной length, которая содержит длину строки.\n\nДругой пример:\n\n```python\nword = 'hello'\nprint(len(word)) # выведет 5\n```\n\nЗдесь мы создаем строку 'hello', используем функцию len() для вычисления ее длины и выводим результат на экран.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 223,
  "fields": {
    "question": "Что выводит следующий код?",
    "answer": "```python\ndef extendList(val, list=[]):\n          list.append(val)\n          return list\n     list1 = extendList(10)\n     list2 = extendList(123,[])\n     list3 = extendList('a')\n     list1,list2,list3\n```\n\nКод определяет функцию extendList, которая принимает два аргумента: значение и список. Если список не указан в качестве аргумента, функция использует значение по умолчанию пустого списка. Функция добавляет значение в список и возвращает обновленный список.\n\nЗатем код трижды вызывает функцию extendList с разными аргументами. Первый вызов передает значение 10 и не имеет аргумента списка, поэтому функция использует пустой список по умолчанию.\n\nВторой вызов передает значение 123 и пустой список, поэтому функция добавляет 123 к пустому списку и возвращает его.\n\nТретий вызов передает значение 'a' и снова использует пустой список по умолчанию. Наконец, код присваивает возвращенные значения трем переменным list1, list2 и list3. Значения list1, list2 и list3:\n\n```python\nlist1: [10, 'a']\nlist2: [123]\nlist3: [10, 'a']\n```\n\nОбратите внимание, что неожиданный вывод связан с тем, что список по умолчанию используется совместно всеми вызовами функций, которые не предоставляют аргумент списка.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 224,
  "fields": {
    "question": "Что такое декоратор? Как определить свою?",
    "answer": "Декоратор - это функция, которая принимает другую функцию и расширяет её поведение без изменения её кода напрямую. Декораторы позволяют добавлять новое поведение функциям во время выполнения программы.\n\nДекораторы определяются с использованием символа @, за которым следует имя декоратора. Ниже приведен пример определения декоратора, который выводит время выполнения функции:\n\n```python\nimport time\n\ndef time_it(func):\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        end = time.time()\n        print(f\"{func.__name__} took {end - start} seconds to execute.\")\n        return result\n    return wrapper\n```\n\nЗдесь определяется функция декоратора time_it, которая принимает функцию на вход и возвращает новую функцию - обертку wrapper. wrapper заменяет оригинальную функцию и при каждом её вызове выводит время выполнения.\n\nЧтобы использовать данный декоратор в функции, нужно просто добавить символ @ и имя декоратора перед определением функции:\n\n```python\n@time_it\ndef some_function():\n    # исходный код функции\n```\n\nТеперь при вызове some_function() будет также выводиться время выполнения.\n\nТакже можно определить свой собственный декоратор, который реализует любое другое нужное поведение. Создание декоратора может показаться сложным на первый взгляд, но после понимания принципа работы можно сделать это довольно легко.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 225,
  "fields": {
    "question": "Зачем использовать декораторы функций? Приведите пример.",
    "answer": "Декораторы функций - это функции, которые принимают в качестве аргументов другие функции и расширяют или изменяют их поведение без изменения самих функций. Они могут использоваться для добавления функциональности к существующим функциям, например, кэширования результатов функции или логирования аргументов и результата функции.\n\nВот пример использования декоратора для логирования вызовов функции и её результата:\n\n```python\ndef logger(func):\n    def wrapper(*args, **kwargs):\n        result = func(*args, **kwargs)\n        print(f\"Called {func.__name__} with args={args} and kwargs={kwargs}. Result: {result}\")\n        return result\n    return wrapper\n\n@logger\ndef add(x, y):\n    return x + y\n\nadd(1, 2)\n# Output: Called add with args=(1, 2) and kwargs={}. Result: 3\n```\n\nВ этом примере мы объявляем функцию logger, которая принимает функцию в качестве аргумента и возвращает новую функцию-обертку wrapper, которая добавляет логирование вызовов и результата функции. Затем мы применяем декоратор @logger к функции add, чтобы добавить логирование к этой функции. При вызове функции add, будет выведена информация о вызове функции и её результата в консоль.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 226,
  "fields": {
    "question": "Сколько аргументов может принимать функция range()?",
    "answer": "Функция range() может принимать от одного до трех аргументов. В зависимости от количества переданных аргументов, range() может генерировать последовательность чисел от нуля до указанного числа с шагом 1 (если передан один аргумент), от указанного начального значения до указанного конечного значения с шагом 1 (если переданы два аргумента), либо от указанного начального значения до указанного конечного значения с указанным шагом (если переданы три аргумента).\n\nНапример:\n\n```python\n# генерирует последовательность от 0 до 9\nfor i in range(10):\n    print(i)\n\n# генерирует последовательность от 2 до 9\nfor i in range(2, 10):\n    print(i)\n\n# генерирует последовательность от 1 до 10 с шагом 2\nfor i in range(1, 11, 2):\n    print(i)\n\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 227,
  "fields": {
    "question": "Как вы отлаживаете программу на Python? Ответьте кратко.",
    "answer": "Основные шаги для начала отладки в Pycharm:\n\n- Добавьте точку останова в строку кода, с которой вы хотите начать отладку, щелкнув в левой части окна редактора.\n- Запустите программу в режиме отладки, нажав кнопку «Отладка» или используя сочетание клавиш «Shift+F9».\n- Выполнение программы остановится на линии точки останова, и появится окно Debug Tool.\n- Теперь вы можете использовать окно средства отладки для проверки состояния программы, пошагового выполнения кода построчно, вычисления выражений и изменения переменных по мере необходимости.\n- Чтобы продолжить выполнение программы с точки останова или остановить программу, используйте окно средства отладки или кнопки панели инструментов.\n\nОсновные шаги для начала отладки в pdb :\nПеред началом отладки в pdb вам нужно запустить вашу программу, используя опцию -m pdb. Например, если вы хотите запустить скрипт my_script.py, выполните следующую команду:\n\n```python\npython -m pdb my_script.py\n```\n\nКогда ваш скрипт запустится, вы увидите приглашение pdb в терминале. Вы можете использовать команды pdb для управления выполнением вашей программы. Некоторые из основных команд pdb:\n\n- n(ext) - выполнить следующую строку кода\n\n- s(tep) - выполнить текущую строку кода и остановиться на первой доступной возможности\n\n- c(ontinue) - продолжить выполнение вашей программы до следующей точки останова или до ее завершения\n\n- b(reak) - установить точку останова на указанной строке кода или в указанной функции\n\n- h(elp) - вывести список доступных команд pdb и их описание\n\n- q(uit) - выйти из pdb и завершить выполнение вашей программы\n\nВы можете использовать эти команды и другие команды pdb для управления выполнением вашей программы и поиска ошибок.\n\nНапример, если вы хотите установить точку останова на строке кода № 10, выполните следующую команду в pdb:\n\n```python\nb 10\n```\n\nЗатем вы можете продолжить выполнение программы и остановиться на этой точке останова, когда ваша программа достигнет этой строки:\n\n```python\nc\n```\n\nВы можете использовать команды n, s и c для продолжения выполнения вашей программы и поиска ошибок в вашем коде. Для получения полного списка команд pdb введите h.\n\nОтладка может быть мощным инструментом для диагностики проблем в вашем коде и понимания того, как работает ваша программа. Это позволяет вам в интерактивном режиме проходить код и проверять его состояние в разные моменты времени.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 228,
  "fields": {
    "question": "Перечислите некоторые команды pdb.",
    "answer": "pdb — это отладчик Python, предоставляющий ряд команд, помогающих отлаживать код. Вот некоторые часто используемые команды:\n\n- break или b: установить точку останова\n- continue или c: продолжить выполнение до следующей точки останова\n- step or s: шаг в код\n- next или n: пройтись по коду\n- return или r: продолжить выполнение, пока текущая функция не вернется\n- list или l: перечислить текущий код print или p: напечатать значение выражения\n- help или h: показать справочное сообщение\n\nВы можете получить доступ к полному списку команд, набрав h или help при использовании отладчика pdb. Кроме того, pdb имеет ряд параметров настройки, таких как псевдонимы и ловушки, которые позволяют использовать более сложные рабочие процессы отладки.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 229,
  "fields": {
    "question": "Какую команду мы используем для отладки программы Python?",
    "answer": "Для отладки программы на Python можно использовать команду pdb, которая является интерактивной отладочной консолью в Python. Есть несколько способов запустить pdb, но один из самых простых - это импортировать pdb и вызвать функцию set_trace(), как в следующем примере:\n\n```python\nimport pdb\n\ndef my_function(x, y):\n    z = x + y\n    pdb.set_trace()    # Останавливаем выполнение программы и запускаем отладочный интерфейс\n    z = z * 2\n    return z\n\nresult = my_function(3, 4)\nprint(result)\n```\n\nПосле запуска этого кода, выполнение программы остановится на строке с функцией set_trace(), и мы сможем использовать команды отладочной консоли для исследования и исправления ошибок. Например, мы можем подробно изучить значения переменных и выполнить шаги программы один за другим, используя команды print, pprint, step, next, continue и другие.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 230,
  "fields": {
    "question": "Что такое счетчик в Python?",
    "answer": "Счетчик — это подкласс словаря в Python, специально разработанный для подсчета хешируемых объектов. Это словарь, в котором объекты хранятся как ключи, а их вхождение подсчитывается как значения. Это полезно, когда вам нужно отслеживать частоту появления различных объектов. элементы в коллекции. Класс Counter предоставляет методы, позволяющие подсчитывать элементы в последовательностях, коллекциях и итерациях. Вот пример того, как использовать счетчик для подсчета элементов в списке:\n\n```python\nfrom collections import Counter\nlst = [1, 2, 3, 3, 2, 1, 2, 3, 4, 5, 4, 3, 2, 1]\nc = Counter(lst)\nprint(c)\n```\n\nЭто выведет:\n\n```python\nCounter({2: 4, 3: 4, 1: 3, 4: 2, 5: 1})\n```\n\nЭто означает, что число 2 встречается в списке 4 раза, число 3 встречается 4 раза, число 1 встречается 3 раза, число 4 встречается 2 раза и число 5 встречается в списке 1 раз.\n\nКласс Counter также предоставляет много других полезных методов, например, most_common(), который возвращает n наиболее распространенных элементов, и elements(), который возвращает итератор по элементам.\n\n# 216. Что такое NumPy? Это лучше, чем список?\n\nNumPy - это библиотека для языка программирования Python, которая позволяет работать с массивами и матрицами числовых данных с высокой эффективностью. Она предоставляет множество функций для операций над этими массивами и матрицами, в том числе математических операций, операций линейной алгебры, операций фурье-анализа и многое другое.\n\nВ ряде случаев использование NumPy массивов может быть более выгодным, чем использование списков. В частности, операции с массивами в NumPy выполняются гораздо быстрее, чем операции со списками в Python, благодаря тому, что данные хранятся в многомерных массивах в памяти в непрерывном блоке, что позволяет использовать оптимизированный код на языке C внутри NumPy. Кроме того, NumPy предоставляет более широкий набор функций для работы с массивами, чем встроенные средства Python.\n\nОднако, при работе с данными не в виде массивов, использование встроенных средств языка, таких как списки, могут быть более выгодно. В любом случае, это зависит от конкретной задачи и типа данных, с которыми вы работаете.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 231,
  "fields": {
    "question": "Как бы вы создали пустой массив NumPy?",
    "answer": "Для создания пустого массива NumPy можно использовать функцию numpy.empty() или numpy.zeros(). Например, чтобы создать пустой массив с 7 элементами типа float, можно сделать так:\n\n```python\nimport numpy as np\n\narr = np.empty(7, dtype=float)\n```\n\nили\n\n```python\narr = np.zeros(7, dtype=float)\n```\n\nОбе функции создают массив заданного размера и типа, но не инициализируют его значениями, поэтому значения элементов будут случайными или нулевыми. Для создания массива со значениями по умолчанию можно использовать numpy.full().",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 232,
  "fields": {
    "question": "Объясните использование ключевого слова «нелокальный» (nonlocal) в Python.",
    "answer": "Ключевое слово \"nonlocal\" используется для доступа к переменным, определенным в вызывающей функции из вложенной функции. Это позволяет изменять значения этих переменных из вложенной функции, что было бы невозможно с помощью ключевого слова \"local\". Например:\n\n```python\ndef outer():\n    x = 1\n    def inner():\n        nonlocal x\n        x = 2\n    inner()\n    print(x) # output: 2\n```\n\nВ этом примере, переменная x определена во внешней функции outer(). Затем мы определяем вложенную функцию inner(), которая изменяет значение x на 2 с помощью ключевого слова nonlocal. После того, как мы вызываем inner() из outer(), значение x становится равным 2 вместо 1.\n\nТакже как и при работе с ключевым словом \"global\", использование \"nonlocal\" следует осторожно использовать, поскольку это может привести к неожиданным побочным эффектам и усложнениям в коде.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 233,
  "fields": {
    "question": "Что такое глобальное ключевое слово?",
    "answer": "Глобальное ключевое слово - это \"global\". Оно используется для определения переменной в глобальной области видимости. Когда переменная определена в функции, она обязательно должна быть импортирована с использованием слова \"global\", чтобы функция могла обновлять значения переменной в глобальной области видимости.\nЭто ключевое слово используется внутри функции для того, чтобы указать на то, что переменная является глобальной, а не локальной. Если переменная определена внутри функции без использования global, то она будет считаться локальной, и изменения, сделанные внутри функции, не будут повлиять на глобальное значение переменной.\n\nНапример:\n\n```python\nx = 10\n\ndef foo():\n    global x\n    x = 20\n    print(x)\n\nfoo() # Выводит 20\nprint(x) # Также выводит 20, потому что x в глобальной области видимости было обновлено внутри функции\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 234,
  "fields": {
    "question": "Как бы вы сделали скрипт Python исполняемым в Unix?",
    "answer": "Для того, чтобы скрипт Python мог быть исполняемым в Unix, вы можете сделать следующее:\n\n- Добавьте шебанг в начало скрипта. Шебанг это специальная конструкция, которая указывает на интерпретатор, который должен быть использован для запуска скрипта. Шебанг состоит из символа решетки (#) и пути к интерпретатору. Для Python путь к интерпретатору обычно /usr/bin/env python. Вот пример шебанга:\n\n```python\n#!/usr/bin/env python\nprint(\"Hello, World!\")\n```\n\n- Сделайте файл исполняемым с помощью команды chmod. Вы можете использовать команду следующим образом:\n\n```bash\nchmod +x filename.py\n```\n\nгде filename.py - имя вашего файла скрипта.\n\n- После этих шагов вы можете запустить скрипт в терминале Unix, используя имя файла, например:\n\n```bash\n./filename.py\n```\n\nЭто позволит Unix использовать указанный в шебанге интерпретатор Python для запуска скрипта.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 235,
  "fields": {
    "question": "Какие функции или методы вы будете использовать для удаления файла в Python?",
    "answer": "- Можно использовать метод os.remove() из модуля os. Например, чтобы удалить файл с именем \"file.txt\", можно использовать следующий код:\n\n```python\nimport os\n\nos.remove(\"file.txt\")\n```\n\nТакже можно использовать метод os.unlink(), который делает то же самое. Разница между ними заключается только в том, что os.unlink() является синонимом для os.remove().\n\n- Если нужно удалить пустую директорию, можно использовать метод os.rmdir(). Однако, если директория содержит какие-либо файлы или другие директории, эта команда не будет работать. В таком случае нужно использовать метод shutil.rmtree(), который удаляет директорию вместе со всем ее содержимым. Например:\n\n```python\nimport shutil\n\nshutil.rmtree(\"my_directory\")\n```\n\nГде \"my_directory\" - это имя директории, которую нужно удалить. Обратите внимание, что эта команда удаляет всю директорию и ее содержимое, так что ее нужно использовать осторожно.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 236,
  "fields": {
    "question": "Что такое аксессоры, мутаторы и @property?",
    "answer": "Аксессоры и мутаторы (getter и setter) - это методы, которые используются для доступа и изменения значения свойства объекта в ООП. Аксессоры (getter) возвращают значение свойства, а мутаторы (setter) изменяют его значение.\n\nС помощью декоратора @property в Python можно создавать свойства класса, которые будут автоматически вызывать методы getter и setter при чтении и записи свойства. Пример:\n\n```python\nclass MyClass:\n    def __init__(self):\n        self._value = 0\n\n    @property\n    def value(self):\n        return self._value\n\n    @value.setter\n    def value(self, value):\n        if value < 0:\n            raise ValueError(\"value cannot be negative\")\n        self._value = value\n\n```\n\nВ данном примере value является свойством класса. Декоратор @property перед методом value говорит Python, что этот метод будет использоваться как getter, а @value.setter - что будет использоваться для изменения свойства.\n\nАксессоры и мутаторы особенно важны для защиты данных и сокрытия реализации объекта от пользователя. Через методы доступа можно контролировать процесс чтения и записи свойства и например, изменять значение свойства только при определенных условиях.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 237,
  "fields": {
    "question": "Различайте методы append() и extend() списка.",
    "answer": "Метод append() предназначен для добавления элемента в конец списка, в то время как метод extend() используется для добавления элементов из другого списка в конец текущего списка.\n\nНапример, если у нас есть список a с элементами [1, 2, 3] и список b с элементами [4, 5, 6], то использование метода append() для добавления списка b в список a приведет к созданию нового списка [1, 2, 3, [4, 5, 6]], в то время как использование метода extend() приведет к созданию нового списка [1, 2, 3, 4, 5, 6].\n\nВот пример использования обоих методов:\n\n```python\na = [1, 2, 3]\nb = [4, 5, 6]\n\na.append(b)\nprint(a) # выводит [1, 2, 3, [4, 5, 6]]\n\na = [1, 2, 3]\nb = [4, 5, 6]\n\na.extend(b)\nprint(a) # выводит [1, 2, 3, 4, 5, 6]\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 238,
  "fields": {
    "question": "Что вы подразумеваете под переопределяющими методами?",
    "answer": "Переопределение методов означает создание метода в дочернем классе с тем же именем, что и метод в родительском классе. Такой метод в дочернем классе переопределяет метод в родительском классе, то есть при вызове метода у объекта дочернего класса будет выполнен переопределенный метод, а не метод родительского класса.\n\nВот пример кода, демонстрирующий переопределение методов в Python:\n\n```python\nclass Animal:\n    def make_sound(self):\n        print(\"The animal makes a sound\")\n\nclass Dog(Animal):\n    def make_sound(self):\n        print(\"The dog barks\")\n\nanimal = Animal()\nanimal.make_sound()  # выводит \"The animal makes a sound\"\n\ndog = Dog()\ndog.make_sound()  # выводит \"The dog barks\"\n```\n\nВ этом примере класс Dog наследует от Animal и определяет метод make_sound(), который переопределяет метод с тем же именем в родительском классе Animal. При вызове метода make_sound() для объекта dog будет выполнен переопределенный метод, который выводит \"The dog barks\".",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 239,
  "fields": {
    "question": "Что такое JSON? Кратко опишите, как вы конвертируете данные JSON в данные Python?",
    "answer": "JSON (JavaScript Object Notation) - это формат обмена данными, основанный на языке JavaScript. Он часто используется для передачи данных между веб-сервером и веб-браузером, но может быть использован в любом другом контексте, где необходима передача структурированных данных.\n\nДля конвертации данных JSON в данные, можно использовать модуль json. Пример:\n\n```python\nimport json\n\n# JSON-строка\njson_string = '{\"name\": \"John Smith\", \"age\": 35, \"city\": \"New York\"}'\n\n# Конвертация JSON-строки в Python-объект\ndata = json.loads(json_string)\n\n# Вывод данных Python\nprint(data)\n```\n\nВывод:\n\n```python\n{'name': 'John Smith', 'age': 35, 'city': 'New York'}\n```\n\nОбратите внимание, что вы можете использовать метод json.dump() для записи Python объекта в файл в формате JSON.\n\n```python\n# Python-объект\ndata = {\n    \"name\": \"John Smith\",\n    \"age\": 35,\n    \"city\": \"New York\"\n}\n\n# Записываем данные в файл в формате JSON\nwith open('data.json', 'w') as f:\n    json.dump(data, f)\n```\n\nЭтот пример создаст файл data.json со следующим содержимым:\n\n```python\n{\"name\": \"John Smith\", \"age\": 35, \"city\": \"New York\"}\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 240,
  "fields": {
    "question": "Как вы выполняете скрипт Python?",
    "answer": "Чтобы запустить скрипт, можно выполнить команду python имя_файла.py в командной строке. Для этого вам нужно перейти в папку, где находится ваш файл Python, используя команду cd. Например, если ваш файл Python называется main.py и находится в папке C:\\Python, то вы можете выполнить следующие команды в командной строке:\n\n```bash\ncd C:\\Python\npython main.py\n```\n\nЕсли вы используете IDE, такую как PyCharm или VS Code, вы можете просто открыть файл в IDE и запустить его внутри среды разработки. Это может быть более удобным, особенно когда нужно отлаживать код.\n\nВам может потребоваться установить все необходимые зависимости и библиотеки перед запуском программы, используя менеджер пакетов, такой как pip.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 241,
  "fields": {
    "question": "Объясните использование try: except: raise, and finally.",
    "answer": "try, exclude и finally используются вместе как механизмы обработки ошибок. Блок try используется для включения некоторого кода, который потенциально может вызвать ошибку. Если в блоке try возникает ошибка, выполняется код в соответствующем блоке exclude. Блок finally выполняется независимо от того, была выброшена ошибка или нет. В контексте try:except:raise это обычно используется для перехвата ошибки, а затем ее повторного инициирования, чтобы ее мог перехватить обработчик исключений более высокого уровня. Например:\n\n```python\ntry:\n  # некоторый код, который может вызвать исключение\nexcept SomeException as e:\n  # обрабатывать исключение\n  raise e\nfinally:\n  # код для выполнения независимо от того, было ли выброшено исключение\n\n```\n\nВ этом примере, если код в блоке try выдает исключение SomeException, код в блоке exclude его поймает. Оператор повышения e повторно вызовет исключение, чтобы оно могло быть перехвачено обработчиком исключений более высокого уровня. Блок finally будет выполнен независимо от того, было ли выброшено исключение или нет. В целом, try, exclude и finally используются вместе для обеспечения надежной обработки ошибок в программах на Python.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 242,
  "fields": {
    "question": "Проиллюстрируйте правильное использование обработки ошибок Python.",
    "answer": "Обработка ошибок в Python осуществляется с помощью конструкции try-except. Эта конструкция позволяет обработать исключение, которое может возникнуть в блоке кода, попытавшись выполнить определенную операцию.\n\nВот пример кода, демонстрирующий использование try-except для обработки исключений:\n\n```python\ntry:\n    # блок кода, в котором может возникнуть исключение\n    result = 10 / 0\nexcept ZeroDivisionError:\n    # блок кода, который будет выполнен, если возникнет исключение ZeroDivisionError\n    print(\"Деление на ноль невозможно\")\n```\n\nВ этом примере, попытка выполнить операцию 10 / 0 приведет к возникновению исключения ZeroDivisionError. Однако, благодаря использованию try-except, мы можем перехватить это исключение и выполнить соответствующую операцию в блоке except.\n\nКроме того, можно использовать несколько блоков except для обработки разных типов исключений. Также можно добавить блок finally, который будет выполнен всегда вне зависимости от того, возникло исключение или нет.\n\n```python\ntry:\n    # блок кода, в котором может возникнуть исключение\n    result = int(\"abc\")\nexcept ValueError:\n    # блок кода, который будет выполнен, если возникнет исключение ValueError\n    print(\"Не удалось преобразовать строку в число\")\nexcept:\n    # блок кода, который будет выполнен, если возникнет какое-то другое исключение\n    print(\"Произошло какое-то исключение\")\nfinally:\n    # блок кода, который будет выполнен всегда\n    print(\"Конец программы\")\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 243,
  "fields": {
    "question": "Что такое пространство имен в Python?",
    "answer": "Пространство имен - это механизм, позволяющий именам переменных, функций и классов быть уникальными и не конфликтовать между собой.\n\nПространство имен можно представить как словарь, где ключами являются имена переменных и функций, а значениями - объекты, на которые эти имена ссылаются. В Python существует несколько пространств имен, каждое со своими правилами области видимости и временем жизни:\n\n- Встроенное пространство имен содержит встроенные функции и константы Python, такие как print() и True.\n\n- Глобальное пространство имен содержит имена, определенные на верхнем уровне модуля. Имена в глобальном пространстве имен могут быть использованы из любой функции в модуле.\n\n- Локальное пространство имен связано с каждой функцией, и содержит все имена, определенные в этой функции. Локальные имена могут быть использованы только в пределах функции, в которой они определены.\n\nКроме того, существует встроенная функция globals(), которая возвращает словарь, содержащий все имена в глобальном пространстве имен, и функция locals(), которая возвращает словарь, содержащий все имена в локальном пространстве имен.\n\nПонимание механизма пространства имен очень важно для понимания языка Python в целом, а также для решения конфликтов имён и написания чистого, понятного кода.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 244,
  "fields": {
    "question": "Объясните разницу между локальными и глобальными пространствами имен.",
    "answer": "В Python каждая функция и модуль имеет своё пространство имён, которое определяет область видимости для переменных.\n\nГлобальное пространство имён относится к переменным, определенным на верхнем уровне модуля. То есть, это переменные, которые видны в любом месте модуля. Локальные переменные создаются внутри функции или метода и видны только внутри этой функции или метода.\n\nПеременные, определенные в глобальном пространстве имён, могут быть использованы внутри любой функции в этом модуле. Однако, если переменная определена как глобальная внутри функции, её можно изменить из этой функции, и эти изменения будут видны во всём модуле.\n\nНапример, рассмотрим следующий пример:\n\n```python\nx = 10\n\ndef foo():\n    print(x)\n\nfoo()\n```\n\nЗдесь переменная x определена на верхнем уровне модуля, и поэтому она доступна внутри функции foo(). В результате, при вызове функции foo(), программа выведет на экран число 10.\n\nТеперь рассмотрим такой код:\n\n```python\ndef foo():\n    y = 20\n    print(y)\n\nfoo()\n```\n\nЗдесь переменная y определена внутри функции foo(), и поэтому она доступна только внутри этой функции. Попытка использовать эту переменную вне функции приведёт к ошибке.\n\n# 231. Назовите четыре основных типа пространств имен в Python?\n\nЧетыре основных типа пространств имен в Python:\n\n- Встроенное пространство имен - содержит имена встроенных функций и объектов, таких как print(), len(), и т.д.\n\n- Глобальное пространство имен - содержит имена, определенные на уровне модуля. Их можно использовать во всех функциях в модуле.\n\n- Локальное пространство имен - содержит имена, которые определены в текущей функции. Они доступны только внутри этой функции и не имеют отношения к другим функциям в модуле.\n\n- Найменованные пространства имен (namespace) - это объекты, которые содержат имена и служат для того, чтобы предоставить отдельное пространство имен для различных контекстов, таких как классы или функции.\n\nПример создания и использования найменованного пространства имен (namespace):\n\n```python\n# Create a new namespace using the dict() function\nmy_namespace = dict()\n\n# Add some variables to the namespace\nmy_namespace['x'] = 42\nmy_namespace['str'] = 'Hello, World!'\n\n# Access the variables in the namespace\nprint(my_namespace['x']) # Output: 42\nprint(my_namespace['str']) # Output: 'Hello, World!'\n```\n\nКроме того, модули также предоставляют своё пространство имен, в котором определены функции, классы и переменные, которые можно использовать в других модулях, импортировав их.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 245,
  "fields": {
    "question": "Когда бы вы использовали тройные кавычки в качестве разделителя?",
    "answer": "Тройные кавычки в Python используются в качестве разделителя для многострочных строк или для строк, которые содержат кавычки внутри себя.\n\nВместо того, чтобы использовать экранирование кавычек внутри строки, можно использовать тройные кавычки, чтобы Python мог понять, что строка продолжается на следующей строке и какие кавычки должны рассматриваться как часть строки.\n\nНапример:\n\n```python\nmy_string = \"\"\"This is a multiline\nstring that spans across\nmultiple lines and contains \"quotes\".\"\"\"\n```\n\nили\n\n```python\nmy_string = '''This is a multiline\nstring that spans across\nmultiple lines and contains \"quotes\".'''\n```\n\nОбратите внимание, что тройные одинарные и двойные кавычки идентичны по своей функциональности, вы можете использовать любые из них в зависимости от вашего предпочтения или требований стиля кода.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 246,
  "fields": {
    "question": "Как работает схема нумерации версий Python?",
    "answer": "Python использует семантическое версионирование, так что каждый номер версии имеет свой набор значений, которые имеют определенную интерпретацию.\n\nНомер версии Python состоит из трех чисел, разделенных точкой: MAJOR.MINOR.PATCH. Первое число отвечает за основные изменения, которые могут привести к несовместимости с предыдущими версиями. Второе число обозначает новые возможности, но не приводит к несовместимости с предыдущими версиями, и третье число представляет исправления ошибок.\n\nНапример, версия 3.9.1 означает, что это основная версия 3, минорная версия 9, и патч-версия 1, то есть это небольшое исправление в версии 3.9.\n\nОбновление первого или второго номера версии Python может привести к несовместимости с предыдущими версиями и возможно потребуется изменить код. Однако, изменение третьего номера версии в целом не приводит к несовместимости и редко требует внесения изменений.\n\nВ Python также используется буквенные обозначения версий, такие как alpha, beta, и release candidate (RC), чтобы помечать нестабильные версии до выпуска окончательной стабильной версии.\n\nНапример, версия 3.10.0rc1 означает, что это кандидат на выпуск окончательной версии 3.10.0.\n\nЭта схема нумерации версий применяется не только в Python, но и во многих других проектах.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 247,
  "fields": {
    "question": "Где находится исходный файл math.py (socket.py, regex.py и т. д.)?",
    "answer": "Расположение файла math.py (или другого модуля Python) будет зависеть от вашей операционной системы и от того, как Python был установлен на вашем компьютере.\n\nОдин из способов найти расположение модуля Python — использовать команду locate в терминале или командной строке. Например, чтобы найти модуль math.py, вы можете запустить эту команду на машине с Linux:\n\n```bash\nlocate math.py\n```\n\nВ Windows вы можете использовать команду dir для поиска файла, например:\n\n```bash\ndir /s /b math.py\n```\n\nВ качестве альтернативы, если вы знаете имя модуля, который хотите использовать в своем коде Python, вы можете просто импортировать его в свой скрипт следующим образом:\n\n```bash\nimport math\n```\n\nИ Python автоматически найдет и использует модуль из своих установленных библиотек.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 248,
  "fields": {
    "question": "Почему не работают мои обработчики сигналов?",
    "answer": "Проблема с обработчиками сигналов может вызываться из-за различных причин, таких как неправильное создание обработчика сигнала или некорректное использование функций при работе с сигналами. Один из распространенных случаев, когда сигналы не будут обрабатываться, - это когда используются функции ввода-вывода, которые блокируют процесс, например input() или print(). В таком случае, чтобы избежать блокировки, следует использовать асинхронный ввод-вывод или многопоточность.\n\nДля корректной обработки сигналов в Python можно использовать библиотеку signal. Вот пример кода, который позволяет обрабатывать сигнал SIGINT (который вызывается при нажатии на клавишу Ctrl+C) для корректного завершения программы:\n\n```python\nimport signal\nimport sys\n\ndef signal_handler(sig, frame):\n    print('Вы нажали Ctrl+C!')\n    sys.exit(0)\n\nsignal.signal(signal.SIGINT, signal_handler)\nprint('Нажмите Ctrl+C')\nsignal.pause()\n```\n\nВ этом примере мы устанавливаем обработчик сигнала SIGINT, который вызывается при нажатии на клавиши Ctrl+C. Обработчик выводит сообщение о том, что была нажата клавиша, а затем вызывает sys.exit(0) для корректного завершения программы. signal.pause() останавливает процесс, ожидая произвольный сигнал, чтобы избежать завершения программы.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 249,
  "fields": {
    "question": "Как отправить почту из скрипта Python?",
    "answer": "Для отправки электронной почты из скрипта Python можно использовать библиотеку smtplib. Вот простейший пример кода, отправляющий email с текстом:\n\n```python\nimport smtplib\n\nsender_email = \"your_email@example.com\"\nreceiver_email = \"recipient_email@example.com\"\nmessage = \"Привет от Питона!\"\n\nsmtp_server = smtplib.SMTP(\"smtp.gmail.com\", 587)\nsmtp_server.starttls()\nsmtp_server.login(sender_email, \"your_password\")\nsmtp_server.sendmail(sender_email, receiver_email, message)\nsmtp_server.quit()\n```\n\nЗамените \"your_email@example.com\" на свой электронный адрес отправителя, \"recipient_email@example.com\" на адрес получателя и \"your_password\" на пароль для входа в вашу учетную запись электронной почты. Также вы можете изменить содержимое переменной message. Обратите внимание, что для отправки почты через Gmail придется разрешить отправку писем из ненадежных приложений в настройках вашей учетной записи Google.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 250,
  "fields": {
    "question": "Что такое реализация в программе Python?",
    "answer": "Реализация (implementation) в программировании - это конкретный набор инструкций и компиляторов (или интерпретаторов), который преобразует код на языке программирования в машинный код, который может выполняться на компьютере.\n\nДля языка Python существует несколько реализаций, каждая из которых имеет свои особенности и преимущества. Одна из наиболее распространенных реализаций - это стандартная реализация CPython, которая разработана на языке C и доступна на большинстве платформ, поддерживаемых Python. Другие реализации включают Jython, IronPython, PyPy и другие. Каждая из этих реализаций имеет свои преимущества и недостатки, и может быть выбрана в зависимости от конкретных потребностей и требований проекта.\n\nОднако, независимо от реализации, Python остается языком программирования с динамической типизацией, высоким уровнем абстракции и широким набором библиотек и инструментов для разработки программного обеспечения.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 251,
  "fields": {
    "question": "Объясните операторы потока управления.",
    "answer": "Операторы потока управления в Python используются для изменения последовательности выполнения программы в зависимости от определенных условий. Самым основным оператором потока управления является if - else, который позволяет выполнить определенный блок кода, если выражение истинно (True), и другой блок, если выражение ложно (False). Вот простой пример использования if - else оператора в Python:\n\n```python\nx = 5\nif x > 10:\n    print(\"x больше 10\")\nelse:\n    print(\"x меньше или равен 10\")\n```\n\nЕще одним важным оператором потока управления является оператор цикла for, который позволяет перебирать элементы внутри итерируемого объекта, такого как список, кортеж или строка, и выполнять некоторый блок кода для каждого элемента. Пример использования for оператора в Python:\n\n```python\nfruits = [\"яблоко\", \"банан\", \"вишня\"]\nfor fruit in fruits:\n    print(fruit)\n```\n\nТакже в Python присутствует оператор цикла while, который позволяет выполнять некоторый блок кода до тех пор, пока определенное логическое условие истинно. Пример использования while оператора в Python:\n\n```python\ni = 1\nwhile i <= 5:\n    print(i)\n    i += 1\n```\n\nБлок кода внутри операторов потока управления может содержать любые допустимые выражения и инструкции в Python, такие как другие операторы потока управления, циклы, функции и т.п.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 252,
  "fields": {
    "question": "Каковы два основных оператора цикла?",
    "answer": "В Python есть два основных оператора цикла:\n\nfor - используется для итерации по последовательности, такой как список или строка. Пример использования:\n\n```python\nfor i in range(10):\n    print(i)\n```\n\nЭто выведет числа от 0 до 9.\n\nwhile - используется для повторения блока кода, пока заданное условие истинно. Пример использования:\n\n```python\ni = 0\nwhile i < 10:\n    print(i)\n    i += 1\n```\n\nЭто выведет числа от 0 до 9.\n\nОба оператора цикла могут использоваться вместе с операторами break и continue для более тонкой настройки поведения цикла.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 253,
  "fields": {
    "question": "При каких обстоятельствах можно использовать оператор while, а не for?",
    "answer": "Оператор for используется для прохождения по итерируемому объекту, такому как список, кортеж или строка. Он выполняется для каждого элемента в итерируемом объекте и автоматически увеличивает счетчик на каждой итерации цикла.\n\nОператор while используется для выполнения цикла до тех пор, пока логическое выражение, указанное после оператора while, остается истинным. В противном случае, если логическое выражение ложно, выполнение цикла завершается.\n\nОператор while может быть полезен в следующих случаях:\n\n- когда необходимо повторять блок кода до тех пор, пока не будет выполнено определенное условие, которое может быть проверено только внутри цикла;\n\n- когда необходимо повторять блок кода до тех пор, пока пользователь не введет корректное значение;\n\n- когда необходимо выполнить блок кода неопределенное количество раз, но известно условие выхода из цикла.\n\nТаким образом, использование оператора while или for зависит от задачи, которую вы пытаетесь решить.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 254,
  "fields": {
    "question": "Что произойдет, если вывести оператор else после блока after?",
    "answer": "",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 255,
  "fields": {
    "question": "Объясните использование операторов break и continue в циклах Python.",
    "answer": "break и continue являются операторами управления потоком выполнения программы в циклах.\n\nОператор break используется для немедленного прерывания выполнения цикла, даже если условие цикла еще не истекло. Вот простой пример:\n\n```python\nfor i in range(5):\n    if i == 3:\n        break\n    print(i)\n\n# вывод: 0 1 2\n```\n\nЗдесь, когда переменная i становится равной 3, оператор break прерывает выполнение цикла, и программа переходит к следующим инструкциям.\n\nОператор continue используется для перехода к следующей итерации цикла без выполнения кода, который следует за оператором continue. Вот пример:\n\n```python\nfor i in range(5):\n    if i == 2:\n        continue\n    print(i)\n\n# вывод: 0 1 3 4\n```\n\nЗдесь, когда переменная i становится равной 2, оператор continue переходит к следующей итерации цикла, пропуская код, который следует за оператором continue.\n\nКак правило, break и continue используются внутри условных выражений в циклах, чтобы управлять их выполнением.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 256,
  "fields": {
    "question": "Когда бы вы использовали оператор continue в цикле for?",
    "answer": "Можно использовать оператор continue в цикле for, когда хотите пропустить текущую итерацию цикла и перейти к следующей. Это может быть полезно, когда вы хотите выполнить какой-то блок кода только для определенных значений итерации цикла, а для других значений - пропустить этот блок. Вот простой пример:\n\n```python\nfor i in range(10):\n    if i < 5:\n        continue  # пропустить обработку чисел от 0 до 4\n    print(i)  # вывести числа от 5 до 9\n```\n\nВ этом примере, если i меньше 5, оператор continue пропустит итерацию цикла, и программа перейдет к следующей итерации. Если i больше или равно 5, программа выполнит блок кода после оператора if, и затем выведет значение i с помощью print().",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 257,
  "fields": {
    "question": "Когда бы вы использовали оператор break в цикле for?",
    "answer": "Оператор break используется в циклах for для преждевременного прерывания выполнения цикла. Обычно он используется в тех случаях, когда необходимо прервать выполнение цикла, когда определенное условие выполнено.\n\nВот несколько примеров ситуаций, в которых можно использовать оператор break в цикле for:\n\n- Когда бы вы хотели прервать выполнение цикла после первого нахождения нужного элемента в списке:\n\n```python\nfruits = ['apple', 'banana', 'mango', 'orange', 'pear']\n\nfor fruit in fruits:\n    if fruit == 'orange':\n        print('Found the orange!')\n        break\n```\n\n- Когда бы вы хотели прервать выполнение цикла после первого нахождения нужного элемента в строке:\n\n```python\nfor letter in 'Hello, world!':\n    if letter == 'o':\n        print('Found the first \"o\"!')\n        break\n```\n\n- Когда бы вы хотели прервать выполнение цикла, если какое-то условие выполнилось:\n\n```python\nfor i in range(10):\n    if i == 5:\n        print('Breaking the loop!')\n        break\n    print(i)\n```\n\nВ общем, оператор break в цикле for используется для преждевременного выхода из цикла, когда достигнуто определенное условие.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 258,
  "fields": {
    "question": "Какова структура цикла for?",
    "answer": "В Python структура цикла for имеет следующий вид:\n\n```python\nfor variable in sequence:\n    # блок кода\n```\n\nЗдесь переменная variable получает значение каждого элемента из последовательности sequence на каждой итерации цикла. Блок кода, который должен быть выполнен на каждой итерации, должен быть сдвинут вправо от строки с for. Пример:\n\n```python\nfor i in range(1, 5):\n    print(i)\n```\n\nВ этом примере range(1, 5) создает последовательность из четырех чисел: 1, 2, 3 и 4. На каждой итерации переменная i принимает значение текущего числа из последовательности и выводит его на экран. Результат:\n\n```bash\n1\n2\n3\n4\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 259,
  "fields": {
    "question": "Какова структура цикла while?",
    "answer": "Пример структуры цикла while на языке Python:\n\n```python\nwhile условие:\n    # код, который нужно выполнить, пока условие истинно\n```\n\nЦикл while продолжает выполняться, пока выражение условие истинно. Каждый раз, когда цикл достигает конца блока кода, он возвращается к началу и проверяет условие еще раз. Если условие все еще истинно, цикл продолжает выполняться, и это происходит до тех пор, пока условие не станет ложным.\n\nНапример, такой цикл печатает числа от 1 до 5:\n\n```python\ni = 1\nwhile i <= 5:\n    print(i)\n    i += 1\n```\n\nЭтот код будет выводить следующее:\n\n```bash\n1\n2\n3\n4\n5\n```\n\nВ зависимости от того, как сформулировано условие, цикл while может работать бесконечно, если условие не изменится на ложное. Поэтому необходимо быть внимательным при использовании циклов while и убедиться, что условие рано или поздно станет ложным.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 260,
  "fields": {
    "question": "Используйте цикл for и проиллюстрируйте, как вы определяете и печатаете символы в строке, по одному на строку.",
    "answer": "```python\nmy_string = \"Hello, World!\"\nfor char in my_string:\n    print(char)\n```\n\nЭто выведет:\n\n```\nH\ne\nl\nl\no\n,\n\nW\no\nr\nl\nd\n!\n\n```\n\nВ этом примере мы определяем строковую переменную my_string. Затем мы используем цикл for для перебора каждого символа в строке. Во время каждой итерации текущий символ присваивается переменной с именем char. Затем мы распечатываем значение char, которое будет одним символом из строки.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 261,
  "fields": {
    "question": "Для строки «I LoveQPython» используйте цикл for и проиллюстрируйте вывод каждого символа, но не включая Q.",
    "answer": "Чтобы напечатать каждый символ в строке «I LoveQPython», используя цикл for в Python, но не включая букву «Q», вы можете использовать следующий код:\n\n```python\nmy_string = \"I LoveQPython\"\n\nfor char in my_string:\n  if char != \"Q\":\n    print(char)\n```\n\nЭто будет перебирать каждый символ в строке и печатать его, только если он не равен «Q». Вывод будет:\n\n```bash\nI\nspace\nL\no\nv\ne\nP\ny\nt\nh\no\nn\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 262,
  "fields": {
    "question": "Имея строку «Я люблю Python», выведите все символы, кроме пробелов, используя цикл for.",
    "answer": "Вот как можно вывести все символы в строке 'Я люблю Python', кроме пробелов, используя цикл for в Python:\n\n```python\ns = 'Я люблю Python'\nfor c in s:\n    if c != ' ':\n        print(c) # ЯлюблюPython\n```\n\nЭтот код сначала создает строку s, затем проходит по каждому символу в строке с помощью цикла for. Если символ не равен пробелу, то он выводится в консоль с помощью функции print(). Таким образом, все символы, кроме пробелов, из строки 'Я люблю Python' будут напечатаны в консоли в результатах выполнения кода.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 263,
  "fields": {
    "question": "Что такое кортеж?",
    "answer": "Кортеж (tuple) - это неизменяемая упорядоченная последовательность элементов произвольных типов, разделенных запятыми и заключенных в круглые скобки. Основное отличие кортежа от списка заключается в его неизменяемости - элементы кортежа нельзя изменить после создания кортежа. Кортежи могут содержать элементы любых типов данных, в том числе другие кортежи.\n\nКортежи часто используются как ключи в словарях и в качестве элементов множества из-за своей неизменяемости. Также, используя синтаксис распаковывания, можно легко присваивать значения элементам кортежа. Например:\n\n```python\nt = (1, 2, 3)\na, b, c = t\nprint(a)  # 1\nprint(b)  # 2\nprint(c)  # 3\n```\n\nКортежи могут быть использованы вместо списков в тех случаях, когда необходима неизменяемость элементов последовательности.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 264,
  "fields": {
    "question": "Что такое Словарь?",
    "answer": "Словарь (Dictionary) в Python - это коллекция элементов, которые хранятся в структуре типа ключ-значение, где каждый элемент является парой ключ-значение. В словаре ключи уникальны и неизменяемы, а значения могут быть изменяемыми или неизменяемыми, и их можно получить по ключу. Словари создаются с помощью фигурных скобок {} или функции dict(), в которых указываются ключи и их соответствующие значения, разделенные двоеточием. Например:\n\n```python\nmy_dict = {'key1': 'value1', 'key2': 'value2'}\n```\n\nВ случае необходимости, значения в словаре могут быть изменены. Ключи, с другой стороны, не могут быть изменены и должны быть уникальными. Вы можете получить доступ к значениям в словаре, используя ключи, как показано в примере ниже:\n\n```python\nmy_dict = {'key1': 'value1', 'key2': 'value2'}\nprint(my_dict['key1'])\n```\n\nЭто выведет значение 'value1'. Если ключ не найден в словаре, будет вызвано исключение KeyError. Для проверки наличия ключа в словаре можно использовать оператор in. Например:\n\n```python\nmy_dict = {'key1': 'value1', 'key2': 'value2'}\nif 'key1' in my_dict:\n    print('Key found!')\nelse:\n    print('Key not found.')\n```\n\nЭто выведет \"Key found!\".",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 265,
  "fields": {
    "question": "Как искать путь к модулям?",
    "answer": "Найти путь к модулям с помощью переменной sys.path. Это список строк, содержащих пути поиска для модулей.\n\nВы можете добавить новый путь в список, используя метод sys.path.append().\n\nНапример, чтобы добавить путь \"C:\\myfolder\" в список, вы можете использовать следующий код:\n\n```python\nimport sys\nsys.path.append(\"C:\\myfolder\")\n```\n\nПосле этого вы можете импортировать модуль из этой директории, используя стандартный синтаксис import module_name. Если модуль находится в поддиректории, то следует добавить эту поддиректорию в sys.path, а затем использовать точечный синтаксис импорта, например:\n\n```python\nimport sys\nsys.path.append(\"C:\\myfolder\\subdirectory\")\nimport mymodule\n```\n\nЭтот код импортирует модуль mymodule, который находится в поддиректории \"subdirectory\" директории \"C:\\myfolder\".\n\nНо следует обрабатывать это с осторожностью, чтобы избежать случайного импортирования нежелательного кода.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 266,
  "fields": {
    "question": "Что такое пакеты?",
    "answer": "Пакеты - это просто специальные подпапки в модульной системе Python. Их цель - структурировать большие проекты и упростить их использование. Пакеты могут содержать другие модули и пакеты, и могут быть относительными или абсолютными.\n\nАбсолютный импорт - это когда вы импортируете модуль или пакет с использованием полного имени пути (например, import mypackage.mymodule). Относительный импорт - это когда вы импортируете модуль или пакет с использованием относительного пути из текущего модуля (например, from . import mymodule).\n\nЧтобы создать пакет в Python, просто создайте новую директорию, и в этой директории создайте файл с именем **init**.py. Этот файл будет запускаться при импорте пакета, и вам стоит использовать его для инициализации и экспорта объектов из пакета.\n\nНапример, если у вас есть пакет mypackage, который содержит модуль mymodule, вам нужно создать такую директорию и файл в вашем проекте:\n\n```python\nmypackage/\n    __init__.py\n    mymodule.py\n```\n\nВ **init**.py вы можете экспортировать объекты из mymodule:\n\n```python\nfrom .mymodule import MyClass\n```\n\nТеперь вы можете использовать MyClass в коде, импортировав его с помощью import mypackage или from mypackage import MyClass.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 267,
  "fields": {
    "question": "Что такое обработка файлов?",
    "answer": "Обработка файлов в Python - это процесс чтения, записи и манипулирования файлами на диске. Python предоставляет встроенные функции и модули для работы с файлами.\n\nЧтение файла в Python можно осуществить с помощью функции open(), которая возвращает объект файла. Например, чтобы прочитать содержимое файла data.txt и вывести его на экран, можно использовать следующий код:\n\n```python\nwith open('data.txt', 'r') as file:\n    data = file.read()\n    print(data)\n```\n\nАргумент 'r' указывает на режим чтения (read), и позволяет читать файл, который уже существует. Аргумент 'w' означает режим записи (write) и позволяет записывать данные в файл.\n\nPython также предоставляет различные модули для обработки различных типов файлов, таких как CSV, JSON и XML. Например, для чтения CSV-файла можно использовать модуль csv:\n\n```python\nimport csv\nwith open('data.csv', 'r') as file:\n    reader = csv.reader(file)\n    for row in reader:\n        print(row)\n```\n\nЭто пример, который читает CSV-файл data.csv и выводит его содержимое построчно на экран.\n\nТакже можно использовать сторонние библиотеки, такие как Pandas, для работы с файлами и обработки данных.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 268,
  "fields": {
    "question": "Что такое ошибки времени выполнения (Runtime Errors)?",
    "answer": "Ошибки времени выполнения в Python (и в программировании в целом) — это ошибки, возникающие во время выполнения программы. Эти ошибки обычно вызваны непредвиденным или неправильным поведением логики программы, например попыткой деления на ноль, доступом к индексу за пределами массива или списка или попыткой использовать объект не так, как он предназначен. В Python ошибки времени выполнения часто вызываются как исключения.\n\nОшибки выполнения могут возникать из-за:\n\n    Неверный Ввод\n    Неверная логика\n    Проблемы с памятью\n    Аппаратные сбои и так далее\n\nДля каждой причины, которая вызывает ошибку времени выполнения, доступен соответствующий класс представления ошибки времени выполнения.\nКлассы представления ошибок во время выполнения технически мы называем классами исключений.\n\nПри выполнении программы, если возникает какая-либо ошибка времени выполнения, создается соответствующий объект класса представления ошибок времени выполнения.\nСоздание объекта класса представления ошибок во время выполнения технически известно как возникающее исключение.\n\nПри выполнении программы, если возникает какое-либо исключение, внутренний интерпретатор Python проверяет, реализован ли какой-либо код для обработки возникшего исключения или нет.\nЕ\nсли код не реализован для обработки возникшего исключения, программа будет аварийно завершена.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 269,
  "fields": {
    "question": "Что такое аномальное завершение?",
    "answer": "«Аномальное завершение» относится к ситуации, когда программа Python завершается неожиданно или аварийно, не завершая свое выполнение. Обычно это вызвано какой-либо ошибкой, например синтаксической ошибкой, ошибкой времени выполнения или необработанным исключением. Когда программа Python аварийно завершается, она обычно отображает сообщение об ошибке, в котором содержится информация о причине ошибки.\n\nВажно правильно обрабатывать ошибки в ваших программах Python, чтобы предотвратить аварийное завершение и обеспечить бесперебойную работу вашей программы. Вы можете обрабатывать ошибки с помощью блоков try-except или try-finally или с помощью модуля ведения журнала для регистрации сообщений об ошибках.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 270,
  "fields": {
    "question": "Что такое try Block?",
    "answer": "В Python конструкция try/except используется для обработки исключений. Блок try содержит код, который может вызвать исключение при выполнении, а блок except содержит код, который выполняется в случае возникновения исключения. Пример использования:\n\n```python\ntry:\n    # code that may raise an exception\nexcept ExceptionType:\n    # how to handle the exception\n```\n\nЗдесь ExceptionType - это конкретный тип исключения, которое мы хотим обработать. Если тип не указан, то блок except будет обрабатывать любые исключения. Также можно использовать несколько блоков except для обработки разных типов исключений.\n\nБлок try может содержать несколько инструкций или даже вложенных блоков try/except. Если исключение не обработано во внутреннем блоке try/except, оно переходит в следующий внешний блок try/except.\n\nКроме блоков try/except, также может использоваться блок finally, который содержит код, который будет выполняться всегда, независимо от того, было или нет исключение в блоке try.\n\nПример использования блоков try/except/finally:\n\n```python\ntry:\n    # code that may raise an exception\nexcept ExceptionType:\n    # how to handle the exception\nfinally:\n    # code that always runs, whether or not an exception was raised\n```\n\nНапример, если мы хотим прочитать данные из файла data.txt, то мы можем использовать конструкцию try/except следующим образом:\n\n```python\ntry:\n    with open('data.txt', 'r') as f:\n        data = f.read()\nexcept FileNotFoundError:\n    print('File not found')\n```\n\nЗдесь мы пытаемся открыть файл data.txt для чтения. Если файл не найден, то возникает исключение FileNotFoundError, которое",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 271,
  "fields": {
    "question": "В чем разница между методами и конструкторами?",
    "answer": "В Python конструктор - это метод, который вызывается при создании экземпляра (инстанцировании) класса. Он имеет имя **init** и может принимать параметры. Конструктор используется для инициализации объекта, задания начальных значений атрибутов объекта, и выполнения других операций, необходимых при создании объекта.\n\nМетоды, с другой стороны, являются функциями, которые могут выполнять определенные операции с объектом, изменять его состояние или возвращать результат. Они определяются внутри класса и могут вызываться на экземпляре объекта этого класса.\n\nТаким образом, разница между конструкторами и методами заключается в том, что конструктор вызывается при создании экземпляра класса и используется для инициализации объекта, а методы вызываются на экземпляре класса и могут выполнять операции с объектом или возвращать результат.\n\nПример класса с конструктором и методом:\n\n```python\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def introduce(self):\n        print(f\"My name is {self.name} and I am {self.age} years old.\")\n\n# Создать экземпляр класса Person и вызвать метод introduce()\nperson = Person(\"Alice\", 25)\nperson.introduce()\n```\n\nЭтот код создаст экземпляр класса Person с именем Alice и возрастом 25, а затем вызовет метод introduce(), который напечатает строку \"My name is Alice and I am 25 years old.\"\n\nМетоды:\n\n- Имя метода может быть любым.\n- По отношению к одному объекту один метод может быть вызван для 'n' членов строк\n- Методы используются для представления бизнес-логики для выполнения операций.\n\nКонструктор:\n\n- Конструктор будет выполняться автоматически всякий раз, когда мы создаем объект.\n- Применительно к одному объекту один конструктор может быть выполнен только один раз\n- Конструкторы используются для определения и инициализации нестатической переменной.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 272,
  "fields": {
    "question": "Что такое инкапсуляция?",
    "answer": "Инкапсуляция - это принцип объектно-ориентированного программирования, который позволяет скрыть внутреннюю реализацию класса от пользователя и защитить данные класса от прямого доступа.\n\nВ Python инкапсуляция реализуется с помощью использования двойных подчеркиваний перед именами атрибутов или методов класса, которые должны быть скрыты. Одинарное подчеркивание говорит о том, что атрибут не должен быть использован за пределами класса, но его можно получить. Двойное подчеркивание делает атрибут или метод частным (private).\n\nНапример, вот пример класса, который использует инкапсуляцию:\n\n```python\nclass Person:\n    def __init__(self, name, age):\n        self.__name = name  # приватный атрибут, имя\n        self.__age = age    # приватный атрибут, возраст\n\n    def get_name(self):\n        return self.__name\n\n    def get_age(self):\n        return self.__age\n\n    def set_name(self, name):\n        self.__name = name\n\n    def set_age(self, age):\n        self.__age = age\n```\n\nВ этом примере класс Person имеет приватные атрибуты **name и **age, которые могут быть получены или изменены только через публичные get и set методы. Любая попытка прямого доступа к этим атрибутам извне класса приведет к ошибке.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 273,
  "fields": {
    "question": "Выполнение команд DML через программы Python?",
    "answer": "Можно выполнять команды DML (Data Manipulation Language) в программе, используя различные библиотеки, такие как Psycopg2 для баз данных PostgreSQL или sqlite3 для баз данных SQLite. Эти библиотеки обеспечивают соединение с базой данных и методы для выполнения запросов к ней, включая запросы SELECT, INSERT, UPDATE и DELETE. Вот пример использования Psycopg2 для выполнения запроса INSERT в базу данных PostgreSQL:\n\n```python\nimport psycopg2\n\nconn = psycopg2.connect(\"dbname=mydatabase user=myuser\")\ncur = conn.cursor()\ncur.execute(\"INSERT INTO mytable (column1, column2, column3) VALUES (%s, %s, %s)\", (value1, value2, value3))\nconn.commit()\n```\n\nА вот пример использования sqlite3 для выполнения запроса SELECT в базе данных SQLite:\n\n```python\nimport sqlite3\n\nconn = sqlite3.connect('example.db')\ncur = conn.cursor()\ncur.execute('SELECT * FROM mytable')\nresults = cur.fetchall()\n```\n\nОбратите внимание, что необходимо заменить mydatabase, myuser, mytable и т.д. на соответствующие значения для вашей базы данных.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 274,
  "fields": {
    "question": "Что такое жизненный цикл потоков?",
    "answer": "Обычно, вы создаете поток, создаётся объект типа Thread или его наследник. После создания потока, вы можете запустить его методом start(), который вызывает метод run() в новом потоке. Когда метод run() завершается, поток переходит в состояние terminated и его жизненный цикл завершается.\n\nЖизненный цикл потоков (thread lifecycle) в Python описывает состояния, на которые может переходить поток от момента его создания до завершения работы. Основные состояния потока в Python включают:\n\n- Создание (creation): Поток создается, но еще не запущен.\n\n- Готовность (ready): Поток готов к выполнению, но еще не начал свою работу (ожидает времени для выполнения).\n\n- Выполнение (running): Поток начинает выполнять свою работу.\n\n- Ожидание (waiting): Поток ожидает какого-то условия для возобновления своей работы (например, ожидание события).\n\n- Блокировка (blocked): Поток блокирован и ожидает освобождения ресурсов (например, блокировка при попытке получения GIL).\n\n- Завершение (termination): Поток выполнил свою работу и завершил свою работу.\n\nМетоды, которые могут изменить состояние потока, включают в себя start(), sleep(), join(), wait(), и notify(). Кроме того, модуль threading позволяет использовать более продвинутые механизмы управления потоками, такие как блокировки и семафоры.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 275,
  "fields": {
    "question": "Что такое планирование?",
    "answer": "Планирование (или планирование задач) в Python - это процесс автоматизации запуска скриптов или выполнения функций в определенное время или по расписанию. Встроенный модуль Python для этого называется sched, и он позволяет создавать простые планировщики задач, чтобы выполнять функции с указанным интервалом времени. Например:\n\n```python\nimport time\nimport sched\n\n# создаем объект класса sched.scheduler\ns = sched.scheduler(time.time, time.sleep)\n\n# определяем функцию, которую хотим выполнить\ndef print_msg(msg):\n    print(\"Сообщение:\", msg)\n\n# планируем выполнение функции через 5 секунд\ns.enter(5, 1, print_msg, argument=(\"Привет\",))\n\n# запускаем планировщик задач\ns.run()\n```\n\nЭтот код планирует выполнение функции print_msg() через 5 секунд, и после этого функция выводит сообщение \"Сообщение: Привет\". Вы можете изменить задержку и функцию, которую хотите выполнить, в зависимости от ваших потребностей. Кроме sched, есть также более продвинутые сторонние библиотеки для планирования задач, например Celery и APScheduler.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 276,
  "fields": {
    "question": "Цикл for реализован на языке python следующим образом:",
    "answer": "```python\nfor element in iterable:\n    iter-obj=iter(iterable)\n    while true:\n        try:\n            element=next(iter_obj)\n        except(slop iteration)\n            break\n```\n\nЦикл For принимает данный объект, преобразует этот объект в форму итерируемого объекта и получает один за другим элемент из итерируемого объекта.\n\nПри получении элемента по значению из итерируемого объекта, если возникает исключение остановки итерации, тогда для цикла внутренне обрабатывается это исключение",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 277,
  "fields": {
    "question": "Для чего нужен OS Module? Приведите примеры.",
    "answer": "Модуль OS - это модуль в Python, который предоставляет множество функций для работы с операционной системой. Он позволяет выполнять такие действия, как создание, удаление и переименование файлов и папок, получение информации о файлах и папках, работа с переменными окружения и многое другое.\n\nВот несколько примеров использования модуля OS:\n\n- Получение текущей директории\n\n```python\nimport os\n\ncurrent_directory = os.getcwd()\nprint(\"Current directory:\", current_directory)\n```\n\n- Создание новой папки\n\n```python\nimport os\n\nnew_folder = os.path.join(os.getcwd(), \"new_folder\")\nos.mkdir(new_folder)\nprint(\"New folder created!\")\n```\n\n- Получение списка файлов в директории\n\n```python\nimport os\n\ndirectory = os.getcwd()\nfile_list = os.listdir(directory)\nprint(\"Files in\", directory, \":\", file_list)\n```\n\n- Удаление файла\n\n```python\nimport os\n\nfile_path_to_delete = \"path/to/file.txt\"\nos.remove(file_path_to_delete)\n```\n\n- Переименование файла\n\n```python\nimport os\n\nold_file_name = \"old_name.txt\"\nnew_file_name = \"new_name.txt\"\n\nos.rename(old_file_name, new_file_name)\n```\n\n- Запуск внешней программы:\n\n```python\nimport os\n\nos.system(\"notepad.exe\")\n\n```\n\n- Проверка существования файла или директории:\n\n```python\nimport os\nif os.path.exists('path/to/file_or_dir'):\n    print('File or dir exists')\nelse:\n    print('File or dir does not exist')\n\n```\n\n- Обход всех файлов в директории и ее поддиректориях:\n\n```python\nimport os\nfor root, dirs, files in os.walk('/path/to/dir'):\n    for file in files:\n        file_path = os.path.join(root, file)\n        print(file_path)\n\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 278,
  "fields": {
    "question": "Что такое приложения Python?",
    "answer": "Python — чрезвычайно универсальный язык программирования с широким спектром практических приложений. Вот некоторые примеры:\n\n- Веб-разработка: Python — популярный выбор для сред веб-разработки, таких как Django и Flask.\n\n- Наука о данных: Python имеет множество библиотек и инструментов, которые позволяют ученым данных эффективно анализировать, визуализировать и манипулировать данными. Популярные библиотеки включают Pandas, NumPy и Matplotlib.\n\n- Машинное обучение и искусственный интеллект: Python стал ведущим языком разработки ИИ с такими популярными платформами, как TensorFlow, PyTorch и Keras.\n\n- Научные вычисления: Python имеет множество библиотек для научных вычислений, таких как SciPy, которые используются учеными для моделирования и анализа сложных систем.\n\n- Разработка игр: Python имеет библиотеки и фреймворки для разработки игр, такие как Pygame.\n\n- Настольные приложения с графическим интерфейсом: Python можно использовать для разработки кроссплатформенных настольных приложений с такими библиотеками, как PyQt и wxPython.\n\n- Сетевое программирование: стандартная библиотека Python включает модули для программирования сокетов и протоколов, таких как HTTP и FTP.\n\n- Образование: Python широко используется во многих учебных заведениях для обучения методам решения проблем и концепциям программирования.\n\nВ целом, Python используется в самых разных приложениях, и его популярность обусловлена ​​простотой использования, гибкостью и универсальностью языка программирования.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 279,
  "fields": {
    "question": "Как интерпретируется Python?",
    "answer": "Язык Python является интерпретируемым языком. Программа Python запускается непосредственно из исходного кода. Он преобразует исходный код, написанный программистом, в промежуточный язык, который снова переводится на машинный язык, который должен быть выполнен.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 280,
  "fields": {
    "question": "Какие инструменты помогают находить ошибки или проводить статический анализ?",
    "answer": "Для нахождения ошибок и проведения статического анализа в Python существует ряд инструментов. Некоторые из них:\n\n- PyChecker — это инструмент статического анализа, который обнаруживает ошибки в исходном коде Python и предупреждает о стиле и сложности ошибки.\n\n- Pylint - это популярный инструмент статического анализа кода Python, который может проверять на соответствие PEP 8, выдавать предупреждения о неиспользуемом коде, проверять типы и т.д.\n\n- Flake8 - это инструмент, объединяющий Pylint, McCabe и PyFlakes, который может использоваться для проведения проверки стиля кода и анализа ошибок.\n\n- PyCharm - это интегрированная среда разработки Python, которая предоставляет инструменты для проведения статического анализа кода, включая проверку на соответствие PEP 8, поиск ошибок и оптимизации кода.\n\n- mypy - это инструмент статической проверки типов для Python, который позволяет обнаруживать ошибки ввода-вывода, предоставляя подробную информацию о типах данных в вашем коде.\n\n- Bandit - это инструмент безопасности, который может использоваться для поиска уязвимостей в коде Python.\n\n- Prospector - это инструмент, который проводит статический анализ Python-кода и выводит информацию о качестве кода, стиле кода, нормах отступов и т.д.\n\n- PyLintBear - это инструмент планирования и прогнозирования ошибок Python, разработанный на основе Pylint, который может поставляться с конфигурируемыми медведями, которые можно использовать для поиска и исправления ошибок.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 281,
  "fields": {
    "question": "Что такое pass в Python?",
    "answer": "В Python pass - это оператор-заглушка, который ничего не делает. Его можно использовать в тех местах, где синтаксически требуется оператор, но никакого действия выполнять не нужно. pass часто используется вместо пустых блоков кода в конструкциях if/else, циклах, функциях, классах, чтобы пока сохранить структуру кода, не реализуя еще какую-то логику. Пример:\n\n```python\nif x == 1:\n    pass   # временно заглушка\nelse:\n    print(\"not 1\")\n```\n\nВ таком примере pass не выполняет никаких действий и не вносит изменений в программу, он просто позволяет коду работать без ошибок. Однако, его можно заменить на любой другой оператор, когда потребуется реализовать какую-то логику внутри этого блока кода.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 282,
  "fields": {
    "question": "Что такое итераторы в Python?",
    "answer": "Итератор в Python - это объект, который позволяет проходить по элементам коллекции или последовательности данных, такой как список, кортеж или словарь, и получать доступ к каждому элементу. Он работает по принципу получения следующего элемента, пока элементы не закончатся. Итераторы реализуют методы **iter**() и **next**(), который возвращает следующий элемент последовательности при каждом вызове.\n\nПример использования итератора в Python:\n\n```python\nmy_list = [1, 2, 3]\nmy_iter = iter(my_list)\nprint(next(my_iter))  # выводит 1\nprint(next(my_iter))  # выводит 2\nprint(next(my_iter))  # выводит 3\n```\n\nВ Python существует множество встроенных итерируемых объектов, таких как range и строки, а также можно создавать пользовательские итераторы, используя классы и реализуя методы **iter**() и **next**(). Итераторы позволяют проходить по коллекции данных без хранения всех элементов в памяти, что полезно при работе с большими объемами данных или потоками данных.\n\n169. Что такое slicing в Python?\n\nSlicing - это механизм выбора подстроки из последовательности, например, строки, списка или кортежа (list, tuple). Он основывается на использовании квадратных скобок и двоеточий [], которые могут принимать три параметра [start:stop:step], что делает возможным выбор только определенного диапазона элементов.\n\nОсновные правила slicing в Python:\n\nstart - индекс символа начала выборки (включая его). Если не указан, значит выборка начинается с самого начала.\n\nstop - индекс символа окончания выборки (не включая его). Если не указан, выборка продолжается до конца последовательности.\n\nstep - опциональный параметр для указания шага изменения индексов.\n\nПримеры использования:\n\n```python\nstr = \"Hello world\"\nprint(str[0:5])  # выведет \"Hello\"\nprint(str[6:])   # выведет \"world\"\n```\n\n```python\nlist = [1, 2, 3, 4, 5]\nprint(list[1:3])  # выведет [2, 3]\nprint(list[::2])  # выведет [1, 3, 5]\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 283,
  "fields": {
    "question": "Что такое генераторы в Python?",
    "answer": "Генераторы - это функции, которые могут приостанавливать своё выполнение (с помощью ключевого слова yield) и возвращать промежуточный результат. Вместо того, чтобы возвращать результат целиком как обычная функция, генераторы возвращают итератор, который может быть использован для последовательного получения промежуточных результатов. Это делает генераторы мощными инструментами для работы с большими наборами данных, поскольку они позволяют работать с данными по мере их поступления, а не ждать завершения обработки всего набора.\n\nВот пример генератора, который генерирует все квадраты чисел от 1 до n включительно:\n\n```python\ndef squares(n):\n    for i in range(1, n+1):\n        yield i*i\n\nfor x in squares(5):\n    print(x)\n```\n\nЭтот код выведет:\n\n```python\n1\n4\n9\n16\n25\n```\n\nОператор yield здесь приостанавливает выполнение функции, возвращая очередной квадрат числа, после чего функция продолжает выполнение с того же места, где остановилась на предыдущей итерации цикла. Каждый раз, когда функция доходит до ключевого слова yield, она приостанавлвает своё выполнение, возвращая промежуточный результат в основную программу. При следующем вызове функции она продолжает работу с точки, где остановилась на предыдущей итерации цикла, и так далее, пока не достигнет конца функции.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 284,
  "fields": {
    "question": "Что такое итератор?",
    "answer": "Итератор - это объект в Python, который может быть пройден (или перебран) в цикле for. Итераторы очень похожи на коллекции: они также могут содержать набор элементов. Однако, в отличие от коллекций, итераторы не могут быть проиндексированы или скопированы напрямую. Вместо этого, они используют метод **next**() для возврата следующего элемента последовательности. Когда все элементы итератора были перебраны, вызов метода **next**() вызывает исключение StopIteration.\n\nНапример, рассмотрим следующий код, который создает итератор my_iter, проходит по его элементам и выводит их на экран:\n\n```python\nmy_list = [1, 2, 3]\nmy_iter = iter(my_list)\nwhile True:\n    try:\n        # Получить следующий элемент из итератора\n        element = next(my_iter)\n        print(element)\n    except StopIteration:\n        # Если все элементы были перебраны, выйти из цикла\n        break\n```\n\nВывод:\n\n```python\n1\n2\n3\n```\n\nЗдесь мы используем функцию iter() для создания итератора из списка my_list и метод next() для получения следующего элемента из итератора. Когда все элементы были перебраны, метод next() вызывает исключение StopIteration, и мы выходим из цикла while.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 285,
  "fields": {
    "question": "Объясните генераторы и итераторы в python?",
    "answer": "",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 286,
  "fields": {
    "question": "Как вы можете скопировать объект в Python?",
    "answer": "Можно скопировать объект, используя конструкторы копирования или методы копирования, такие как copy() или deepcopy() модуля copy, или используя операцию среза. Например, для создания поверхностной копии объекта можно использовать срез:\n\n```python\noriginal_list = [1, 2, 3]\nnew_list = original_list[:]\n```\n\nДля создания глубокой копии объекта можно использовать функцию deepcopy():\n\n```python\nimport copy\n\noriginal_dict = {'a': [1, 2, 3], 'b': {'c': 4}}\nnew_dict = copy.deepcopy(original_dict)\n```\n\nЭто создаст новый словарь new_dict, который будет глубоко скопирован с original_dict.\n\nЧасто используется метод .copy() для поверхностного копирования, который создает новый объект, содержащий ссылки на те же элементы, что и исходный объект:\n\n```python\noriginal_dict = {'a': [1, 2, 3], 'b': {'c': 4}}\nnew_dict = original_dict.copy()\n```\n\nЭто приведет к созданию нового словаря new_dict, который будет содержать ссылки на те же элементы, что и original_dict.\n\nТакже можно использовать конструкторы копирования для создания новых объектов с теми же значениями. Например, для создания новой копии списка можно использовать следующий код:\n\n```python\noriginal_list = [1, 2, 3]\nnew_list = list(original_list)\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 287,
  "fields": {
    "question": "Как преобразовать число в строку?",
    "answer": "Для преобразования числа в строку можно использовать функцию str(). Например:\n\n```python\nx = 10\ns = str(x)\nprint(s) # выводит строку '10'\n```\n\nТакже, при использовании строковых операций с числами, Python автоматически производит преобразование числа в строку. Например:\n\n```python\nx = 10\ns = 'Number: ' + str(x)\nprint(s) # выводит строку 'Number: 10'\n```\n\nЕсли необходимо преобразовать строку в число, то можно использовать функцию int(). Например:\n\n```python\ns = '10'\nx = int(s)\nprint(x) # выводит число 10\n```\n\nНо следует учитывать, что если строка не содержит числовых символов, вызов int() приведет к ошибке.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 1,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 288,
  "fields": {
    "question": "Что такое модуль и пакет в Python?",
    "answer": "Что такое модуль и пакет в Python?\n\nМодуль - это файл, содержащий код с определенным функционалом, который можно загрузить и использовать в других программах.\n\nПакет - это способ организации модулей вместе в одном месте. Пакеты могут содержать другие пакеты, а также модули.\n\nДля создания пакета необходимо создать директорию с именем пакета, содержащую файл **init**.py. Файл **init**.py может быть пустым, либо содержать инициализирующий код для пакета. Модули внутри пакета могут быть импортированы с помощью конструкции import package.module. Это удобный способ организации больших проектов на Python и позволяет легко импортировать и использовать код из других частей программы.\n\nИспользование пакетов и модулей в Python упрощает организацию и поддержку кода, так как позволяет разбить приложение на небольшие и понятные блоки, которые можно разрабатывать отдельно, тестировать и поддерживать.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 289,
  "fields": {
    "question": "Расскажите, каковы правила для локальных и глобальных переменных в Python?",
    "answer": "- Локальные переменные в функции видны только внутри этой функции. Они не могут быть использованы вне функции или в другой функции.\n\n```python\ndef my_function():\n    my_var = 42\n    print(my_var)\nmy_function() # Выведет 42\nprint(my_var) # Ошибка, my_var не определена.\n```\n\n- Глобальные переменные определяются за пределами функции и могут быть использованы в любой части программы, включая функции.\n\n```python\nmy_global_var = 42\ndef my_function():\n    print(my_global_var)\nmy_function() # Выведет 42\nprint(my_global_var) # Выведет 42\n```\n\n- Объявление переменной в функции как global делает эту переменную видимой для всех функций и главной программы.\n\n````python\ndef my_function():\n    global my_var\n    my_var = 42\nmy_function() # my_var будет доступна вне функции\nprint(my_var) # Выведет 42\n```python\n+ Если переменная не была определена внутри функции, Python будет искать ее во внешней области видимости и, если найдет, будет использовать эту переменную внутри функции. Если переменная не будет найдена, это приведет к ошибке.\n````\n\nmy_var = 42\ndef my_function():\nprint(my_var)\nmy_function() # Выведет 42\n\n````\n176. Как вы можете использовать глобальные переменные в модулях?\nВ модулях Python глобальные переменные могут быть объявлены с помощью ключевого слова global. Это позволяет функциям в модуле изменять значение глобальных переменных, определенных в этом же модуле.\n\nНапример, если у вас есть модуль mod.py, содержащий глобальную переменную counter и функцию increment_counter, которая увеличивает значение счетчика на 1, то вы можете использовать global для того, чтобы эта функция могла изменить значение глобальной переменной:\n```python\n# mod.py\ncounter = 0\n\ndef increment_counter():\n    global counter\n    counter += 1\n````\n\nТеперь, если импортировать модуль в другой файл и вызвать функцию increment_counter, это приведет к увеличению значения счетчика на 1:\n\n```python\n# main.py\nimport mod\n\nprint(mod.counter)  # 0\nmod.increment_counter()\nprint(mod.counter)  # 1\n```\n\nТакже можно использовать имена модулей в качестве пространств имен для глобальных переменных, которые могут быть использованы в других файлах.\n\n```python\n# mod.py\napp_count = 0\n\ndef increment_counter():\n    global app_count\n    app_count += 1\n\n# main.py\nimport mod\n\nprint(mod.app_count)  # 0\nmod.increment_counter()\nprint(mod.app_count)  # 1\n```\n\nВнимание, что использование глобальных переменных может быть опасно, если они используются неправильно, поэтому лучше использовать их в ограниченном объеме и с осторожностью.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 290,
  "fields": {
    "question": "Объясните, как удалить файл в Python?",
    "answer": "Чтобы удалить файл в Python, можно использовать метод os.remove() из модуля os.\n\n```python\nimport os\nos.remove('filename.txt') # замените filename.txt на имя вашего файла\n```\n\nОднако, убедитесь, что у вас есть необходимые разрешения на удаление файла.\n\nЕсли вам нужно также удалить пустую директорию, то вы можете использовать os.rmdir(). Если директория не пуста, вы должны использовать shutil.rmtree() чтобы удалить её вместе с содержимым.\n\n```python\nimport os\nimport shutil\n\n# удаление директории если она пустая\nos.rmdir('directory_name') # замените directory_name на имя вашей директории\n\n# удаление директории со всем содержимым\nshutil.rmtree('directory_name') # замените directory_name на имя вашей директории\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 291,
  "fields": {
    "question": "Использование оператора // в Python?",
    "answer": "Оператор // в языке программирования Python используется для целочисленного деления (то есть возвращает только целую часть результата деления). Например:\n\n```python\n>>> 5 // 2\n2\n>>> 7 // 3\n2\n```\n\nВ обоих случаях результат деления округляется в меньшую сторону до ближайшего целого числа, так как до этого вычисления происходит простое целочисленное деление. Этот оператор поможет вам получить только целую часть результата деления, без остатка, что может быть полезно в некоторых случаях.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 292,
  "fields": {
    "question": "Назовите пять преимуществ использования Python?",
    "answer": "- Простота и читаемость кода, благодаря удобному синтаксису.\n\n- Кроссплатформенность, что позволяет запускать программы на различных операционных системах без изменения кода.\n\n- Большое количество библиотек, которые покрывают множество областей, от научных вычислений до веб-разработки.\n\n- Интерактивный режим, который позволяет быстро прототипировать и отлаживать код.\n\n- Сильная поддержка сообщества, которое разрабатывает и поддерживает множество бесплатных инструментов и библиотек.\n\n- Возможность использования Python во многих областях, включая научные и исследовательские проекты, веб-разработку, машинное обучение и автоматизацию задач.\n\n- Высокая производительность, благодаря оптимизированным интерпретаторам, промежуточным языкам и JIT-компиляторам.\n\n- Хорошая масштабируемость и возможность создания больших и сложных проектов.\n\n- Поддержка различных парадигм программирования, включая объектно-ориентированное, функциональное и процедурное программирование.\n\n- Большое количество обучающих ресурсов и курсов, которые помогают быстро и эффективно изучать язык.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 293,
  "fields": {
    "question": "Укажите, в чем разница между Django, Pyramid и Flask?",
    "answer": "Django, Pyramid и Flask - это все web-фреймворки для Python, предназначенные для разработки веб-приложений. Некоторые из основных различий между ними:\n\n- Django - наиболее полнофункциональный из этих фреймворков, с множеством встроенных возможностей, таких как ORM, система аутентификации и авторизации, админ-панель и т.д. Он предназначен для создания сложных web-приложений и подходит для больших команд разработчиков.\n\n- Pyramid - более легковесный фреймворк, не имеет встроенных возможностей, таких как ORM или админ-панель, это позволяет разработчикам самостоятельно настраивать и интегрировать необходимые инструменты. Pyramid - это хороший выбор для проектов с нестандартными требованиями и высокой степенью индивидуализации.\n\n- Flask - самый легковесный из этих трех фреймворков. Flask - это минимальный фреймворк, который может быть использован для создания простых веб-приложений. Flask обеспечивает только базовый функционал, и вам нужно установить и настроить все необходимые инструменты самостоятельно. Flask хорошо подходит для простых проектов, которые не требуют многих функций и имеющих ограниченное время на разработку.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 294,
  "fields": {
    "question": "Объясните, как вы можете свести к минимуму простои сервера Memcached при разработке Python?",
    "answer": "Memcached это бесплатная система кэширования данных в памяти. Она используется для ускорения доступа к данным, которые часто запрашиваются из базы данных или других источников. Memcached хранит данные в оперативной памяти, что позволяет быстро получать к ним доступ и уменьшать количество запросов к базе данных, что в свою очередь ускоряет работу приложений. Memcached работает в формате клиент-сервер, где клиенты отправляют запросы на чтение или запись данных, а серверы хранят и обрабатывают эти запросы. Memcached широко используется веб-приложениями для ускорения доступа к часто используемым данным, таким как HTML-страницы, изображения, результаты запросов к базе данных и т.д.\n\nДля минимизации простоя сервера Memcached при разработке на Python можно использовать библиотеку pymemcache, которая обеспечивает клиент для взаимодействия с Memcached.\n\nЧтобы избежать повторной загрузки данных из базы данных или другого источника, кэшированные данные можно добавить в сервер Memcached и получить их оттуда при последующих запросах. Для этого нужно установить соединение с сервером Memcached по IP-адресу и порту, и затем использовать методы get и set объекта, чтобы получить или установить данные:\n\n```python\nfrom pymemcache.client import base\n\n# create a client instance to connect to the Memcached server\nclient = base.Client(('localhost', 11211)) # replace with your server's IP and port\n\n# set data in cache\nclient.set(key, value, expire_time_in_seconds)\n\n# get data from cache\ndata = client.get(key)\n```\n\nЗдесь key - строковый ключ для сохранения данных, value - данные, которые должны быть сохранены, и expire_time_in_seconds - время в секундах, через которое данные должны быть удалены из кэша.\n\nИспользование кэширования помогает уменьшить нагрузку на сервер и ускорить обработку запросов в приложении.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 295,
  "fields": {
    "question": "Объясните, что такое эффект Dogpile? Как можно предотвратить этот эффект?",
    "answer": "Эффект Dogpile (дрожание кучи) - это ситуация, когда множество запросов кэшу приложения истекают практически одновременно. При этом каждый запрос, который не прошел проверку на наличие в кэше, приводит к обращению к базе данных или другому источнику данных, чтобы получить нужные данные. Это может привести к перегрузке базы данных и снижению производительности приложения.\n\nЧтобы предотвратить эффект Dogpile, можно использовать технику \"мьютекс\" или \"замок\". В этом подходе каждый запрос блокирует доступ к данным, пока не завершится процесс обновления кэша. Таким образом, множество параллельных запросов к кэшу преобразуется в последовательные блокирующие запросы, что позволяет предотвратить загрузку базы данных и сократить время ожидания ответа пользователей.\n\nВ Python для реализации этого подхода можно использовать библиотеку dogpile.cache, которая включает в себя реализацию этой техники и предоставляет удобный API для работы с кэшем.\n\nЧтобы предотвратить эффект Dogpile, можно использовать механизмы, такие как мьютексы, чтобы только один поток запроса запрашивал данные с бэкенда, пока другие потоки просто ждут, пока данные не будут доступны в кэше.\n\nВот пример, как можно предотвратить эффект Dogpile в Python с помощью мьютексов:\n\n```python\nimport threading\n\ndef get_data(key):\n    # Проверить кеш\n    data = CACHE.get(key)\n    if data is not None:\n        return data\n\n    # Получите блокировку и снова проверьте кеш\n    with LOCK:\n        data = CACHE.get(key)\n        if data is not None:\n            return data\n\n        # Если данные по-прежнему недоступны, извлеките их из бэкэнда.\n        data = fetch_data_from_backend(key)\n        CACHE[key] = data\n    return data\n```\n\nВ этом примере используется глобальный словарь CACHE для хранения данных и мьютекс LOCK, который удерживается для одновременного доступа к критической секции кода. При первом обращении поток ждет, пока функция fetch_data_from_backend() не вернет данные. Дальше, другие потоки могут получить данные из кэша, пока данные не устареют.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 1,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 296,
  "fields": {
    "question": "Объясните, почему Memcached не следует использовать в вашем проекте Python?",
    "answer": "Memcached не всегда является наилучшим выбором для проектов Python. Он может иметь сложности с масштабируемостью, особенно когда кэшируемые данные не помещаются в оперативную память. Кроме того, его использование может привести к проблемам с устареванием данных, если они не обновляются или не удаляются из кэша вовремя.\n\nЕсли вы не уверены, что Memcached подходит для вашего проекта Python, рекомендуется тщательно рассмотреть альтернативные варианты кэширования данных, такие как Redis или Couchbase, и выбрать тот, который лучше всего соответствует вашир требованиям и потребностям.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 297,
  "fields": {
    "question": "У вас есть несколько серверов Memcache под управлением Python, на которых один из серверов memcacher выходит из строя, и у него есть ваши данные, будет ли он когда-нибудь пытаться получить ключевые данные с этого одного из вышедших из строя серверов?",
    "answer": "По умолчанию Memcached настроен так, чтобы не пытаться получить данные с неработающих серверов. Когда один из серверов Memcached выходит из строя, задача администратора заключается в том, чтобы удалить этот сервер из кольцевой конфигурации, чтобы данные на этом сервере больше не использовались. Обычно это делается с помощью утилиты для управления Memcached, такой как Memcached Manager или Memcached Control. После удаления неработающего сервера из группы все запросы на ключи будут перенаправлены на оставшиеся работающие серверы.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 298,
  "fields": {
    "question": "Объясните, как можно минимизировать отключения Memcached сервера в вашей разработке на Python",
    "answer": "Чтобы свести к минимуму время простоя сервера Memcached в проекте разработки Python, вы можете выполнить следующие шаги:\n\n- Используйте клиентскую библиотеку, например python-memcached или pymemcache, для подключения к серверу Memcached из кода Python. Эти библиотеки обрабатывают управление соединениями и позволяют легко выполнять операции с кешем.\n- Реализуйте в коде механизм повторных попыток для обработки ошибок подключения. Это можно сделать, перехватив исключения, выдаваемые клиентской библиотекой, когда ей не удается подключиться, и повторив операцию после ожидания в течение некоторого времени с помощью функции time.sleep().\n- Используйте балансировщик нагрузки, такой как HAProxy или Nginx, для распределения нагрузки между несколькими серверами Memcached. Таким образом, если один сервер выходит из строя, другие могут продолжать обрабатывать запросы и обеспечивать бесперебойную работу пользователей.\n- Отслеживайте состояние серверов Memcached с помощью таких инструментов, как Nagios или Zabbix, и настраивайте оповещения, чтобы уведомлять вас о сбое сервера. Это позволит вам принять незамедлительные меры и минимизировать время простоя.\n\nВыполняя эти шаги, вы можете гарантировать, что сервер Memcached останется в рабочем состоянии, обеспечивая быстрый кэш для вашего приложения.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 299,
  "fields": {
    "question": "Для чего используется функция List Comprehension в Python?",
    "answer": "Функция List Comprehension используется для создания новых списков на основе других списков и применения функций к каждому элементу списка. Она представляет собой компактный и выразительный способ создания списков. Вместо того чтобы использовать цикл for для создания нового списка, можно использовать синтаксис в квадратных скобках с указанием выражения, которое нужно применить к каждому элементу списка.\n\nК примеру, следующий код создает список квадратов чисел от 0 до 9, используя цикл for:\n\n```python\nsquares = []\nfor x in range(10):\n    squares.append(x**2)\n```\n\nЭто же самое можно сделать с помощью List Comprehension в одну строку:\n\n```python\nsquares = [x**2 for x in range(10)]\n```\n\nТакже можно добавлять условия в выражение, используя ключевое слово if:\n\n```python\nevens = [x for x in range(10) if x % 2 == 0]\n```\n\nЭто создаст список четных чисел от 0 до 9. List Comprehension может быть использована для решения многих задач в Python, когда требуется создать новый список на основе существующего.\n\nНапример, создание списка из всех слов с нечетной длиной:\n\n```python\nwords = [\"apple\", \"banana\", \"orange\", \"grapefruit\", \"kiwi\"]\nodd_length_words = [word for word in words if len(word) % 2 != 0]\n```\n\nТеперь переменная odd_length_words будет содержать список слов с нечетной длиной: ['apple', 'orange'].",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 300,
  "fields": {
    "question": "Что такое лямбда-выражения, генераторы списков и выражения-генераторы?",
    "answer": "Лямбда-выражения, генераторы списков и выражения-генераторы - это особенности языка Python, которые позволяют сократить объем кода и улучшить его читаемость.\n\n- Лямбда-выражения (lambda expressions) - это анонимные функции, которые можно создавать на лету и использовать в качестве аргументов функций или присваивать переменным. Они особенно полезны для преобразования данных, например в функции map() или filter(). Пример лямбда-выражения:\n\n```python\nsquare = lambda x: x**2\nprint(square(3)) # выводит 9\n```\n\n- Генераторы списков (list comprehensions) - это способ создания списков на основе других списков или итерируемых объектов в более компактной форме с помощью выражений в квадратных скобках. Они позволяют избавиться от необходимости создавать временные переменные и использовать циклы for. Пример генератора списков:\n\n```python\nsquares = [x**2 for x in range(10)]\nprint(squares) # выводит [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n```\n\n- Выражения-генераторы (generator expressions) - это аналог генераторов списков, но они создают итераторы вместо списков. Выражения-генераторы особенно полезны для работы с большими наборами данных, поскольку они позволяют создавать структуры данных \"на лету\" и не занимать много места в памяти. Пример выражения-генератора:\n\n```python\nsquares = (x**2 for x in range(10))\nfor square in squares\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 301,
  "fields": {
    "question": "Что выведет последнее утверждение ниже?",
    "answer": "```python\nflist = []\nfor i in range(3):\n    flist.append(lambda: i)\n\n[f() for f in flist]   # что это распечатает?\n```\n\nВ любом замыкании в Python переменные связаны по имени. Таким образом, приведенная выше строка кода выведет следующее:\n[2, 2, 2]\nПредположительно не то, что задумал автор приведенного выше кода?\n\nОбходной путь — либо создать отдельную функцию, либо передать аргументы по имени; например:\n\n```python\nflist = []\nfor i in range(3):\n    flist.append(lambda i = i : i)\n\n[f() for f in flist]\n[0, 1, 2]\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 302,
  "fields": {
    "question": "Python интерпретируется или компилируется?",
    "answer": "Как отмечалось в статье «Почему так много питонов?», это, честно говоря, вопрос с подвохом, поскольку он искажен. Python сам по себе является не чем иным, как определением интерфейса (как и любая спецификация языка), для которого существует несколько реализаций. Соответственно, вопрос о том, интерпретируется ли «Python» или компилируется, не относится к самому языку Python; скорее, это относится к каждой конкретной реализации спецификации Python.\n\nЕще больше усложняет ответ на этот вопрос тот факт, что в случае с CPython (наиболее распространенной реализацией Python) ответ на самом деле «вроде того и другого». В частности, в CPython код сначала компилируется, а затем интерпретируется. Точнее, он не компилируется в собственный машинный код, а скорее в байт-код. Хотя машинный код, безусловно, быстрее, байт-код более переносим и безопасен. Затем байт-код интерпретируется в случае CPython (или интерпретируется и компилируется в оптимизированный машинный код во время выполнения в случае PyPy).\n\nPython является интерпретируемым языком программирования, что означает, что код Python выполняется интерпретатором строка за строкой, а не компилируется в машинный код перед запуском. Когда вы запускаете скрипт Python, интерпретатор Python читает ваш код, переводит его в байт-код и затем выполняет этот байт-код. Если вам нужно, чтобы ваш код был быстрее, вы можете использовать JIT (Just-in-Time) компиляцию с помощью PyPy, что позволяет ускорить выполнение кода более чем в несколько раз.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 303,
  "fields": {
    "question": "Какие существуют альтернативные реализации CPython? Когда и почему вы можете их использовать?",
    "answer": "Существует несколько альтернативных реализаций CPython, которые могут иметь преимущества в некоторых сценариях использования:\n\n- Jython - версия Python, которая работает на платформе JVM (Java Virtual Machine). Это позволяет использовать библиотеки Java в Python-коде и наоборот.\n\n- IronPython - версия Python, которая работает на платформе .NET. Это позволяет использовать библиотеки .NET в Python-коде и наоборот.\n\n- PyPy - JIT-компилирующая версия Python, которая может работать значительно быстрее чем CPython в некоторых случаях, благодаря оптимизации исполнения Python-кода.\n\n- Stackless Python - версия Python, которая не использует стек вызовов, что позволяет создавать многопоточные приложения с меньшими накладными расходами.\n\n- MicroPython - реализация Python, которая оптимизирована для запуска на устройствах с ограниченными ресурсами. MicroPython позволяет запускать Python код на микроконтроллерах и встраиваемых устройствах.\n\nКаждая из этих реализаций может иметь свои преимущества в зависимости от конкретного сценария использования. Например, если вам нужен быстрый запуск Python-кода, PyPy может быть лучшим выбором, а если вы хотите использовать Java- или .NET-библиотеки в Python-приложении, Jython или IronPython могут быть более подходящими.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 304,
  "fields": {
    "question": "Что такое unittest в Python? Каков ваш подход к модульному тестированию в Python?",
    "answer": "unittest — это стандартный модуль тестирования в Python, который позволяет создавать модульные тесты и запускать их.\nВ unittest входят следующие члены:\n\n>\n\n- FunctionTestCase\n- SkipTest\n- TestCase\n- TestLoader\n- TestResult\n- TestSuite\n- TextTestResult\n- TextTestRunner\n- defaultTestLoader\n- expectedFailure\n- findTestCases\n- getTestCaseNames\n- installHandler\n- main\n- makeSuite\n- registerResult\n- removeHandler\n- removeResult\n- skip\n- skipIf\n- skipUnless\n\nМой подход к модульному тестированию в Python включает написание тестов на каждую функцию или метод в моем коде, и проверка их работы на различных входных данных. Я также стараюсь использовать библиотеку mock для имитации входных данных и других объектов, которые могут влиять на работу кода. Модульное тестирование помогает мне обнаружить и устранить ошибки в коде, а также улучшить его качество и надежность.\n\nВ целом, мой подход заключается в том, чтобы покрыть как можно больше кода тестами, чтобы быть уверенным в правильности работы приложения и быстрой обнаружении ошибок.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 305,
  "fields": {
    "question": "Как бы вы выполнили модульное тестирование своего кода Python?",
    "answer": "Для модульного тестирования Python-кода вы можете использовать встроенный модуль unittest или более простой pytest. Я бы примерно следовал следующей методологии:\n\n- Определить функцию, которую вы хотите протестировать.\n\n- Написать тесты для этой функции, каждый тест должен проверять один аспект поведения функции.\n\n- Запустить все тесты и убедиться, что они все прошли успешно.\n\nНапример, если бы у меня была функция add_numbers, которая принимает два числа и возвращает их сумму, мой тестовый случай может выглядеть так:\n\n```python\ndef add_numbers(x, y):\n    return x + y\n\ndef test_add_numbers():\n    assert add_numbers(2, 3) == 5\n    assert add_numbers(-1, 1) == 0\n    assert add_numbers(0, 0) == 0\n\nif __name__ == '__main__':\n    test_add_numbers()\n    print('All tests passed')\n```\n\nВы можете запустить эту программу, чтобы проверить, что все тесты проходят. Кроме того, более точные отчеты о тестировании можно вывести, используя pytest.\n\n# 293. Как протестировать программу или компонент Python\n\nВы можете использовать встроенный модуль unittest в Python для написания и запуска тестов для вашего кода. Вот пример использования unittest:\n\n```python\nimport unittest\n\ndef add_numbers(a, b):\n    return a + b\n\nclass TestAddNumbers(unittest.TestCase):\n\n    def test_add_positive_numbers(self):\n        self.assertEqual(add_numbers(2, 3), 5)\n\n    def test_add_negative_numbers(self):\n        self.assertEqual(add_numbers(-2, -3), -5)\n\n    def test_add_mixed_numbers(self):\n        self.assertEqual(add_numbers(-2, 3), 1)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nОбратите внимание, что вам нужно создать класс, наследуемый от unittest.TestCase, и определить тестовые функции, которые должны начинаться со слова \"test\". В тестовых функциях вы можете использовать методы assert, такие как assertEqual или assertRaises, чтобы проверить, что ваш код работает корректно в разных сценариях использования.\n\nВы можете запустить этот тест, запустив этот скрипт из командной строки. Но вы также можете использовать интегрированную среду разработки, такую как PyCharm, которая может запускать тесты и показывать результаты в пользовательском интерфейсе.\n\nЕще одним популярным инструментом для тестирования Python-кода является фреймворк pytest. Вы можете установить его с помощью pip и использовать следующим образом:\n\n```python\nimport pytest\n\ndef add_numbers(a, b):\n    return a + b\n\ndef test_add_positive_numbers():\n    assert add_numbers(2, 3) == 5\n\ndef test_add_negative_numbers():\n    assert add_numbers(-2, -3) == -5\n\ndef test_add_mixed_numbers():\n    assert add_numbers(-2, 3) == 1\n```\n\n- Python поставляется с двумя средами тестирования:\n  Тестовый модуль документации находит примеры в строках документации для модуля и запускает их, сравнивая вывод с ожидаемым выводом, указанным в строке документации.\n\nМодуль unittest представляет собой более сложную среду тестирования, созданную по образцу сред тестирования Java и Smalltalk.\n\nДля тестирования полезно написать программу так, чтобы ее можно было легко протестировать, используя хороший модульный дизайн. Ваша программа должна иметь почти всю функциональность, инкапсулированную либо в функции, либо в методы класса. Иногда это приводит к удивительному и восхитительному эффекту ускорения работы программы, поскольку доступ к локальным переменным выполняется быстрее, чем доступ к глобальным.\n\nКроме того, программа должна избегать зависимости от изменения глобальных переменных, так как это значительно усложняет тестирование.\n«Глобальная основная логика» вашей программы может быть такой простой, как:\n\n```python\nесли __name__==\"__main__\":\n    main_logic()\n```\n\nв нижней части основного модуля вашей программы.\nКак только ваша программа будет организована как удобный набор функций и поведений классов, вы должны написать тестовые функции, которые проверяют поведение.\n\nНабор тестов может быть связан с каждым модулем, который автоматизирует последовательность тестов.\n\nВы можете сделать кодирование намного более приятным, написав свои тестовые функции параллельно с «рабочим кодом», так как это позволяет легко находить ошибки и даже недостатки дизайна раньше.\n\n«Модули поддержки», которые не предназначены для использования в качестве основного модуля программы, могут включать самопроверку модуля.\n\n```python\nесли __name__ == \"__main__\":\n    self_test()\n```\n\nДаже программы, которые взаимодействуют со сложными внешними интерфейсами, могут быть протестированы, когда внешние интерфейсы недоступны, с использованием «поддельных» интерфейсов, реализованных в Python.\n\n- <div align=\"right\">\n      <b><a href=\"#\">↥ вернуться к началу</a></b><br>\n      <b><a href=\"#\">если вам понравилось поставьте пожалуйста ★ </a></b>\n  </div>",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 306,
  "fields": {
    "question": "Что такое Flask и его преимущества?",
    "answer": "Flask - это микрофреймворк для веб-приложений на языке Python. Он предоставляет простую и легковесную архитектуру для создания веб-приложений и API.\n\nНекоторые из преимуществ Flask:\n\n- Простота использования и легковесность - Flask предоставляет минимальный набор инструментов для создания веб-приложений, что делает его очень простым в использовании и быстрым в изучении.\n\n- Гибкость в настройке - Flask позволяет настроить почти каждый аспект приложения на ваше усмотрение, что позволяет создавать высокопроизводительные приложения с минимальными затратами.\n\n- Расширяемость - Flask имеет большое количество расширений, которые облегчают реализацию различных функциональных возможностей, таких как аутентификация, работа с базами данных, управление формами, тестирование и т.д.\n\n- Удобство документации - Flask имеет документацию высокого качества и множество практических руководств, что делает его идеальным выбором для начинающих.\n\n- Широкое сообщество - Flask имеет широкое сообщество разработчиков, которые создают множество библиотек и расширений и делятся своим опытом в интернете, что упрощает работу с фреймворком и ускоряет процесс разработки.\n\nВ целом, Flask - отличный выбор для тех, кто ищет простоту, гибкость и высокую производительность в своих веб-приложениях на языке Python",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 307,
  "fields": {
    "question": "Укажите, что такое Flask-WTF и каковы их особенности?",
    "answer": "Flask-WTF - это расширение Flask для работы с web-формами, которое предоставляет инструменты для создания и валидации форм на основе HTML. Он облегчает процесс создания форм, упрощает обработку вводимых данных и обеспечивает защиту от атак типа CSRF (межсайтовая подделка запросов) и XSS (межсайтовые скрипты).\n\nОсобенности Flask-WTF:\n\n- Предоставляет инструменты для создания и валидации форм на основе HTML.\n\n- Упрощает процесс обработки данных, вводимых пользователем.\n\n- Обеспечивает защиту форм от атак CSRF и XSS.\n\n- Расширяемый и кастомизируемый набор методов формирования данных.\n\n- Макросы для быстрого и удобного добавления форм в шаблон Flask.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 308,
  "fields": {
    "question": "Объясните, как обычно работает сценарий Flask?",
    "answer": "Сценарий Flask - это веб-фреймворк для языка Python, который обычно применяется для создания веб-приложений. Он работает по принципу модели MVC (Model-View-Controller), который разделяет приложение на три части: модель, представление и контроллер.\n\nМодель представляет собой объекты данных, представление — пользовательский интерфейс, а контроллер — управляет бизнес-логикой приложения и связывает модель и представление.\n\nВ сценарии Flask вы создаете экземпляр класса Flask и регистрируете в нем маршруты (routes). Маршруты представляют URL-адреса и связанные с ними функции, которые обрабатывают запросы. Функции могут возвращать HTML-страницы, JSON-данные или другие форматы, в зависимости от типа запроса.\n\nНапример, вот простой пример Flask-приложения:\n\n```python\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return 'Hello, World!'\n\nif __name__ == '__main__':\n    app.run()\n```\n\nЗдесь экземпляр класса Flask создается с указанием имени приложения, и создается конечная точка '/' с помощью декоратора @app.route. Функция index будет вызываться при обращении к данной конечной точке, и вернет простое текстовое сообщение 'Hello, World!'. Затем запускается приложение с помощью метода run().\n\nОбычно для работы с запросами в Flask используется объект request, который содержит информацию о запросе, например, переданные параметры и т.д. Например, вот так можно получить значение параметра 'name', переданного при обращении к конечной точке '/hello':\n\n```python\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/hello')\ndef hello():\n    name = request.args.get('name')\n    return f'Hello, {name}!'\n\nif __name__ == '__main__':\n    app.run()\n```\n\nЗдесь метод args.get() используется для получения значения параметра 'name', переданного в GET-запросе.\n\nЭто только самые базовые концепции Flask , дополнительные возможности включают работу с БД, различные методы запросов и многое другое.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 309,
  "fields": {
    "question": "Объясните, как вы можете получить доступ к сеансам в Flask?",
    "answer": "В Flask сессии хранятся на стороне сервера, а не в браузере клиента. Чтобы получить доступ к сессии в Flask, вам нужно импортировать объект session из модуля Flask и использовать его для установки и извлечения значений из сессии. Здесь пример, который демонстрирует, как установить значение в сессии и извлечь его из нее:\n\n```python\nfrom flask import Flask, session, redirect, url_for, request\n\napp = Flask(__name__)\napp.secret_key = 'some_secret_key'\n\n@app.route('/set_session')\ndef set_session():\n    session['username'] = 'John'\n    return 'Session value set'\n\n@app.route('/get_session')\ndef get_session():\n    username = session.get('username')\n    if username:\n        return 'Hello, {}'.format(username)\n    else:\n        return 'No session value set'\n\nif __name__ == '__main__':\n    app.run()\n```\n\nВ этом примере мы устанавливаем значение 'John' для ключа 'username' в сессии при обращении к маршруту /set_session и выводим это значение при обращении к маршруту /get_session. Заметьте, что мы установили секретный ключ app.secret_key, который используется Flask для подписи куков сессии, чтобы обеспечить безопасность.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 310,
  "fields": {
    "question": "Является ли Flask моделью MVC, и если да, то приведите пример, показывающий шаблон MVC для вашего приложения?",
    "answer": "Да, Flask можно рассматривать как модель MVC (Model-View-Controller) в своей архитектуре. Пример шаблона MVC для Flask-приложения может выглядеть примерно так:\n\nМодель (Model): модуль Flask-приложения, отвечающий за обработку данных и логику приложения. Например, это может быть модуль, который взаимодействует с базой данных и обрабатывает запросы.\n\nПредставление (View): модуль Flask-приложения, отвечающий за отображение данных на экране, как правило с помощью Jinja-шаблонов. Например, это может быть модуль, который рендерит HTML-страницы для пользователя.\n\nКонтроллер (Controller): модуль Flask-приложения, отвечающий за обработку HTTP-запросов и связь между моделью и представлением. Например, это может быть модуль, который определяет маршруты и обработчики запросов.\n\nПример:\n\n```python\nfrom flask import Flask, render_template, request\napp = Flask(__name__)\n\n# модель\ndef get_data_from_database():\n    # код для получения данных из базы данных\n    return data\n\n# представление\n@app.route('/')\ndef index():\n    data = get_data_from_database()\n    return render_template('index.html', data=data)\n\n# контроллер\n@app.route('/submit', methods=['POST'])\ndef submit():\n    # код для обработки данных, полученных из формы\n    data = request.form['data']\n    # сохранение данных в базу данных\n    return redirect('/')\n```\n\nВ этом примере функция get_data_from_database является моделью, функция index является представлением, а функция submit - контроллером. Шаблон для отображения данных определен в файле index.html.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 311,
  "fields": {
    "question": "Объясните подключение к базе данных в Python Flask?",
    "answer": "Для подключения к базе данных в Flask можно использовать библиотеку SQLAlchemy. Вот пример кода, демонстрирующий подключение к базе данных SQLite:\n\n```python\nfrom flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\n\napp = Flask(__name__)\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///example.db'\ndb = SQLAlchemy(app)\n\nclass User(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(80), nullable=False)\n\n@app.route('/')\ndef hello_world():\n    return 'Hello, World!'\n\nif __name__ == '__main__':\n    app.run()\n```\n\nВ этом примере мы создаем объект приложения Flask, затем устанавливаем настройку SQLALCHEMY_DATABASE_URI, которая определяет, какую базу данных использовать (в этом случае мы используем SQLite). Мы также создаем экземпляр класса SQLAlchemy, который мы будем использовать для работы с базой данных.\n\nЗатем мы создаем модель базы данных User, которая содержит имя пользователя. Обратите внимание, что эта модель является подклассом db.Model, который является частью SQLAlchemy. Это означает, что SQLAlchemy сможет выполнить миграции базы данных и создать таблицу для этой модели.\n\nНаконец, мы запускаем приложение Flask и можем использовать модель пользователя, чтобы сохранять данные в базе данных.\n\nЭто был пример простого подключения к базе данных SQLite в Flask, но SQLAlchemy также поддерживает другие базы данных, такие как PostgreSQL, MySQL и другие.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 312,
  "fields": {
    "question": "Как вы будете сортировать результаты учеников, оценки которых вам неизвестны, на основе их номеров?",
    "answer": "Используя сортировку пузырьком.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 313,
  "fields": {
    "question": "Как вы будете проверять утечку памяти в Linux?",
    "answer": "Для проверки утечки памяти в Linux можно использовать утилиту Valgrind. Она предназначена для отладки программ, написанных на C, C++ и других языках, и позволяет обнаруживать утечки памяти, ошибки использования указателей и другие проблемы. Для использования Valgrind в Python необходимо установить пакет memcheck-3.4.1 (или более новую версию) и запустить интерпретатор Python с помощью утилиты Valgrind. Например:\n\n```bash\nvalgrind --tool=memcheck --leak-check=yes python myscript.py\n```\n\nЭто запустит скрипт myscript.py под управлением Valgrind и выведет отчет о возможных утечках памяти и других проблемах.\n\nТакже можно использовать модуль Python tracemalloc, который позволяет отслеживать использование памяти в Python и выводить отладочную информацию. Пример использования:\n\n```python\nimport tracemalloc\ntracemalloc.start()  # начало трассировки памяти\n\n# ваш код\n\nsnapshot = tracemalloc.take_snapshot()  # текущее состояние памяти\ntop_stats = snapshot.statistics('lineno')\n\nprint(\"[ Top 10 ]\")\nfor stat in top_stats[:10]:\n    print(stat)\n```\n\nЭто выведет топ-10 участков кода с наибольшим использованием памяти. Однако, обратите внимание, что использование tracemalloc может снизить производительность программы и требует дополнительной обработки кода.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 314,
  "fields": {
    "question": "Как вы можете вернуть несколько значений из функции.",
    "answer": "В Python, вы можете вернуть несколько значений из функции, используя кортежи или списки. Пример с кортежем:\n\ndef get_user_info(user_id): # запрос к базе данных\nuser_name = \"John\"\nuser_age = 30\nuser_gender = \"Male\"\nreturn user_name, user_age, user_gender\n\n# вызываем функцию и сохраняем результат в несколько переменных\n\nname, age, gender = get_user_info(123)\nprint(name, age, gender)\nВ этом примере функция get_user_info возвращает кортеж из трех значений, который затем распаковывается в name, age и gender. Аналогичный пример с использованием списка:\n\ndef get_user_info(user_id): # запрос к базе данных\nuser_name = \"John\"\nuser_age = 30\nuser_gender = \"Male\"\nreturn [user_name, user_age, user_gender]\n\n# вызываем функцию и сохраняем результат в список\n\nuser_info = get_user_info(123)\nprint(user_info)\nЗдесь функция get_user_info возвращает список, который затем можно обработать как обычный список в коде.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 315,
  "fields": {
    "question": "Как быстрее всего поменять местами значения, связанные с двумя переменными?",
    "answer": "Для обмена значениями двух переменных в Python есть несколько способов. Один из наиболее быстрых способов - использовать множественное присваивание. Пример:\n\n```python\na = 1\nb = 2\n\n# обмен значениями\na, b = b, a\n\nprint(a) # 2\nprint(b) # 1\n```\n\nВ этом примере, значение переменной a присваивается переменной b, а значение переменной b присваивается переменной a, при этом оба значения меняются местами.\n\nЕще один способ - использовать временную переменную. Пример:\n\n```python\na = 1\nb = 2\n\n# обмен значениями\ntemp = a\na = b\nb = temp\n\nprint(a) # 2\nprint(b) # 1\n```\n\nВ этом примере, значение переменной a сохраняется во временную переменную, затем значение переменной b присваивается переменной a, а сохраненное значение переменной a присваивается переменной b.\n\nПервый способ с использованием множественного присваивания обычно более предпочтителен, так как он более краткий и понятный.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 316,
  "fields": {
    "question": "В чем важность подсчета ссылок?",
    "answer": "В Python все объекты создаются динамически в куче (heap) и у каждого объекта есть счетчик ссылок на него. Когда счетчик ссылок на объект становится равным нулю, объект удаляется автоматически из памяти. Поэтому правильное подсчет ссылок на объекты в Python является критически важным компонентом управления памятью в Python.\n\nЕсли ссылка на объект не удалена, то объект остается в памяти, занимая ресурсы и может вызывать утечки памяти. С другой стороны, если ссылка на объект удалена преждевременно, то объект может быть удален неправильно и это может вызвать неожиданные ошибки в программе.\n\nТаким образом, правильное управление ссылками на объекты является важным аспектом проектирования и написания Python программ. В Python можно использовать модуль sys для отладки и вывода информации о текущем использовании памяти программой.\n\nВ Python подсчет ссылок на объекты важен для работы сборщика мусора, который автоматически освобождает память, занимаемую неиспользуемыми объектами. Сборщик мусора в Python использует счетчик ссылок для определения, когда объект может быть безопасно удален из памяти. Если на объект не остается ссылок, это означает, что он больше не нужен в программе и может быть удален. Счетчик ссылок также используется для определения экземпляра объекта, на который ссылается переменная. Если одна переменная ссылается на объект, и другая переменная ссылается на тот же объект, то обе переменные ссылается на один и тот же объект, то есть оба объекта имеют одинаковый идентификатор (id). В целом, понимание работы счетчика ссылок в Python важно для понимания механизма управления памятью в языке, и может помочь в создании эффективных и безопасных программ.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 317,
  "fields": {
    "question": "Возвращают ли функции что-то, даже если нет оператора return?",
    "answer": "Да, в Python функции всегда возвращают какое-то значение, даже если внутри них нет оператора return или оператор return без значения. Если оператор return отсутствует, то функция вернет значение None, что может быть использовано в качестве дефолтного значением в тех случаях, когда функция должна вернуть значение, но не имеет конкретных результатов для возврата.\n\nНапример:\n\n```python\ndef greet(name):\n    print(f\"Hello, {name}!\")\n\nresult = greet(\"John\")\nprint(result)  # output: None\n```\n\nЗдесь функция greet не имеет оператора return, поэтому результат ее вызова будет равен None.\n\nОднако, стоит учитывать, что если функция вызвана в рамках выражения (например, передана в качестве аргумента в другую функцию), то в этом случае результат ее выполнения будет использован в соответствующем выражении:\n\n```python\ndef add(a, b):\n    return a + b\n\nresult = add(2, 3) * 5\nprint(result)  # output: 25\n```\n\nЗдесь функция add возвращает результат сложения аргументов, и этот результат умножается на 5, что дает значение 25.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 318,
  "fields": {
    "question": "Как перевернуть список?",
    "answer": "Чтобы перевернуть список в Python, вы можете использовать метод reverse(), который изменяет порядок элементов в списке на противоположный. Например:\n\n```python\nmy_list = [1, 2, 3, 4, 5]\nmy_list.reverse()\nprint(my_list) #Это выведет [5, 4, 3, 2, 1].\n```\n\nЕсли же вы хотите получить новый список, содержащий элементы в обратном порядке, вы можете использовать функцию reversed(), которая возвращает итератор, перебирающий элементы списка в обратном порядке. Например:\n\n```python\nmy_list = [1, 2, 3, 4, 5]\nreversed_list = list(reversed(my_list))\nprint(reversed_list) #Это выведет [5, 4, 3, 2, 1].\n```\n\nОбратите внимание, что функция reversed() не изменяет оригинальный список.\n\nЕщё один способ создать новый список с элементами в обратном порядке - использовать срез с отрицательным шагом. Например:\n\n```python\nmy_list = [1, 2, 3, 4, 5]\nreversed_list = my_list[::-1]\nprint(reversed_list) # Это также выведет [5, 4, 3, 2, 1].\n\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 319,
  "fields": {
    "question": "Как бы вы объединили два отсортированных списка?",
    "answer": "В Python вы можете объединить два отсортированных списка с помощью алгоритма слияния (merge). Этот алгоритм работает следующим образом:\n\nСоздайте новый пустой список и инициализируйте два указателя (index) на начало каждого списка.\n\nСравните значения, на которые указывают указатели, наименьшее из них добавьте в новый список и передвиньте соответствующий указатель на следующую позицию в соответствующем списке.\n\nПовторяйте пункт 2 до тех пор, пока один из указателей не достигнет конца списка.\n\nДобавьте оставшиеся элементы из другого списка в конец нового списка.\n\nВот пример кода на Python, который объединяет два отсортированных списка:\n\n```python\ndef merge_sorted_lists(lst1, lst2):\n    result = []\n    i = 0\n    j = 0\n    while i < len(lst1) and j < len(lst2):\n        if lst1[i] < lst2[j]:\n            result.append(lst1[i])\n            i += 1\n        else:\n            result.append(lst2[j])\n            j += 1\n    result += lst1[i:]\n    result += lst2[j:]\n    return result\n\n# Пример:\nlst1 = [1, 3, 5, 7]\nlst2 = [2, 4, 6, 8]\nmerged = merge_sorted_lists(lst1, lst2)\nprint(merged)  # [1, 2, 3, 4, 5, 6, 7, 8]\n```\n\nЗдесь мы создаем новый пустой список result и два указателя i и j, которые указывают на начало каждого списка. Затем мы сравниваем элементы, на которые указывают указатели, добавляем меньший из них в result и передвигаем соответствующий указатель",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 320,
  "fields": {
    "question": "Как бы вы считали строки в файле?",
    "answer": "Для чтения строк из файла в Python, вы можете использовать метод readline() для чтения одной строки или метод readlines() для чтения всех строк и сохранения их в списке. Вот пример использования метода readline():\n\n```python\nwith open('file.txt', 'r') as file:\n    line = file.readline()\n    while line:\n        print(line.strip())\n        line = file.readline()\n```\n\nЭтот код открывает файл file.txt в режиме чтения и использует метод readline() для чтения первой строки. Затем он входит в цикл while, который продолжается до тех пор, пока readline() не вернет пустую строку. В теле цикла он выводит текущую строку, очищая ее от лишних символов с помощью метода strip(), и затем использует readline() для чтения следующей строки.\n\nВы также можете использовать расширенный синтаксис оператора with. Этот синтаксис обеспечивает автоматическую очистку файла после того, как он больше не нужен, что здесь достигается при помощи дополнительного блока with.\n\nЕсли вам нужно обработать каждую строку как отдельную единицу, вы можете использовать for-цикл следующим образом:\n\n```python\nwith open('file.txt', 'r') as file:\n    for line in file:\n        print(line.strip())\n```\n\nЭтот код имеет тот же эффект, что и предыдущий пример: он выводит все строки файла, одну за другой, очищая каждую строку от лишних пробелов и символов перевода строки с помощью метода strip().",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 321,
  "fields": {
    "question": "Какие стандартные библиотеки Python?",
    "answer": "Python имеет большое количество стандартных библиотек, охватывающих широкий спектр функций. Вот некоторые из основных стандартных библиотек Python:\n\n- datetime для управления датами и временем\n- math для математических операций\n- random для генерации случайных чисел\n- re для регулярных выражений\n- json для кодирования и декодирования данных JSON.\n- csv для работы с файлами CSV\n- os для функций, связанных с операционной системой\n- sys для системных параметров и функций\n- urllib для выполнения HTTP-запросов\n- sqlite3 для работы с базами данных SQLite\n- pickle для сериализации и десериализации объектов Python\n\nВ Python есть еще много стандартных библиотек, охватывающих широкий спектр функций. Кроме того, для Python доступно множество сторонних библиотек, которые можно установить с помощью менеджеров пакетов, таких как pip или conda.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 322,
  "fields": {
    "question": "Что такое размер целого числа в Python?",
    "answer": "В Python размер целого числа зависит от используемой платформы, так как используется целочисленное представление в дополнительном коде. В большинстве современных платформ размер целых чисел равен 4 байтам (32 битам) или 8 байтам (64 бита), но в теории может быть самым разным. Однако для работы с очень большими целыми числами их можно представлять в виде строк, используя модуль Decimal, например. Кроме того, в Python есть другие типы данных для работы с числами, такие как float и Decimal, если требуется большая точность вычислений.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 323,
  "fields": {
    "question": "Что такое форматы сериализации в Python?",
    "answer": "Форматы сериализации - это способы преобразования объектов Python в байтовые потоки, которые могут быть сохранены в файл или переданы по сети для последующего использования. Некоторые из наиболее распространенных форматов сериализации в Python включают JSON, Pickle, YAML, XML и Avro.\n\n- JSON (JavaScript Object Notation) - это текстовый формат обмена данными, основанный на синтаксисе объектов JavaScript. В Python есть встроенный модуль json, который позволяет сериализовать объекты Python в JSON и обратно.\n\n- Pickle - это протокол Python для сериализации и десериализации объектов Python. Pickle может сериализовать практически любой объект Python, включая списки, словари, кортежи и объекты пользовательских классов.\n\n- YAML (YAML Ain't Markup Language) - это текстовый формат сериализации данных, который является человекочитаемым и удобным для редактирования вручную. В Python есть модуль PyYAML, который позволяет сериализовать объекты Python в YAML и обратно.\n\n- XML (Extensible Markup Language) - это формат сериализации данных, который использует синтаксис разметки для хранения данных в текстовых файлах. В Python есть несколько модулей для работы с XML, в том числе ElementTree, lxml и xml.etree.ElementTree.\n\n- Avro - это двоичный протокол сериализации данных, который позволяет определить схему данных и генерировать код для работы с ней на разных языках. В Python есть модуль fastavro, который позволяет сериализовать и десериализовать данные в формате Avro.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 324,
  "fields": {
    "question": "Как Python управляет памятью?",
    "answer": "Python использует автоматическое управление памятью, что означает, что вы не должны явно управлять выделением и освобождением памяти при работе с объектами. Вместо этого, Python использует сборщик мусора для автоматического освобождения неиспользуемой памяти.\n\nPython применяет схему подсчета ссылок для определения того, какие объекты в настоящее время используются приложением, и автоматически освобождает память, когда объекты больше не нужны. При удалении объекта Python уменьшает количество ссылок на него, и когда количество ссылок достигает нуля, Python автоматически освобождает память, занятую объектом.\n\nЕсли вы хотите управлять памятью в программе на Python, вы можете использовать модуль gc (garbage collector), который предоставляет некоторые функции для управления поведением сборщика мусора.\n\nНапример, для отключения сборки мусора в Python вы можете использовать следующий код:\n\n```python\nimport gc\ngc.disable()\n```\n\nОбычно в Python нет необходимости явно управлять памятью, и рекомендуется разрабатывать приложения без непосредственного воздействия на работу сборщика мусора.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 325,
  "fields": {
    "question": "Является ли кортеж изменяемым или неизменным?",
    "answer": "Кортеж (tuple) в Python является неизменяемым (immutable) объектом, что означает, что после создания его нельзя изменить, добавить или удалить элементы. Однако, если кортеж содержит изменяемые объекты, например, список (list), то эти объекты могут быть изменены. Но сам кортеж останется неизменным, то есть его размер (количество элементов) и порядок элементов не изменятся. Это отличает кортеж от списка, который является изменяемым объектом.\n\n```python\nmy_tuple = (1, 2, 3)\nprint(my_tuple)  # (1, 2, 3)\n\n# my_tuple[1] = 4  # TypeError: объект 'tuple' не поддерживает назначение элементов\n\nmy_tuple_with_list = (1, [2, 3])\nmy_tuple_with_list[1][0] = 4  # возможно, поскольку список внутри кортежа является изменяемым\nprint(my_tuple_with_list)  # (1, [4, 3])\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 326,
  "fields": {
    "question": "Расскажите мне какие-нибудь структуры данных в Python?",
    "answer": "Структуры данных в Python включают в себя различные виды, такие как списки, словари, множества, кортежи и т.д.\n\n- Списки (list) являются наиболее распространенным типом структуры данных в Python. Они представляют собой упорядоченную коллекцию объектов. Списки могут содержать объекты любого типа, включая другие списки. Чтобы объявить список, можно использовать квадратные скобки:\n\n```python\nmy_list = [1, 2, 3, \"four\", 5.0]\n```\n\n- Словари (dictionary) - это также очень распространенный вид структуры данных в Python. Словарь представляет собой неупорядоченную коллекцию объектов, в которой каждый объект имеет ключ, связанный с ним. Ключи должны быть уникальными, а значения могут быть объектами любого типа. Для создания словаря можно использовать фигурные скобки:\n\n```python\nmy_dict = {\"one\": 1, \"two\": 2, \"three\": 3}\n```\n\n- Множества (set) - это еще один тип структуры данных, представляющий собой неупорядоченную коллекцию уникальных элементов. Множество можно создать с помощью функции set() или фигурных скобок:\n\n```python\nmy_set = set([1, 2, 3, 4, 5])\n```\n\n- Кортежи (tuple) - это структура данных, представляющая собой неизменяемый список. Они содержат объекты любого типа, включая другие кортежи, и объявляются с помощью круглых скобок:\n\n```python\nmy_tuple = (1, 2, 3, \"four\", 5.)\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 327,
  "fields": {
    "question": "Почему python вместо scala на spark, если у scala лучше производительность?",
    "answer": "Вопрос о выборе Python вместо Scala для Spark - это сложный вопрос, который зависит от конкретной ситуации и потребностей. В общем случае, Scala может демонстрировать более высокую производительность, чем Python, поскольку это статически типизированный язык с компиляцией в байт-код JVM. Однако использование Python с Apache Spark также имеет свои преимущества, такие как возможность работы с библиотеками на Python и более широким сообществом пользователей. Кроме того, Python имеет более простой синтаксис и легче доступен для начинающих разработчиков. Таким образом, выбор между Python и Scala для Spark зависит от конкретной задачи, приоритетов проекта и опыта команды разработчиков.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 328,
  "fields": {
    "question": "Как получить доступ к файлу на Linux-сервере с помощью Python?",
    "answer": "Для получения доступа к файлу на Linux-сервере с помощью Python можно использовать модуль paramiko. Этот модуль позволяет создавать SSH-соединения с удаленными серверами и выполнять на них команды, включая работу с файлами.\n\nВот простой пример, который показывает, как прочитать содержимое файла с помощью модуля paramiko:\n\n```python\nimport paramiko\nssh = paramiko.SSHClient()\nssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\nssh.connect('hostname', username='username', password='password')\nstdin, stdout, stderr = ssh.exec_command('cat /path/to/file.txt')\nprint(stdout.read().decode())\nssh.close()\n```\n\nВ этом примере мы создаем SSH-соединение с удаленным сервером, указываем имя пользователя и пароль, и выполняем команду 'cat /path/to/file.txt', которая выводит содержимое файла на экран. Затем мы просто выводим результат в консоль.\n\nКроме того, вы можете использовать SCP (Secure Copy), чтобы скопировать файл с сервера на локальную машину:\n\n```python\nimport paramiko\nssh = paramiko.SSHClient()\nssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\nssh.connect('hostname', username='username', password='password')\n\nscp = ssh.open_sftp()\nscp.get('/path/to/remote/file', '/path/to/local/file')\nscp.close()\n\nssh.close()\n```\n\nВ этом примере мы подключаемся к удаленному серверу, создаем объект SCP, запрашиваем файл и копируем его на локальную машину.\n\nОба примера использования модуля paramiko требуют установки этого модуля на вашей системе:\n\n```bash\npip install paramiko\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 329,
  "fields": {
    "question": "Что такое List Comprehension? Показать на примере",
    "answer": "List comprehension в Python - это синтаксическая конструкция, которая позволяет создавать новый список на основе элементов существующего списка или другого итерируемого объекта с использованием более компактного и выразительного синтаксиса.\n\nПример:\n\nСоздание списка, содержащего квадраты чисел от 0 до 9 с помощью цикла for:\n\n```python\nsquares = []\nfor i in range(10):\n    squares.append(i**2)\nprint(squares) # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n```\n\nТо же самое с использованием list comprehension:\n\n```python\nsquares = [i**2 for i in range(10)]\nprint(squares) # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n```\n\nВ данном случае, мы создаем новый список, применяя операцию возведения в квадрат к каждому элементу диапазона от 0 до 9.\n\nМожно также добавить условие фильтрации элементов, например, чтобы создать список квадратов только для четных чисел:\n\n```python\nsquares = [i**2 for i in range(10) if i % 2 == 0]\nprint(squares) # [0, 4, 16, 36, 64]\n```\n\nВ этом примере, мы добавляем условие if i % 2 == 0, чтобы список squares содержал квадраты только четных чисел.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 330,
  "fields": {
    "question": "Как выполнить java-код?",
    "answer": "Выполнение Java-кода в Python может быть достигнуто с помощью использования библиотеки JPype. Эта библиотека позволяет вызывать Java-методы из Python и наоборот.\n\nСначала нужно установить JPype. Вы можете установить его, используя pip:\n\n```bash\npip install JPype1\n```\n\nЗатем на Java-стороне вам нужно создать Java-класс, который вы хотите вызвать из Python\n\nВ Python-скрипте вы можете создать экземпляр Java-класса jpype.JClass(className) и вызвать его методы, используя стандартный синтаксис вызова методов в JPype.\n\nВот небольшой пример:\n\n```java\nJava-код MyClass.java\n\npublic class MyClass {\n   public static String hello(String name) {\n       return \"Hello \" + name + \" from Java!\";\n   }\n}\n```\n\nPython-код\n\n```python\nimport jpype\n\n# Загрузка JVM\njpype.startJVM(jpype.getDefaultJVMPath())\n\n# Создание экземпляра класса MyClass\nMyClass = jpype.JClass('MyClass')\nmsg = MyClass.hello('you')\n\n# Вывод сообщения на экран\nprint(msg)\n\n# Остановка JVM\njpype.shutdownJVM()\n```\n\nЭтот код загрузит класс MyClass из Java-кода, создаст его экземпляр и вызовет статический метод hello(). Результат будет выведен на экран.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 331,
  "fields": {
    "question": "Как найти PID процесса и как узнать, сколько ресурсов занимает процесс в Linux?",
    "answer": "В Linux можно найти идентификатор процесса (PID) с помощью утилиты ps. Вы можете использовать команду ps aux | grep process_name для поиска процесса по его имени и показа его PID. Например:\n\n```bash\nps aux | grep firefox\n```\n\nЭто покажет все запущенные процессы Firefox, их PID и другую информацию.\n\nВы также можете использовать утилиту top, чтобы увидеть запущенные процессы и их PID. Команда top покажет текущую нагрузку на систему и список всех процессов, запущенных в данный момент. Она также отображает информацию о каждом процессе, включая его PID, процент использования процессора и использование памяти.\n\nЧтобы узнать, сколько ресурсов занимает процесс, вы можете использовать утилиту ps. Команда ps отображает информацию о процессах, включая использование памяти. Вы можете использовать команду ps -p pid -o %cpu,%mem для показа процессорного и памятевого использования определенного процесса. Например:\n\n```bash\nps -p 1234 -o %cpu,%mem\n```\n\nЭто вернет процент использования процессора и памяти для процесса с PID 1234.\n\nЕсли вы хотите увидеть более подробную информацию о процессах, вы можете использовать команду top. В top вы можете сортировать процессы по использованию процессора или памяти, чтобы найти наиболее интенсивно использующий ресурсы процесс.",
    "category": 1,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 332,
  "fields": {
    "question": "Какие иструменты для приема данных в Python?",
    "answer": "В Python доступно несколько инструментов для приема данных, в том числе:\n\n- Pandas: популярная библиотека обработки и анализа данных на Python, которая включает в себя множество функций для приема данных из разных источников\n- Petl: Python ETL — это базовый инструмент, который предлагает стандартную функциональность ETL для импорта данных из разных источников (таких как csv 1, excel и т. д.).\n- Bonobo: легкая структура ETL, предназначенная для быстрого создания конвейеров для обработки данных.\n- Beautiful Soup: библиотека для парсинга веб-страниц на Python, которую можно использовать для извлечения данных из файлов HTML и XML.\n- Airflow: платформа для программного создания, планирования и мониторинга рабочих процессов. Фабрика данных\n- Azure: облачная служба интеграции данных, которая позволяет создавать, планировать и управлять конвейерами данных.\n\nЭти инструменты предоставляют ряд функций и возможностей для приема данных из разных источников и их преобразования по мере необходимости.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 333,
  "fields": {
    "question": "Как Python выполняет код?",
    "answer": "Python выполняет код в несколько этапов. Когда вы запускаете скрипт Python или вводите код в интерактивной оболочке, он проходит через следующие этапы:\n\n- Лексический анализ: разбивает исходный код на лексемы или токены (ключевые слова, операторы, идентификаторы и т.д.).\n\n- Синтаксический анализ: анализирует последовательность лексем и создает дерево синтаксических связей, называемое деревом разбора.\n\n- Компиляция: проходит по дереву разбора и создает байт-код.\n\n- Выполнение: интерпретатор Python читает байт-код, и выполняет соответствующие операции.\n\nТакже Python выполняет процесс интерпретации кода динамически, что означает, что тип переменной определяется во время выполнения кода, а не во время компиляции, как, например, в языке C.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 334,
  "fields": {
    "question": "Что такое привязки, т. е. что означает привязка значения к переменной?",
    "answer": "В Python привязка — это связь между переменной, также известной как имя, и объектом, также известным как значение. Когда мы создаем новую переменную, мы создаем новое имя, которое привязывается к определенному объекту в памяти. Затем мы можем использовать это имя для ссылки на объект и выполнения с ним действий. Когда мы присваиваем значение переменной в Python, мы привязываем эту переменную к объекту, который представляет значение. Это означает, что имя переменной теперь указывает на объект в памяти, который содержит значение. С этого момента, если мы используем переменную, мы фактически ссылаемся на значение, хранящееся в объекте, на который она указывает.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 335,
  "fields": {
    "question": "Как вы создаете список?",
    "answer": "Вы можете создать список (list), используя квадратные скобки [] и разделяя элементы запятыми. Ниже приведены несколько примеров:\n\n```python\n# Создание пустого списка\nmy_list = []\n\n# Создание списка со значениями\nmy_list = [1, 2, 3, \"four\", 5.0]\n\n# Создание списка из переменных\na = 10\nb = 20\nc = 30\nmy_list = [a, b, c]\n\n# Создание вложенного списка\nnested_list = [[1,2,3], [4,5,6], [7,8,9]]\n```\n\nВы также можете создавать список с помощью генератора списка или добавлять элементы в список с помощью метода append(). Вот несколько примеров:\n\n```python\n# Создание списка с помощью генератора списка\nmy_list = [x**2 for x in range(1, 6)]\n# [1, 4, 9, 16, 25]\n\n# Создание списка с использованием метода append()\nmy_list = []\nmy_list.append(10)\nmy_list.append(20)\nmy_list.append(30)\n# [10, 20, 30]\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 336,
  "fields": {
    "question": "Как вы создаете словарь?",
    "answer": "Cловари (dict) могут быть созданы с помощью фигурных скобок {} или с использованием ключевого слова dict(). Вот несколько примеров:\n\n```python\n# Создание словаря с помощью фигурных скобок {}\nmy_dict = {\"key1\": \"value1\", \"key2\": \"value2\"}\n\n# Создание пустого словаря с фигурными скобками {}\nmy_empty_dict = {}\n\n# Создание словаря с использованием ключевого слова dict()\nmy_dict_2 = dict(key1=\"value1\", key2=\"value2\")\n\n# Создание пустого словаря с использованием ключевого слова dict()\nmy_empty_dict_2 = dict()\n```\n\nМожно также использовать циклы for для заполнения словаря:\n\n```python\n# Создание словаря с использованием цикла for\nmy_dict = {}\nfor i in range(5):\n    my_dict[i] = i * i\n```\n\nМожно также использовать comprehension для создания словаря:\n\n```python\n# Создание словаря с использованием comprehension\nmy_dict = {i: i * i for i in range(5)}\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 337,
  "fields": {
    "question": "Что такое list comprehension? Почему бы вам использовать один?",
    "answer": "List comprehension - это конструкция в языке Python, которая позволяет создавать новые списки с помощью более компактного и выразительного синтаксиса, чем при использовании циклов for и while.\n\nВ общем виде, синтаксис list comprehension выглядит следующим образом:\n\n`new_list = [expression for item in iterable if condition]`\nгде:\n\n- expression - это выражение, которое применяется к каждому элементу входного списка (iterable), чтобы создать соответствующий элемент в выходном списке (new_list).\n\n- item - это переменная, которая принимает каждый элемент входного списка (iterable).\n\n- iterable - это исходный список, из которого нужно извлечь элементы для нового списка.\n\n- condition (не обязательно) - это условие, которое должно быть истинным для каждого элемента входного списка (iterable), чтобы он был включен в выходной список (new_list).\n\nНиже приведен пример, показывающий, как можно использовать list comprehension для создания нового списка, содержащего квадраты четных чисел:\n\n```python\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nsquares_of_evens = [x**2 for x in numbers if x % 2 == 0]\nprint(squares_of_evens)        # Output: [4, 16, 36, 64, 100]\n```\n\nПреимущества использования list comprehension заключаются в том , что она делает код более кратким, читаемым и выразительным. Она также может увеличить производительность, особенно при работе с большими наборами данных, поскольку выполняется в один проход без необходимости создавать промежуточные значения.\n\n\n\n##326. Что такое генератор? Для чего это можно использовать?\n\nГенераторы в Python - это функции, которые имеют возможность временно приостанавливать свое выполнение, возвращать промежуточный результат и затем возобновлять выполнение с того же места, где оно было приостановлено. Они используют ключевое слово yield для возврата значений. Таким образом, генератор в Python позволяет производить тяжелые вычисления \"на лету\", без необходимости загрузки в память всех данных сразу.\n\nГенераторы могут использоваться для создания последовательностей значений, которые могут быть достаточно большими для того, чтобы не помещаться в память. Они также могут использоваться для создания бесконечных последовательностей или для обработки больших объемов данных.\n\nПример использования генератора для создания последовательности чисел:\n\n```python\ndef generator(n):\n    i = 0\n    while i < n:\n        yield i\n        i += 1\n\n# Пример использования генератора\nfor i in generator(5):\n    print(i)\n```\n\nЭтот код будет выводить числа от 0 до 4.\n\nБлагодаря генераторам, нет необходимости загружать все числа в последовательности сразу, что может быть очень полезным при работе с большими объемами данных.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 338,
  "fields": {
    "question": "Что такое наследование?",
    "answer": "Наследование - это механизм, который позволяет классу наследовать атрибуты и методы другого класса. В Python каждый класс наследует некоторые методы от своего базового класса (названного родительским классом или суперклассом), таких как **init**() метод, который определяет, как создать объект класса. В дочернем классе вы можете переопределять методы, унаследованные от родительского класса, или добавлять новые атрибуты и методы. Наследование позволяет переиспользовать код и создавать иерархии классов для описания связей между объектами.\n\nВот пример класса, который наследует атрибуты и методы другого класса:\n\n```python\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n\n    def make_sound(self):\n        pass\n\nclass Dog(Animal):\n    def make_sound(self):\n        return \"woof!\"\n```\n\nDog является дочерним классом Animal, поэтому он автоматически наследует **init**() метод. Dog также переопределяет make_sound() метод, который был унаследован от Animal. Теперь мы можем создать объект Dog и вызвать его методы:\n\n```python\nmy_dog = Dog(\"Rufus\")\nprint(my_dog.name) # выводит \"Rufus\"\nprint(my_dog.make_sound()) # выводит \"woof!\"\n```\n\nЭто пример простого наследования в Python. Наследование может быть глубоким и включать множество уровней иерархии классов.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 339,
  "fields": {
    "question": "Что произойдет, если у вас есть ошибка в операторе **init** ?",
    "answer": "Если в операторе **init** класса произойдет ошибка, то при создании экземпляра класса будет вызвано исключение TypeError. Это происходит потому что при вызове **init** происходит инициализация объекта класса, и если эта инициализация завершается ошибкой, экземпляр класса не будет создан.\n\nПример:\n\n```python\nclass MyClass:\n    def __init__(self, x):\n        self.value = 10 / x\n\nobj = MyClass(0)\n```\n\nЭтот код вызовет исключение ZeroDivisionError, так как происходит деление на ноль в операторе **init**. Если мы исправим код и передадим ненулевое значение аргумента x, то экземпляр класса создастся успешно.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 340,
  "fields": {
    "question": "Что произойдет в питоне, если вы попытаетесь делить на ноль?",
    "answer": "В Python при делении на 0 возникает исключение ZeroDivisionError. Например, если попробовать сделать 5 / 0, код выдаст ошибку:\n\nZeroDivisionError: division by zero\nЧтобы избежать ошибки, можно использовать конструкцию try/except для обработки исключения:\n\n```python\ntry:\n    x = 5 / 0\nexcept ZeroDivisionError:\n    print(\"Деление на ноль невозможно.\")\n```\n\nЭтот код будет выводить сообщение \"Деление на ноль невозможно.\" в случае, если происходит деление на 0.\n\nИспользование этой конструкции особенно важно, если делитель задается пользователем и может быть равен 0 - это избавляет от нежелательного прерывания выполнения программы.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 341,
  "fields": {
    "question": "Чем переменные экземпляра отличаются от переменных класса?",
    "answer": "Переменные экземпляра отличаются от переменных класса тем, что они хранят данные, уникальные для каждого экземпляра класса. Переменные класса, также называемые переменными-членами, хранят данные, общие для всех экземпляров класса.\n\nВ Python переменные экземпляра объявляются внутри метода **init**, например:\n\n```python\nclass MyClass:\n    def __init__(self, name):\n        self.name = name\n```\n\nЗдесь переменная name является переменной экземпляра, так как она хранит уникальное значение для каждого объекта класса MyClass.\n\nПеременные класса объявляются внутри класса, но вне методов. Они доступны через имя класса, а не через имя экземпляра. Например:\n\n```python\nclass MyClass:\n    class_var = 0\n```\n\nЗдесь переменная class_var является переменной класса и будет общей для всех объектов класса MyClass.\n\nДля доступа к переменным экземпляра используется оператор точки ., а для доступа к переменным класса - имя класса, например:\n\n```python\nmy_object = MyClass('test')\nprint(my_object.name)  # обращение к переменной экземпляра\nprint(MyClass.class_var)  # обращение к переменной класса\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 342,
  "fields": {
    "question": "Объясните разницу между Map и Reduce и Filter?",
    "answer": "Функции map(), reduce() и filter() относятся к так называемым встроенным функциям высшего порядка и используются для обработки коллекций данных, таких как списки или кортежи. Вот их краткое описание:\n\n- map() принимает функцию и коллекцию и возвращает новую коллекцию, где каждый элемент исходной коллекции заменен результатом применения переданной функции к этому элементу. Пример:\n\n```python\na = [1, 2, 3, 4, 5]\nsquared = map(lambda x: x**2, a)\nprint(list(squared)) # [1, 4, 9, 16, 25]\n```\n\n- reduce() принимает функцию и коллекцию и возвращает результат последовательного применения этой функции ко всем элементам коллекции до получения единственного значения. Пример:\n\n```python\nimport functools\na = [1, 2, 3, 4, 5]\nproduct = functools.reduce(lambda x, y: x*y, a)\nprint(product) # 120\n```\n\n- filter() принимает функцию и коллекцию и возвращает новую коллекцию, содержащую только те элементы исходной коллекции, которые удовлетворяют условию, определенному переданной функцией. Пример:\n\n```python\na = [1, 2, 3, 4, 5]\neven = filter(lambda x: x % 2 == 0, a)\nprint(list(even)) # [2, 4]\n```\n\nТаким образом, Map и Filter принимают коллекцию и возвращают новую коллекцию, в то время как Reduce принимает коллекцию и возвращает одно значение, полученное последовательным применением функции к элементам коллекции.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 343,
  "fields": {
    "question": "Что такое Генераторы?",
    "answer": "Генераторы (generators) - это функции, которые используются для создания итераторов. Они позволяют генерировать значения на лету, вместо того, чтобы хранить все значения в памяти сразу, что может быть полезно при работе с большими объемами данных.\n\nГенераторы создаются с помощью ключевого слова yield. Когда функция с yield вызывается, она возвращает объект-генератор, который может быть проитерирован с помощью цикла for или функции next(), вызывая тело функции до тех пор, пока не будет достигнуто выражение yield.\n\nПример генератора, который возвращает список квадратов чисел от 1 до 10:\n\n```python\ndef squares():\n    for i in range(1, 11):\n        yield i**2\n\n# использование\nfor square in squares():\n    print(square)\n```\n\nТакже можно использовать генераторы в качестве аргументов функций, например, sum() или list():\n\n```python\ndef squares():\n    for i in range(1, 11):\n        yield i**2\n\n# использование\nprint(sum(squares())) # 385\nprint(list(squares())) # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 344,
  "fields": {
    "question": "Что такое Итераторы?",
    "answer": "Итератор - это объект, который генерирует последовательность элементов. Итератор является объектом, который можно проитерировать, то есть пройти по нему в цикле for. Когда вызывается функция iter() на итерируемом объекте, она создает и возвращает итератор.\n\nЧтобы создать собственный итератор в Python, нужно определить специальные методы **iter**() и **next**(). Метод **iter**() должен возвращать сам объект итератора, а метод **next**() должен возвращать следующий элемент последовательности или возбуждать исключение StopIteration, если элементов больше нет.\n\nВот пример, как использовать итератор для прохода по списку:\n\n```python\nmy_list = [1, 2, 3]\nmy_iterator = iter(my_list)\n\nprint(next(my_iterator)) # 1\nprint(next(my_iterator)) # 2\nprint(next(my_iterator)) # 3\n```\n\nВызовы функции next() в последней строке генерируют элементы списка последовательно.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 345,
  "fields": {
    "question": "Можно ли использовать генератор для создания итераторов? Приведите пример.",
    "answer": "Да, возможно использовать генератор для создания итераторов в Python. Вот пример такого использования:\n\n```python\ndef my_generator(n):\n    for i in range(n):\n        yield i * i\n\nclass MyIterator:\n    def __init__(self, n):\n        self.generator = my_generator(n)\n\n    def __next__(self):\n        return next(self.generator)\n\n    def __iter__(self):\n        return self\n\n# использование\nmy_iterator = MyIterator(5)\nfor i in my_iterator:\n    print(i)\n```\n\nВ этом примере генератор my_generator используется для итерирования n раз и возврата квадрата индекса i. Затем создается итератор MyIterator, который использует этот генератор. Класс MyIterator определяет методы **next** для получения следующего элемента и **iter** для возврата самого себя в качестве итератора.\n\nПри использовании генератора в качестве основы для итератора вы можете избежать необходимости явно определять методы **next** и **iter** в классе итератора. Более того, использование генераторов позволяет сократить объем кода, делая его более читаемым и поддерживаемым.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 346,
  "fields": {
    "question": "Можно ли использовать итераторы для создания генератора?",
    "answer": "Да, итераторы могут быть использованы для создания генераторов. Генератор - это специальный тип итератора, который обычно создается с помощью ключевых слов yield или yield from. Пример:\n\n```python\ndef my_generator():\n    for i in range(10):\n        yield i\n\ngen = my_generator()\nfor i in gen:\n    print(i)\n```\n\nЭтот код создает функцию-генератор my_generator, которая итерируется по диапазону от 0 до 9 и возвращает каждое значение с помощью yield. Затем он создает экземпляр генератора и использует его в цикле for, чтобы вывести каждое значение.\n\nГенераторы создаются с помощью функций и возвращают итераторы, которые могут быть использованы для итерации по значениям возвращаемым генератором.\n\nТаким образом, итераторы и генераторы - это связанные понятия в Python, и вы можете использовать итераторы для создания генераторов.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 347,
  "fields": {
    "question": "Что такое итераторы и генераторы?",
    "answer": "Итератор - это объект, который позволяет итерироваться (проходить) по другому объекту (например, коллекции) и получать его значения по одному. Для создания итератора нужно реализовать методы **iter**() и **next**() в соответствующем классе.\n\nГенератор - это специальная форма итератора, которая может быть создана с помощью ключевого слова yield. Генераторы позволяют создавать последовательности значений без необходимости хранения всех значений в памяти одновременно, что делает их полезными для работы с большими данными, такими как файлы или потоки сетевого ввода-вывода.\n\nВот примеры создания итератора и генератора:\n\n```python\n# Пример итератора\nclass MyIterator:\n    def __init__(self, iterable):\n        self.index = 0\n        self.iterable = iterable\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.index >= len(self.iterable):\n            raise StopIteration\n        value = self.iterable[self.index]\n        self.index += 1\n        return value\n\n# Пример генератора\ndef my_generator(iterable):\n    for item in iterable:\n        yield item\n```\n\nЭти примеры можно использовать следующим образом:\n\n```python\n# Использование итератора\nmy_list = [1, 2, 3]\nmy_iterator = MyIterator(my_list)\nfor item in my_iterator:\n    print(item)\n\n# Использование генератора\nmy_list = [1, 2, 3]\nmy_generator = my_generator(my_list)\nfor item in my_generator:\n    print(item)\n```\n\nВ первом примере мы создали класс MyIterator, который реализует методы **iter**() и **next**(). Во втором примере мы определили функцию, используя ключевое слово yield.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 348,
  "fields": {
    "question": "Что такое Method Resolution Order?",
    "answer": "python Что такое Method Resolution Order (MRO)?\nMethod Resolution Order (MRO) — это порядок, в котором интерпретатор ищет методы при множественном наследовании. MRO описывает, как Python разрешает методы, вызываемые по наследству. Он определяет порядок, в котором функции и методы с одинаковыми именами в базовых классах располагаются при поиске.\n\nПо умолчанию Python использует алгоритм C3 линеаризации, чтобы вычислить MRO. Этот алгоритм гарантирует, что при следовании MRO будут учитываться все исходные порядки, сохраняя при этом их локальный порядок.\n\nMRO является важной концепцией множественного наследования в Python, и его понимание необходимо для эффективного использования этого языка.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 349,
  "fields": {
    "question": "В чем разница между методами append() и extend()?",
    "answer": "Метод append() используется в Python для добавления нового элемента в конец списка. Например:\n\n```python\nmylist = [1, 2, 3]\nmylist.append(4)\nprint(mylist) # [1, 2, 3, 4]\n```\n\nС другой стороны, метод extend() используется для объединения двух списков. Он добавляет каждый элемент второго списка в конец первого списка. Например:\n\n```python\nmylist1 = [1, 2, 3]\nmylist2 = [4, 5, 6]\nmylist1.extend(mylist2)\nprint(mylist1) # [1, 2, 3, 4, 5, 6]\n```\n\nМожно также использовать оператор + для объединения двух списков:\n\n```python\nmy_list = [1, 2, 3]\nother_list = [4, 5, 6]\nnew_list = my_list + other_list\nprint(new_list) # [1, 2, 3, 4, 5, 6]\n```\n\nТаким образом, разница между методами append() и extend() заключается в том, что append() добавляет новый элемент в конец списка, а extend() добавляет содержимое другого списка в конец первого списка.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 350,
  "fields": {
    "question": "Как вы можете реализовать функциональное программирование и зачем?",
    "answer": "Вы можете реализовать функциональное программирование с помощью функций высшего порядка, замыканий и списковых включений. Функциональное программирование обычно используется для создания устойчивых и легко поддерживаемых программ, поскольку функции имеют строго определенные входные и выходные параметры и не имеют побочных эффектов, таких как изменения глобальных переменных или изменения состояния объектов.\n\nЗачем использовать функциональное программирование? Функциональный подход может помочь решить некоторые проблемы в программировании, такие как управление состоянием и улучшение модульности и повторного использования кода. Он также может ускорить процесс разработки благодаря своей простоте и высокому уровню абстракции.\n\nНапример, вот как можно использовать функциональный подход в Python:\n\n```python\n# Функция высшего порядка возвращает функцию, которая умножает число на заданный множитель\ndef multiply_by(multiplier):\n    def multiply(number):\n        return number * multiplier\n    return multiply\n\n# Создание объекта функции, который умножает число на 5\nmultiply_by_five = multiply_by(5)\n\n# Использование функции для умножения числа на 5\nresult = multiply_by_five(3)   # Результат: 15\n```\n\nЗдесь функция multiply_by() является функцией высшего порядка, которая принимает множитель и возвращает функцию multiply(), которая умножает число на множитель. Создание объекта функции multiply_by_five позволяет использовать ее для умножения любого числа на 5.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 351,
  "fields": {
    "question": "Объясните ctypes и зачем их использовать?",
    "answer": "Модуль ctypes в Python позволяет работать с библиотеками на C и использовать их функции и переменные в Python-скриптах. Он используется для доступа к существующим библиотекам на C и для создания оболочек Python для таких библиотек.\n\nС помощью ctypes можно использовать функции на C в Python, написав соответствующий прототип функции и указав, что она расположена в данной библиотеке. Также можно работать с переменными на C в Python, передавая указатель на переменную и определяя её тип.\n\nПреимущества использования ctypes заключаются в том, что это стандартный модуль Python и он не требует установки дополнительных библиотек. Он также позволяет использовать преимущества быстродействия кода на C.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 352,
  "fields": {
    "question": "Что такое множественное наследование и когда его следует использовать?",
    "answer": "Множественное наследование - это когда класс наследуется от нескольких базовых классов. Это означает, что класс-потомок получает свойства и методы от всех своих базовых классов.\n\nПример использования множественного наследования в Python:\n\n```python\nclass A:\n    def method_a(self):\n        print(\"Method A\")\n\nclass B:\n    def method_b(self):\n        print(\"Method B\")\n\nclass C(A, B):\n    def method_c(self):\n        print(\"Method C\")\n\nobj_c = C()\nobj_c.method_a()  # Output: Method A\nobj_c.method_b()  # Output: Method B\nobj_c.method_c()  # Output: Method C\n```\n\nВ этом примере классы A и B являются базовыми классами для класса C. Класс C получает свойства и методы от классов A и B, и может использовать их в своих собственных методах.\n\nМножественное наследование может быть полезно, когда вам нужно использовать свойства и методы из разных классов, чтобы создать новый класс с уникальным поведением. Однако, когда используется множественное наследование, может возникать проблема \"алмазного наследования\", когда два базовых класса оба имеют одноименный метод, что может привести к неоднозначности и ошибкам в коде.\n\nЕсли такая проблема возникает, то рекомендуется пользоваться композицией вместо множественного наследования. Композиция - это когда вы создаете класс, включающий в себя другие классы в качестве своих атрибутов. Для примера, класс может иметь атрибут объекта класса вместо наследования от этого класса.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 2,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 353,
  "fields": {
    "question": "Что такое метакласс?",
    "answer": "Метакласс в Python - это класс, который определяет поведение других классов. Когда мы определяем класс, интерпретатор Python использует метакласс (по умолчанию - type) для создания этого класса. Метаклассы позволяют изменять поведение классов и их экземпляров, а также добавлять свои собственные методы и атрибуты.\n\nВот пример метакласса, который добавляет метод custom_method() в класс MyClass:\n\n```python\nclass MyMeta(type):\n    def __new__(cls, name, bases, dct):\n        dct['custom_method'] = lambda self: print('Hello, world!')\n        return super().__new__(cls, name, bases, dct)\n\nclass MyClass(metaclass=MyMeta):\n    pass\n\nobj = MyClass()\nobj.custom_method()   # output: Hello, world!\n```\n\nВ этом примере MyMeta является метаклассом , который добавляет метод custom_method() в класс MyClass. Затем мы создаем экземпляр MyClass и вызываем добавленный метод на этом экземпляре, выводя строку \"Hello, world!\".\n\nЕще один пример использования метаклассов - это создание синглтона, когда мы хотим, чтобы у нас был только один экземпляр класса:\n\n```python\nclass Singleton(type):\n    _instances = {}\n\n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super().__call__(*args, **kwargs)\n        return cls._instances[cls]\n\nclass MyClass(metaclass=Singleton):\n    pass\n\na = MyClass()\nb = MyClass()\n\nprint(a is b)   # output: True\n```\n\nВ этом примере Singleton является метаклассом , который гарантирует, что у нас будет только один экземпляр класса MyClass благодаря словарю \\_instances. Когда мы создаем",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 354,
  "fields": {
    "question": "Что такое свойства и в чем смысл?",
    "answer": "В Python свойства — это способ управления доступом к атрибутам класса. Они позволяют вам определять методы получения и установки, которые вызываются автоматически при доступе к атрибуту или его изменении. Смысл использования свойств состоит в том, чтобы обеспечить контролируемый доступ к данным класса и их изменение.\n\nСвойства могут помочь вам предотвратить ошибки, обеспечить соблюдение ограничений и добавить дополнительную проверку или вычисление в процесс доступа или изменения атрибута.\n\nНапример, вы можете использовать свойство, чтобы убедиться, что атрибут класса всегда положительный, или чтобы гарантировать, что строковый атрибут всегда пишется с заглавной буквы. Используя свойства для принудительного применения таких ограничений, вы можете упростить свой код и снизить вероятность ошибок программирования.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 355,
  "fields": {
    "question": "Что такое строка Юникода?",
    "answer": "Строка юникода в Python - это объект строки, который использует стандарт Юникода для представления символов. Это позволяет работать с текстом, содержащим символы различных языков, кодировок и символьных наборов.\n\nСтроки в Python по умолчанию используют кодировку Unicode, и знание этого стандарта является необходимым для эффективной работы с текстом в Python.\n\nВ Python 3 все текстовые строки (тип str) представляются в Unicode, а в Python 2 для работы с Unicode необходимо использовать отдельный тип unicode.\n\nДля работы со строками в Unicode в Python используются различные функции и методы, такие как кодирование и декодирование строк, получение символов по их кодам в юникоде и многое другое.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 356,
  "fields": {
    "question": "Что делает оператор yield?",
    "answer": "Оператор yield в Python используется для создания генераторов — объектов, которые лениво генерируют последовательность значений. Он приостанавливает выполнение функции-генератора и возвращает значение, как будто функция завершена. Тем не менее, контекст выполнения сохраняется, и при следующем вызове функции выполнение продолжится с того же места, где оно было остановлено, а не с начала. Кроме того, функция-генератор может получать значения от вызывающей программы при помощи оператора send(value). Пример:\n\n```python\ndef generate_numbers(start, end):\n    while start <= end:\n        yield start\n        start += 1\n\nnumbers = generate_numbers(1, 5)\nfor number in numbers:\n    print(number)\n```\n\nЭтот код создаст генератор, который будет выдавать числа от 1 до 5 включительно. Как только в цикле for будет запрошено следующее значение, выполнение функции-генератора продолжится с того момента, где оно было приостановлено.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 357,
  "fields": {
    "question": "Что такое полиморфизм и когда его использовать?",
    "answer": "Полиморфизм в объектно-ориентированном программировании (ООП) - это возможность обработки объектов разных классов с помощью общих методов. В Python полиморфизм можно реализовать с помощью множественного наследования и переопределения методов родительских классов в дочерних классах. Это позволяет использовать один и тот же метод с разными объектами разных классов.\n\nВот несколько примеров полиморфизма в Python:\n\n- Метод len(), который можно использовать для получения длины любой последовательности, например, списка или строки:\n\n```python\nmy_list = [1, 2, 3, 4, 5]\nmy_string = \"Hello, world!\"\nprint(len(my_list))     # выводит 5\nprint(len(my_string))   # выводит 13\n```\n\n- Метод +, который может использоваться для объединения разных типов объектов, например, строк и чисел:\n\n```python\nmy_string = \"Hello, \"\nmy_name = \"John\"\nmy_number = 42\nprint(my_string + my_name)   # выводит \"Hello, John\"\nprint(my_number + 10)        # выводит 52\n```\n\n- Функция isinstance(), которая позволяет проверять, принадлежит ли объект определенному классу. Например:\n\n```python\nmy_list = [1, 2, 3, 4, 5]\nif isinstance(my_list, list):\n    print(\"This is a list\")\n```\n\nЭто объясняет, что такое полиморфизм и как его использовать в Python.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 358,
  "fields": {
    "question": "Как вы упаковываете код Python?",
    "answer": "Существует несколько способов упаковки кода Python, включая использование модулей, сборщиков и инструментов для создания исполняемых файлов. Ниже перечислены некоторые из них:\n\n- Использование модулей: вы можете создать модуль, содержащий свой код, и импортировать его в другие программы. Это позволяет вам организовать свой код в более логические блоки и повторно использовать его в других проектах.\n\n- Использование сборщиков: существуют различные сборщики для Python, которые позволяют объединить весь ваш код и его зависимости в один пакет, который можно легко установить и использовать на других компьютерах. Некоторые из наиболее популярных сборщиков включают в себя setuptools, py2exe и PyInstaller.\n\n- Создание исполняемого файла: Вы можете использовать инструменты, такие как Nuitka или cx_Freeze для создания исполняемого файла, который позволяет запустить вашу программу без необходимости установки Python на компьютере пользователя.\n\n- Использование контейнеров: вы можете использовать контейнеры, такие как Docker, для упаковки вашего Python-приложения вместе с его зависимостями и запуска его на любой платформе, где работает Docker.\n\nВыбор конкретного метода упаковки зависит от ваших потребностей и требований вашего проекта.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 359,
  "fields": {
    "question": "Компилируется ли Python? Если да, то как, если нет, то как.",
    "answer": "Python - это интерпретируемый язык программирования, что означает, что код Python не компилируется в машинный язык, а вместо этого выполняется непосредственно интерпретатором Python во время исполнения программы.\n\nОднако существует несколько инструментов, которые могут быть использованы для создания исполняемых файлов из кода Python, например, PyInstaller и cx_Freeze. Эти инструменты упаковывают код Python и все его зависимости в один исполняемый файл, который можно запустить на целевой платформе без необходимости установки интерпретатора Python на этой платформе.\n\nТаким образом, можно сказать, что Python не компилируется, но может быть упакован в исполняемый файл с помощью сторонних инструментов.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 360,
  "fields": {
    "question": "Что означает **some-variable** ?",
    "answer": "Двойное подчеркивание перед и после имени переменной в Python называется \"dunder\" (Double underscore) и используется для специальных методов и атрибутов, которые могут быть вызваны автоматически. Например, **init** - это специальный метод, который вызывается при создании экземпляра класса. Другие примеры включают **str**, **len**, **call**, **iter**, и так далее.\n\nТакже могут использоваться \"dunder\" атрибуты, такие как **name**, **module**, **doc**, **file**, **dict**, **class**, **all** и другие, которые предоставляют информацию о модуле, классе, функции или другом объекте.\n\nЗначение, которое присваивается такой переменной, зависит от контекста использования. Например, **name** - это специальный атрибут, который содержит имя текущего модуля.\n\nОбычно используйте двойное подчеркивание только для специальных методов и атрибутов, которые имеют специальный смысл в языке Python, и не используйте такие имена для своих собственных переменных, чтобы избежать конфликтов и неожиданного поведения",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 361,
  "fields": {
    "question": "Должен ли я импортировать весь модуль?",
    "answer": "Можно импортировать только нужные функции из модуля, используя синтаксис from module import function. Например, для импорта только функции sqrt из модуля math, необходимо написать:\n\n```python\nfrom math import sqrt\n```\n\nЕсли вам нужно использовать несколько функций из модуля, можно перечислить их через запятую:\n\n```python\nfrom math import sqrt, sin, cos\n```\n\nЕсли вы хотите импортировать весь модуль, можно использовать синтаксис import module. Это импортирует весь модуль и дает доступ ко всем его элементам через пространство имен модуля. Например, для импорта модуля math:\n\n```python\nimport math\n```\n\nЗатем, чтобы использовать его функции, нужно указывать имя модуля перед именем функции:\n\n```python\nx = math.sqrt(25)\n```\n\nМожно также использовать псевдоним для модуля, чтобы сделать имя более коротким. Например:\n\n```python\nimport math as m\nx = m.sqrt(25)\n```\n\nПараметр \"as\" позволяет задать псевдоним для импортированного модуля. В данном случае, был задан псевдоним m, вместо полного имени модуля math.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 362,
  "fields": {
    "question": "Что означает dynamicly/duck тип?",
    "answer": "В языках программирования термины «динамически типизированный» и «утиный тип» часто используются взаимозаменяемо для описания системы типов, в которой переменным не присваивается конкретный тип во время компиляции, а тип определяется во время выполнения на основе присвоенного значения. к переменной. Другими словами, тип переменной может динамически изменяться во время выполнения программы. Это отличается от статически типизированных языков, которые требуют, чтобы переменные были явно объявлены с определенным типом во время компиляции, и тип не может быть изменен во время выполнения. Термин «утиная типизация» специально подчеркивает идею о том, что если объект ведет себя как определенный тип (или «ходит как утка и крякает как утка»), то его можно рассматривать как этот тип, независимо от его фактического типа. Это означает, что код можно оптимизировать для совместимости со многими различными типами объектов, если эти объекты поддерживают те же операции, что и тип. что код ожидает.\n\nPython — это язык с динамической типизацией, который использует утиную типизацию 12, что означает, что тип переменной определяется во время выполнения на основе значения, которое она содержит, а объекты рассматриваются как принадлежащие к определенному типу на основе их поведения, а не их фактического типа. .",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 363,
  "fields": {
    "question": "Когда я не буду использовать Python?",
    "answer": "Python — это универсальный язык, который можно использовать в самых разных областях. Однако есть определенные ситуации, когда Python может быть не лучшим выбором. Вот несколько сценариев, в которых вы можете рассмотреть возможность использования другого языка:\n\n- Высокопроизводительные вычисления. Хотя Python известен своей простотой использования и удобочитаемостью, он может быть не лучшим выбором для высокопроизводительных вычислений, таких как научные вычисления или машинное обучение. В этих случаях лучшим вариантом могут быть такие языки, как C++ или Julia.\n\n- Разработка мобильных приложений. Хотя с помощью Python можно разрабатывать мобильные приложения, это не самый популярный язык для этой области. Вместо этого более популярны такие языки, как Java (для Android) или Swift (для iOS).\n\n- Системы реального времени: Python — это интерпретируемый язык, а это означает, что его выполнение обычно медленнее, чем в скомпилированных языках. Это может быть недостатком, если вы разрабатываете системы реального времени, которые требуют очень быстрых и точных ответов.\n\n- Низкий уровень программирования: если вам нужно взаимодействовать с оборудованием или писать низкоуровневый код, такой как драйверы устройств, Python может быть не лучшим выбором. Вместо этого для этих задач лучше подходят такие языки, как C или Rust.\n\n- Браузерные приложения. Хотя Python можно использовать в веб-разработке, он не так хорошо подходит для браузерных приложений, как такие языки, как JavaScript, который является основным языком Интернета.\n\nОбратите внимание, что это всего лишь несколько сценариев, в которых Python может быть не лучшим выбором, и могут быть другие факторы, характерные для вашего проекта, которые делают другой язык более подходящим.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 364,
  "fields": {
    "question": "Что такое DRY, как я могу применить его через ООП или FP?",
    "answer": "DRY - это принцип разработки, который означает \"Don't Repeat Yourself\" (не повторяйся). В контексте программирования, DRY означает, что любой фрагмент кода должен иметь только один источник истины, и он должен быть легко доступен и изменяем. Это уменьшает количество дублирующегося кода и упрощает процесс сопровождения и изменения кода.\n\nЧерез ООП или ФП, можно применять принцип DRY следующим образом:\n\nООП: используйте наследование, полиморфизм и абстракцию для организации кода. Вынесите общие методы и свойства в родительские классы, а для каждого подкласса определите только те функции, которые отличают его от других.\n\nФП: используйте функции высшего порядка, замыкания и лямбда-выражения. Выносите общие функции в модули или библиотеки, и переиспользуйте их при необходимости.\n\nВот пример того, как ООП можно использовать для применения принципов DRY:\n\n```python\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def introduce(self):\n        print(f\"My name is {self.name} and I am {self.age} years old.\")\n\nclass Student(Person):\n    def __init__(self, name, age, major):\n        super().__init__(name, age)\n        self.major = major\n\n    def introduce(self):\n        super().introduce()\n        print(f\"I am majoring in {self.major}.\")\n\nclass Teacher(Person):\n    def __init__(self, name, age, department):\n        super().__init__(name, age)\n        self.department = department\n\n    def introduce(self):\n        super().introduce()\n        print(f\"I teach in the {self.department} department.\")\n\n```\n\nКласс Person содержит общие атрибуты и поведение для всех людей в системе. Классы Student и Teacher наследуют от Person и добавляют свои определенные атрибуты и поведение. Таким образом, мы избегаем дублирования кода таких атрибутов, как имя и возраст, или таких методов, как внедрение.\n\nИспользуя ООП и наследование, мы можем эффективно применять принципы DRY и сделать код более удобным в сопровождении и расширяемым. Точно так же вы можете использовать функции и композицию более высокого порядка в FP для достижения тех же целей.",
    "category": 6,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 365,
  "fields": {
    "question": "Когда я буду использовать Python?",
    "answer": "Вы можете использовать Python во многих различных сферах, включая:\n\n- Научные исследования, включая обработку данных и машинное обучение\n\n- Создание веб-приложений с использованием фреймворков, таких как Django и Flask\n\n- Разработка программного обеспечения для администрирования систем и автоматизации задач\n\n- Создание игр с использованием библиотек, таких как Pygame\n\n- Разработка десктопных приложений с использованием фреймворков, таких как PyQt и Tkinter\n\n- Создание скриптов для автоматизации задач и обработки данных.\n\nКроме того, Python является одним из самых популярных языков программирования и предлагает широкий спектр библиотек и инструментов, делая его полезным для многих проектов.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 366,
  "fields": {
    "question": "Приведите примеры Python Framework?",
    "answer": "Некоторые популярные Python фреймворки:\n\n- Django - это высокоуровневый веб-фреймворк с отличной документацией и многочисленными плагинами. Он используется для создания крупных веб-приложений и имеет набор готовых модулей и инструментов, которые облегчают создание приложения.\n\n- Flask - это микро-фреймворк, который полностью опирается на ядро Python. Он дает разработчикам свободу выбора инструментов и библиотек, которые они хотят использовать, и не навязывает им предпочтительных способов организации кода.\n\n- Pyramid - это универсальный фреймворк для создания веб-приложений. Он позволяет создавать приложения любой сложности и может быть использован для различных видов проектов, от маленьких экспериментов до огромных корпоративных приложений.\n\n- Bottle - это легковесный фреймворк, который сосредоточен на быстрой и простой разработке. С его помощью можно быстро создать простое приложение в несколько строк кода.\n\n- CherryPy - это фреймворк, который используется для создания сетевых приложений. Он просто в использовании и включает в себя различные возможности, такие как встроенный веб-сервер и поддержку работы с AJAX.\n\nЭто лишь несколько примеров Python фреймворков из множества доступных в Python.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 367,
  "fields": {
    "question": "Как интерпретируется Python.",
    "answer": "Python обычно считается интерпретируемым языком, что означает, что он не компилируется перед выполнением. Вместо этого интерпретатор Python считывает и компилирует каждую строку кода одну за другой во время выполнения.\n\nИсходный код сначала транслируется в промежуточный байт-код, который затем выполняется виртуальной машиной Python. Этот процесс позволяет легко запускать код Python на нескольких платформах без необходимости использования каких-либо дополнительных инструментов или компиляторов. Тем не менее, в этом процессе присутствует некоторый уровень компиляции.\n\nИнтерпретатор Python сначала считывает и оптимизирует код, написанный человеком, в некую промежуточную форму, прежде чем интерпретировать его в машинный код. Кроме того, методы компиляции Just-In-Time (JIT), используемые некоторыми реализациями Python, такими как PyPy, могут компилировать код налету для повышения производительности.\n\nТаким образом, Python — это в первую очередь интерпретируемый язык с некоторой компиляцией, связанной с процессом. Интерпретатор читает код и выполняет необходимые действия. оптимизация и переводы во время выполнения для выполнения программы.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 368,
  "fields": {
    "question": "Объясните dict().",
    "answer": "Для создания словаря в Python используется встроенный класс dict. Словарь представляет собой неупорядоченный набор пар ключ-значение, где каждый ключ должен быть уникальным. Ключами могут быть объекты любого неизменяемого типа данных (например, числа, строки, кортежи), а значения могут быть любого типа данных (числа, строки, списки, другие словари и т.д.). Словарь можно создать с помощью литерала {} или встроенной функции dict(). Примеры:\n\n```python\n# Создание словаря с помощью литерала\nmy_dict = {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}\n\n# Создание словаря с помощью функции dict()\nmy_dict = dict(key1='value1', key2='value2', key3='value3')\n```\n\nЧтение и запись элементов в словарь осуществляется по ключу с помощью оператора []. Примеры:\n\n```python\n# Чтение элемента по ключу\nvalue = my_dict['key1']\n\n# Запись элемента по ключу\nmy_dict['key4'] = 'value4'\n```\n\nТакже для работы со словарем в Python есть множество встроенных методов и функций, таких как keys(), values(), items(), get(), pop(), update() и многие другие.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 369,
  "fields": {
    "question": "Как передавать необязательные или ключевые аргументы.",
    "answer": "Для передачи необязательных аргументов в Python используются \\*args и \\*\\*kwargs.\n\n\\*args - это список неименованных аргументов, которые могут быть переданы в функцию. Они собираются в кортеж.\n\n\\*\\*kwargs - это словарь именованных аргументов, которые могут быть переданы в функцию. Имена аргументов и их значения указываются в форме ключевых слов.\n\nВот пример использования \\*args и \\*\\*kwargs в Python:\n\n```python\ndef my_function(*args, **kwargs):\n    # Работа с неименованными аргументами (args)\n    for arg in args:\n        print(arg)\n\n    # Работа с именованными аргументами (kwargs)\n    for key, value in kwargs.items():\n        print(f\"{key} = {value}\")\n\n# Вызов функции с неименованными аргументами\nmy_function('Hello', 'world', '!')\n\n# Вызов функции с именованными аргументами\nmy_function(first_name='John', last_name='Doe', age=30)\n```\n\nВ первом вызове функции передаются неименованные аргументы \"Hello\", \"world\" и \"!\".\n\nВо втором вызове функции передаются именованные аргументы first_name, last_name и age.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 370,
  "fields": {
    "question": "Объясните индексацию и срез.",
    "answer": "Индексация и срезы в Python позволяют получать доступ к конкретным элементам или подстрокам в строке, списке или другом итерируемом объекте.\n\nИндексация используется для получения одного элемента из объекта с помощью его индекса. Индексация начинается с нуля для первого элемента и увеличивается на единицу для каждого последующего элемента. Чтобы получить элемент с индексом i из объекта obj, вы можете использовать выражение obj[i].\n\nСрезы позволяют получать подстроку или подсписок из объекта. Срезы имеют три параметра: начальный индекс, конечный индекс и шаг. Начальный индекс указывает, с какого индекса начинать, конечный индекс указывает, на каком индексе закончить, а шаг указывает, какие элементы пропустить между начальным и конечным индексами. Вы можете использовать выражение obj[start:end:step], чтобы получить срез объекта от индекса start до индекса end-1 с шагом step.\n\nПримеры:\n\n```python\ns = 'Hello, World!'\nprint(s[0])     # output: 'H'\nprint(s[7])     # output: 'W'\nprint(s[-1])    # output: '!'\nprint(s[0:5])   # output: 'Hello'\nprint(s[:5])    # output: 'Hello'\nprint(s[7:])    # output: 'World!'\nprint(s[::2])   # output: 'Hlo ol!'\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 371,
  "fields": {
    "question": "Разница между str() и repr().",
    "answer": "str() и repr() — это встроенные в Python функции, которые можно использовать для получения строковых представлений объекта, но разница между ними заключается в контексте, в котором они используются.\n\n- str(obj) используется для получения печатного строкового представления объекта, которое обычно предназначено для удобочитаемости. Он обычно используется, когда код пытается вывести что-то на консоль или в файл, или когда он преобразует объект в строку для целей отображения.\n- repr(obj) используется для получения «официального» строкового представления объекта, которое в идеале должно быть действительным кодом Python, который можно использовать для воссоздания объекта. Он обычно используется в сценариях отладки или когда код пытается отобразить строку, представляющую объект таким образом, который более точно отражает его внутреннюю структуру.\n\nОсновное различие между str() и repr() заключается в том, что str() возвращает человекочитаемое представление объекта в виде строки, а repr() возвращает представление объекта в виде строки, которое может быть использовано для создания копии объекта или его точного воссоздания.\n\nОбычно используется str() для вывода строки на экран или в файл, а repr() для отладки или вывода информации о типе и значении объекта.\n\nНапример:\n\n```python\nclass Example:\n    def __init__(self):\n        self.value = 42\n    def __repr__(self):\n        return 'Example(' + str(self.value) + ')'\n    def __str__(self):\n        return 'The value is ' + str(self.value)\n\ne = Example()\n\nprint(str(e))   # \"The value is 42\"\nprint(repr(e))  # \"Example(42)\"\n```\n\nВ этом примере мы определили класс Example, имеющий реализацию методов **str**() и **repr**(). Вызов str(e) возвращает \"The value is 42\", тогда как repr(e) возвращает \"Example(42)\".\n\nЕсли метод **str**() не определен в классе, то будет использоваться метод **repr**(). Если метод **repr**() не определен, будет выводиться строковое представление по умолчанию для данного класса, которое не всегда будет информативным.\n\nНапример, если определить класс без методов **str**() и **repr**():\n\n```python\nclass Example2:\n    def __init__(self):\n        self.value = 42\n\ne = Example2()\n\nprint(str(e))   # \"<__main__.Example2 object at 0x7f8aadd16c10>\"\nprint(repr(e))  # \"<__main__.Example2 object at 0x7f8aadd16c10>\"\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 372,
  "fields": {
    "question": "Что такое динамическая типизация?",
    "answer": "Динамическая типизация - это свойство языка Python, которое позволяет изменять тип переменной во время выполнения программы. То есть, в отличие от языков Java или C++, где тип переменной определяется в момент ее объявления и не может быть изменен в процессе выполнения программы, в Python тип переменной может быть изменен на любой другой тип в любой момент времени.\n\nНапример, вы можете объявить переменную x как целое число (int) и затем изменить ее на строку (str), если это необходимо:\n\n```python\nx = 5\nx = \"Hello\"\n```\n\nДля определения типа переменной в Python можно использовать функцию type():\n\n```python\nx = 5\nprint(type(x)) # <class 'int'>\n\nx = \"Hello\"\nprint(type(x)) # <class 'str'>\n```\n\nЭто свойство динамической типизации Python позволяет писать более гибкий и более экономичный код, так как не требуется жесткое определение типов для каждой переменной в программе.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 373,
  "fields": {
    "question": "Обоснуйте это утверждение: в Python все является объектом?",
    "answer": "В Python все, включая переменные, функции, модули, даже базовые типы данных (например, числа, строки, списки и т.д.), являются объектами. Это означает, что они имеют определенный тип, атрибуты и методы, которые можно вызывать на этих объектах. Python является объектно-ориентированным языком программирования, где объекты используются для представления всех структур данных и функциональных возможностей языка. Таким образом, все в Python является объектом, что позволяет гибко использовать их в программировании.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 374,
  "fields": {
    "question": "Что такое промежуточное программное обеспечение?",
    "answer": "В Python промежуточное программное обеспечение — это класс или функция, которая перехватывает, обрабатывает или изменяет HTTP-запрос или ответ до того, как он будет отправлен или получен веб-приложением. ПО промежуточного слоя может выполнять множество задач, таких как ведение журнала, проверка подлинности, ограничение скорости или изменение заголовков ответа. В популярных веб-фреймворках Python, таких как Django или Flask, промежуточное ПО реализовано в виде серии классов, которые регистрируются в приложении и выполняются в определенном порядке при получении запроса. Это позволяет объединять ПО промежуточного слоя в цепочку для выполнения сложных операций или изменения запроса или ответа по мере его прохождения через цикл запроса/ответа приложения. Промежуточное ПО — это мощный инструмент для настройки поведения веб-приложений, который можно использовать для реализации широкого спектра функций.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 375,
  "fields": {
    "question": "Какая польза от enumerate() в Python?",
    "answer": "Функция enumerate() в Python применяется для итерирования по последовательности (например, списку) и возвращения пары значений: индекса текущего элемента и самого элемента. Это позволяет упростить код для итерации по элементам, особенно если вам нужно сохранить не только значение элемента, но также его индекс в последовательности.\n\nПреимущество использования enumerate() заключается в том, что вы не нуждаетесь в дополнительной переменной для отслеживания индексов элементов в списке. Вместо этого вы можете использовать enumerate() для одновременного перебора элементов и соответствующих индексов. Это может существенно сократить количество написанного кода\n\nНапример:\n\n```python\nmy_list = ['apple', 'banana', 'orange']\nfor index, value in enumerate(my_list):\n    print(f'The value {value} is at index {index}')\nЭто выведет следующее:\n\nThe value apple is at index 0\nThe value banana is at index 1\nThe value orange is at index 2\n```\n\nТаким образом, enumerate() упрощает сопоставление значений и соответствующих индексов в последовательности, что делает код более читаемым и понятным.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 376,
  "fields": {
    "question": "Что такое сжатие списка/словаря.",
    "answer": "Сжатие списков и словарей — это функция синтаксиса Python, которая позволяет создавать списки и словари в сжатой и удобочитаемой форме.\n\nСжатие списков позволяет создавать новый список путем фильтрации и преобразования данного итерируемого объекта. Вот пример сжатие списка, который создает новый список чисел в квадрате из существующего списка:\n\n```python\nnumbers = [1, 2, 3, 4, 5]\nsquared_numbers = [num**2 for num in numbers]\n```\n\nСжатие словаря работает аналогично, но позволяет вам создать новый словарь из итерируемого объекта, указав пары ключ-значение. Вот пример понимания словаря, который создает новый словарь ключей и значений в верхнем регистре:\n\n```python\noriginal_dict = {'apple': 'red', 'banana': 'yellow', 'grape': 'purple'}\nnew_dict = {key.upper(): value.upper() for key, value in original_dict.items()}\n```\n\nВ обоих случаях код значительно короче и читабельнее, чем при использовании традиционных циклов for для создания того же вывода. В целом, сжатие списков и словарей — это мощные инструменты, которые позволяют создавать краткий и удобочитаемый код Python.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 377,
  "fields": {
    "question": "Как сделать массив в Python?",
    "answer": "Чтобы создать список (массив) в Python, вы можете использовать квадратные скобки и разделять элементы запятыми. Примеры:\n\nСоздание пустого списка:\n\n```python\nmy_list = []\n```\n\nСоздание списка с несколькими элементами:\n\n```python\nmy_list = [1, 2, 3, \"строка\", True]\n```\n\nВы можете получить доступ к элементам списка по их индексу, начиная с 0. Пример:\n\n```python\nmy_list = [1, 2, 3, \"строка\", True]\nprint(my_list[3])  # выводит \"строка\"\n```\n\nТакже вы можете изменять элементы списка по их индексу:\n\n```python\nmy_list = [1, 2, 3, \"строка\", True]\nmy_list[1] = 5\nprint(my_list)  # выводит [1, 5, 3, \"строка\", True]\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 378,
  "fields": {
    "question": "Как генерировать случайные числа?",
    "answer": "Для генерации случайных чисел можно использовать модуль random. Есть несколько функций для генерации случайных чисел:\n\n- random.random() - генерирует случайное число от 0 до 1.\n\n- random.randint(a, b) - генерирует случайное целое число в диапазоне от a до b включительно.\n\n- random.uniform(a, b) - генерирует случайное число с плавающей точкой в диапазоне от a до b.\n\n- random.choice(sequence) - выбирает случайный элемент из заданной последовательности.\n\nДля использования модуля random нужно его импортировать с помощью команды import random. Вот примеры использования:\n\n```python\nimport random\n\n# Генерирование случайного целого числа в диапазоне от 0 до 100\nrandom_number = random.randint(0, 100)\nprint(random_number)\n\n# Генерирование случайного числа с плавающей точкой в диапазоне от 0 до 1\nrandom_float = random.random()\nprint(random_float)\n\n# Выбор случайного элемента из списка\nmy_list = [\"apple\", \"banana\", \"cherry\"]\nrandom_element = random.choice(my_list)\nprint(random_element)\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 379,
  "fields": {
    "question": "Как обрабатывать исключения?",
    "answer": "Исключения обрабатываются с помощью конструкции try - except. Вы можете поместить блок кода, который может вызвать ошибку (исключение), в конструкцию try. В блок except вы можете поместить код, который должен быть выполнен, если произошло исключение.\n\n```python\ntry:\n  # некоторый код, который может вызвать исключение\nexcept SomeException:\n  # код для обработки исключения\nexcept AnotherException:\n  # код для обработки другого исключения\nelse:\n  # код, который будет выполняться, если в блоке try не возникло никаких исключений\nfinally:\n  # код, который будет выполняться несмотря ни на что\n```\n\nexcept может иметь несколько блоков, чтобы обрабатывать различные типы исключений. Вы также можете добавить блок else, который будет выполнен только в том случае, если исключение не было вызвано. Блок finally содержит код, который будет выполнен независимо от того, произошло исключение или нет.\n\nВот исходный код, который показывает пример использования конструкции try - except:\n\n```python\ntry:\n    x = int(input(\"Введите число: \"))\n    y = 1 / x\nexcept ZeroDivisionError:\n    print(\"На ноль делить нельзя!\")\nexcept ValueError:\n    print(\"Вы ввели не число!\")\nelse:\n    print(\"Результат: \", y)\nfinally:\n    print(\"Конец программы\")\n```\n\nВ этом примере, если пользователь вводит 0 в качестве значения, мы получим сообщение \"На ноль делить нельзя!\", а если он вводит нечисловое значение, мы получим сообщение \"Вы ввели не число!\". Если пользователь вводит числовое значение, которое не равно 0, мы получаем результат деления и выводим его вместе с сообщением \"Результат: \". Наконец, блок finally всегда выполняется и выводит \"Конец программы\".",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 380,
  "fields": {
    "question": "Иерархия исключений Python?",
    "answer": "В Python все исключения являются экземплярами класса, производного от класса BaseException. В Python есть встроенная иерархия исключений, которая позволяет вам перехватывать определенные типы исключений. Вот неполный список некоторых классов исключений в Python, перечисленных в соответствии с их иерархией наследования:\n\n```\nBaseException\n +-- SystemExit\n +-- KeyboardInterrupt\n +-- Exception\n      +-- StopIteration\n      +-- ArithmeticError\n      |    +-- ZeroDivisionError\n      +-- AssertionError\n      +-- AttributeError\n      +-- BufferError\n      +-- EOFError\n      +-- ImportError\n      +-- LookupError\n      |    +-- IndexError\n      |    +-- KeyError\n      +-- NameError\n      |    +-- UnboundLocalError\n      +-- OSError\n      |    +-- FileNotFoundError\n      +-- ReferenceError\n      +-- RuntimeError\n      |    +-- NotImplementedError\n      +-- SyntaxError\n      +-- IndentationError\n           +-- TabError\n\n```\n\nЭто не исчерпывающий список всех встроенных классов исключений, но он охватывает некоторые важные. При обработке исключений с помощью блока try-except можно перехватить несколько исключений, указав кортеж классов исключений после ключевого слова exclude. Например:\n\n```python\ntry:\n    # некоторый код, который может вызывать различные исключения\nexcept (ValueError, TypeError):\n    # обрабатывать ValueError или TypeError\nexcept OSError as e:\n    # обрабатывать OSError, используя ключевое слово as, чтобы получить экземпляр исключения\nexcept:\n    # обрабатывать любое другое исключение\n```\n\nВы также можете создавать свои собственные классы исключений, создавая подклассы любого существующего класса исключений или самого класса BaseException.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 381,
  "fields": {
    "question": "Когда использовать list/tuple/set/dict?",
    "answer": "list, tuple, set и dict — все это структуры данных в Python, которые служат разным целям. Вот несколько общих рекомендаций о том, когда использовать каждый из них:\n\n- Используйте список, если у вас есть коллекция заказанных элементов, которые вам может потребоваться изменить или переупорядочить. Списки изменяемы, то есть вы можете добавлять или удалять элементы и изменять их значения.\n- Используйте кортеж, если у вас есть коллекция упорядоченных элементов, которые вы не хотите изменять. Кортежи неизменяемы, то есть вы не можете изменить их значения после их создания.\n- Используйте набор, когда у вас есть коллекция элементов, и вы хотите удалить дубликаты или выполнить над ними операции над наборами (пересечение, объединение, различие). Наборы изменяемы, как и списки.\n- Используйте словарь, когда у вас есть коллекция пар ключ-значение и вы хотите быстро найти значение на основе его ключа. Словари изменяемы, как и списки.\n\nЭто всего лишь общие рекомендации, и вам может потребоваться выбрать структуру данных на основе конкретных требования вашей программы. Кроме того, в Python есть и другие структуры данных (такие как deque и NamedTuple), которые в некоторых случаях могут оказаться более подходящими.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 382,
  "fields": {
    "question": "Что такое virtualenv?",
    "answer": "Virtualenv - это инструмент для создания изолированных Python-окружений, где каждое из окружений может иметь свои собственные установленные пакеты и зависимости. Это позволяет вам использовать различные версии Python и библиотек в разных проектах, не взаимодействуя друг с другом, и также создавать \"чистые\" окружения, где не установлены стандартные библиотеки, чтобы избежать конфликтов зависимостей. Вы можете активировать виртуальное окружение с помощью команды в командной строке, и когда оно активно, ваше приложение будет использовать только пакеты, установленные в данный момент в этом окружении.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 383,
  "fields": {
    "question": "Оператор `with` и его использование.",
    "answer": "Оператор with в Python используется для работы с контекстными менеджерами, которые обеспечивают выполнение операций до и после выполнения блока кода. Контекстный менеджер представляет собой объект с методами **enter** и **exit**, которые определяют выполнение операций при входе и выходе из блока кода.\n\nОсновной синтаксис оператора with выглядит следующим образом:\n\n```python\nwith <expr> as <var>:\n    <block>\n```\n\nЗдесь <expr> представляет собой выражение, возвращающее объект контекстного менеджера, <var> - переменную для хранения объекта менеджера, <block> - блок кода, в котром будет использоваться объект контекстного менеджера.\n\nПример использования with для работы с файлом:\n\n```python\nwith open('file.txt', 'r') as f:\n    data = f.read()\n    # сделать что-то с данными\n```\n\nЗдесь оператор with используется для автоматического закрытия файла после завершения чтения данных из него.\n\nКроме работы с файлами, оператор with также может быть использован для работы с сетевыми соединениями, блокировками для многопоточных приложений и другими объектами, поддерживающими протокол контекстного менеджера.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 384,
  "fields": {
    "question": "Что такое class и что такое self.",
    "answer": "Class - это структура данных, которая описывает состояние объекта и поведение объекта. Self - это способ обозначить экземпляр класса, который передается в методы класса и позволяет методам работать с состоянием этого экземпляра. Когда метод вызывается для экземпляра, Python автоматически передает этот экземпляр в качестве первого аргумента метода с использованием специального имени \"self\". Это позволяет методу получить доступ к переменным и методам этого экземпляра.\n\nНапример, в следующем примере кода определен класс Person, который имеет переменную экземпляра 'name' и метод для вывода имени:\n\n```python\nclass Person:\n    def __init__(self, name):\n        self.name = name\n\n    def say_hello(self):\n        print(\"Hello, my name is\", self.name)\n```\n\nДля создания экземпляра класса необходимо вызвать конструктор класса с требуемыми аргументами. Например:\n\n```python\nperson = Person(\"Alice\")\nperson.say_hello() # Output: Hello, my name is Alice\n```\n\nВ этом примере кода переменная self используется для доступа к имени человека и вывода его на экран в методе say_hello().",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 385,
  "fields": {
    "question": "Объясните isinstance()",
    "answer": "Функция isinstance() используется для проверки принадлежности объекта к определенному типу данных. Она принимает два аргумента: объект, который нужно проверить, и тип данных, к которому нужно проверить его принадлежность. Возвращает True, если объект принадлежит указанному типу, и False в противном случае. Например:\n\n```python\nx = 5\nprint(isinstance(x, int)) # True\n\ny = \"hello\"\nprint(isinstance(y, int)) # False\n```\n\nЭто может быть полезно, когда нужно проверить, соответствует ли объект определенному типу данных, прежде чем выполнять операции с ним, которые могут быть не совместимы с этим типом.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 386,
  "fields": {
    "question": "Что такое статический метод, метод класса и метод экземпляра?",
    "answer": "В Python есть три типа методов: методы экземпляра, методы класса и статические методы. Вот их описание:\n\n- Методы экземпляра: Это обычные методы, которые объявляются внутри класса и принимают self как первый параметр. Они могут использовать любые атрибуты экземпляра класса. Пример:\n\nclass MyClass:\ndef my_method(self):\nprint(\"This is an instance method\")\n\nobj = MyClass()\nobj.my_method()\n\n- Методы класса: Это методы, которые объявляются внутри класса, но принимают cls вместо self в качестве первого параметра. Они могут использовать только атрибуты класса. Чтобы объявить метод класса, можно использовать декоратор @classmethod. Пример:\n\nclass MyClass:\nx = 10\n\n    @classmethod\n    def my_method(cls):\n        print(\"This is a class method\")\n        print(cls.x)\n\nMyClass.my_method()\n\n- Статические методы: Это методы, которые объявляются внутри класса, но не принимают self или cls в качестве первого параметра. Они могут использовать только локальные переменные, и не могут изменять атрибуты экземпляра класса. Чтобы объявить статический метод, можно использовать декоратор @staticmethod. Пример:\n\nclass MyClass:\n@staticmethod\ndef my_method():\nprint(\"This is a static method\")\n\nMyClass.my_method()",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 387,
  "fields": {
    "question": "Объясните map, filter,reduce and lambda.",
    "answer": "map(), filter(), reduce() и lambda — все это встроенные в Python функции.\n\n- map() — это функция, которая применяет заданную функцию к каждому элементу в итерируемом объекте и возвращает новый итерируемый объект с результатами.\n- filter() — это функция, которая создает новую итерацию с элементами из исходной итерации, которые соответствуют определенному условию, заданному функцией. r\n- educe() — это функция, которая применяет заданную функцию к элементам итерации в определенном порядке и возвращает одно значение. Обратите внимание, что в Python 3 вам сначала нужно импортировать сокращение из functools.\n- lambda — это способ определения небольших анонимных функций в Python. Это позволяет вам определить функцию в одной строке, не давая ей имени. Лямбда-функции часто используются с map() и filter() для определения встроенной функции. Вот пример того, как использовать эти функции вместе:\n\n```python\nfrom functools import reduce\n\nnumbers = [1, 2, 3, 4, 5]\n\nsquares = list(map(lambda x: x**2, numbers))\nevens = list(filter(lambda x: x % 2 == 0, numbers))\nsum_of_numbers = reduce(lambda x, y: x + y, numbers)\n\nprint(squares)  # [1, 4, 9, 16, 25]\nprint(evens)    # [2, 4]\nprint(sum_of_numbers)  # 15\n```\n\nВ этом коде map() используется для возведения в квадрат каждого числа в списке, filter() используется для хранения только четных чисел, а reduce() используется для вычисления суммы всех чисел. Сила этих функций в том, что они позволяют выполнять сложные операции с вашими данными, используя краткий и удобочитаемый синтаксис.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 388,
  "fields": {
    "question": "Разница между классами в новом стиле и классами в старом стиле.",
    "answer": "В Python разница между классами нового и старого стиля заключается в том, что классы нового стиля наследуются от класса объекта, а классы старого стиля — нет.\n\nКлассы нового стиля были введены в Python 2.2 и используются по умолчанию в Python 3.x. У них есть ряд преимуществ по сравнению с классами старого стиля, включая встроенные свойства, такие как **name**, **class** и **bases**, а также новые функции, такие как дескрипторы, которые позволяют определять геттеры и сеттеры для переменных экземпляра.\n\nКлассы нового стиля также поддерживают Порядок разрешения методов (MRO), который определяет порядок, в котором базовые классы ищут конкретный метод или атрибут. С другой стороны, классы старого стиля не имеют этих функций или преимуществ. Первоначально они были разработаны для Python версии 1.5 и в значительной степени устарели в Python 2.2, хотя по-прежнему поддерживаются для обеспечения обратной совместимости. В большинстве случаев рекомендуется использовать классы нового стиля в Python. Чтобы создать класс нового стиля, вы просто нужно наследовать от класса объекта так:\n\n```python\nclass NewStyleClass(object):\n    pass\n\n```\n\nКроме того, в Python 3.x вы можете опустить часть (объект) и определить класс следующим образом:\n\n```python\nclass NewStyleClass:\n    pass\n\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 389,
  "fields": {
    "question": "В чем разница между Python и Java?",
    "answer": "В чем разница между Python и Java?\nОсновные различия между Python и Java:\n\n- Типизация: Java - это язык со статической типизацией и компиляцией, а Python - это язык с динамической типизацией и интерпретацией.\n\n- Структуры данных: Python имеет встроенные высокоуровневые структуры данных, такие как словари и списки, и в целом более экономный синтаксис, чем у Java.\n\n- Параллелизм: в Python существует проблема Global Interpreter Lock (GIL), которая ограничивает выполнение кода в несколько потоков. В то время как в Java вы можете создавать потоки и выполнять вычисления параллельно.\n\n- Компиляция: в Java код компилируется в байт-код, который затем выполняется виртуальной машиной Java (JVM), в то время как Python - это язык интерпретируемый.\n\n- Импорт: в Java оператор import используется для импорта классов, переменных и функций из других пакетов. В Python тоже используется оператор import, однако он также может быть использован для импорта модулей или определенных элементов из них.\n- Java обычно используется для написания крупных приложений, а Python чаще всего используется для написания быстрого прототипирования и научных вычислений.\n\n- Код на Java обычно дольше и более сложен, чем на Python, потому что Java - более формальный язык с множеством правил и синтаксических требований, тогда как Python часто используется для написания более простых и лаконичных программ.\n\n- Python часто используется в области машинного обучения и научных вычислений, тогда как Java часто используется в крупных предприятиях и проектах, связанных с серверной разработкой.\n\nЭто далеко не все отличия, однако это некоторые из самых основных. Выбор между Python и Java зависит от конкретных задач и потребностей проекта.",
    "category": 5,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 390,
  "fields": {
    "question": "Что такое контекстный процессор?",
    "answer": "Контекстные процессоры (context processors) в Django - это функции, которые добавляют глобальные переменные в контекст перед рендерингом шаблона. Эти переменные могут быть использованы в любом шаблоне в приложении, и не нужно передавать их каждый раз при рендеринге каждого шаблона вручную.\n\nКонтекстные процессоры в Django имеют доступ к объекту request, который содержит информацию о запросе, и могут использоваться для добавления переменных в контекст на основе этой информации.\n\nНапример, контекстный процессор может добавлять текущего пользователя в контекст, что позволит проверять доступности функционала приложения на страницах, доступных только зарегистрированным пользователям.\n\nВот пример функции-контекстного процессора, которая добавляет текущего пользователя в контекст:\n\n```python\ndef user_context(request):\n    return {'user': request.user}\n```\n\nЧтобы использовать этот контекстный процессор в вашем приложении Django, добавьте его в настройки проекта в списке CONTEXT_PROCESSORS.\n\nНапример:\n\n```python\n# Файл settings.py\n# ...\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'APP_DIRS': True,\n        'OPTIONS': {\n            'context_processors': [\n                # ...\n                'myapp.context_processors.user_context',\n            ],\n        },\n    },\n]\n```\n\nТеперь переменная user будет доступна в любом шаблоне вашего приложения.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 391,
  "fields": {
    "question": "Что такое exec() и eval()?",
    "answer": "exec() и eval() — это встроенные функции Python, используемые для динамического выполнения кода. exec() можно использовать для выполнения блока кода, представленного в виде строки или объекта, что позволяет динамически генерировать и выполнять код Python. Например:\nexec() и eval() - это функции в Python, которые позволяют выполнять произвольный код в строковом формате.\n\neval() используется для вычисления выражения из строки и возвращает результат вычислений. Например:\n\n```python\nx = 5\nresult = eval('x * 2')\nprint(result) # Выводит 10\n```\n\nФункция exec() используется для выполнения строки как программного кода. Например:\n\n```python\nx = 5\ncode_string = 'y = x * 2'\nexec(code_string)\nprint(y) # Выводит 10\n```\n\nОднако, обе эти функции могут быть опасными, поскольку могут выполнять произвольный код, в том числе и вредоносный. Поэтому, следует использовать их с осторожностью и только при необходимости.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 392,
  "fields": {
    "question": "Как передать аргумент командной строки.",
    "answer": "В Python вы можете использовать модуль argparse для обработки аргументов командной строки. Вот простой пример:\n\n```python\nimport argparse\n\nparser = argparse.ArgumentParser(description='Описание вашей программы')\nparser.add_argument('--foo', type=int, default=42, help='Числовой параметр')\nparser.add_argument('filename', help='Имя файла для обработки')\nargs = parser.parse_args()\n\nprint(args.foo)\nprint(args.filename)\n```\n\nВ этом примере мы создаем объект ArgumentParser, добавляем два аргумента и парсим аргументы командной строки, используя метод parse_args(). В результате, args.foo будет иметь значение, которое было передано в качестве параметра --foo, а args.filename - имя файла, переданное без какого-либо префикса.\n\nВы можете выполнить эту программу, используя командную строку следующим образом:\n\n```python\npython myprogram.py --foo 123 somefile.txt\n```\n\nгде myprogram.py - имя вашего файла программы.\n\nДля передачи аргументов при запуске Python-скрипта в Jupyter Notebook, вы можете использовать sys.argv:\n\n```python\nimport sys\n\nprint(\"Аргументы командной строки:\")\nfor arg in sys.argv:\n    print(arg)\n```\n\nВы можете затем вызвать свой скрипт так:\n\n```python\npython myprogram.py arg1 arg2 arg3\n```\n\nгде arg1, arg2 и arg3 - аргументы, которые вы хотите передать в ваш скрипт.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 393,
  "fields": {
    "question": "Что такое yield?",
    "answer": "yield в Python используется для создания генераторов, которые возвращают значения итерируемого типа. Генератор функция это функция, возвращающая итератор - один раз может использоваться для прохода по последовательности значений, а затем исчезает.\n\nКогда yield используется в функции, она становится генератором. Каждый раз, когда yield достигается в теле генератора, он возвращает значения, указанные после yield, и временно \"замораживает\" (приостанавливает) функцию до следующей итерации. Кроме того, при каждом вызове генератора создается новый объект класса генератор и возвращаемые значения сохраняются в нем между вызовами.\n\nВот пример функции-генератора, которая генерирует квадраты чисел:\n\n```python\ndef squares(n):\n    for i in range(n):\n        yield i**2\n\n# пример использования\nsquares_gen = squares(5)\nfor x in squares_gen:\n    print(x) # выведет 0 1 4 9 16\n```\n\nЭта функция возвращает генератор, который генерирует квадраты целых чисел от 0 до n-1. Мы можем вызвать эту функцию, чтобы получить генератор, и затем использовать его как итератор, чтобы перебирать элементы последовательности.\n\nВажно помнить, что при первом вызове генератор не выполняет никакого кода внутри функции, а только создает и возвращает объект генератора. Код внутри функции будет выполнен только после вызова метода **next**() (или с помощью next() в Python 2.x) на генераторном объекте.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 394,
  "fields": {
    "question": "Что такое ord() и chr()?",
    "answer": "ord() и chr() - это функции в Python, которые связаны с ASCII кодировкой.\n\nord() - это функция, которая принимает один символ (строка длиной 1) и возвращает его числовое ASCII значение. Например, ord('a') вернет 97, потому что \"a\" имеет значение 97 в таблице ASCII.\n\nchr() - это функция, которая принимает одно число и возвращает соответствующий символ ASCII-кода. Например, chr(97) вернет \"a\", потому что 97 соответствует символу \"a\" в таблице ASCII.\n\nПример:\n\n```python\nprint(ord('a'))\n```\n\nЭто выведет 97, так как символ 'a' имеет код Unicode 97. Функция chr() принимает один аргумент - код символа в десятичной системе и возвращает соответствующий символ Unicode. Пример:\n\n```python\nprint(chr(97))\n```\n\nЭто выведет 'a', так как код Unicode 97 соответствует символу 'a'.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 395,
  "fields": {
    "question": "Что такое метаклассы?",
    "answer": "Метаклассы в языке Python - это классы, которые определяют поведение других классов. То есть, они являются классами для классов. Метаклассы используются в Python для создания новых типов объектов и управления созданием новых классов.\n\nОдним из примеров использования метаклассов является создание класса с динамическими атрибутами. При использовании метакласса можно определять атрибуты и методы класса динамически в зависимости от различных условий.\n\nПример создания метакласса:\n\n```python\nclass MyMeta(type):\n    def __new__(cls, name, bases, attrs):\n        # код для создания нового класса\n        return super().__new__(cls, name, bases, attrs)\n\nclass MyClass(metaclass=MyMeta):\n    pass\n```\n\nВ данном примере создан метакласс MyMeta, который будет использоваться для создания новых классов. Затем создан класс MyClass с помощью метакласса MyMeta.\n\nТакже стоит отметить, что метаклассы в Python могут использоваться для перехвата и изменения поведения существующих методов в классах.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 396,
  "fields": {
    "question": "Что такое дескриптор?",
    "answer": "Дескриптор в Python - это объект, который определяет, как атрибуты класса должны быть доступны, устанавливаемы и удалены. Дескрипторы предоставляют программистам более мощный способ управления атрибутами объектов, и они широко используются в различных библиотеках и фреймворках Python.\n\nДескрипторы предоставляют три метода: **get**, **set**, и **delete**. Метод **get** вызывается при обращении к атрибуту, **set** - при попытке установить его значение, а **delete** - при удалении атрибута.\n\nКогда вы определяете дескриптор, вы можете использовать его как атрибут класса следующим образом:\n\nclass MyClass:\nmy_attribute = MyDescriptor()\nЗдесь MyClass - это класс, my_attribute - это атрибут, который использует дескриптор MyDescriptor() для определения его поведения.\n\nПример простого дескриптора:\n\n```python\nclass Descriptor:\n    def __get__(self, instance, owner):\n        print(\"Getting the attribute\")\n        return instance._value\n\n    def __set__(self, instance, value):\n        print(f\"Setting the attribute to {value}\")\n        instance._value = value\n\n    def __delete__(self, instance):\n        print(\"Deleting the attribute\")\n        del instance._value\n\nclass MyClass:\n    my_attribute = Descriptor()\n    def __init__(self, value):\n        self._value = value\n```\n\nЗдесь Descriptor - это класс дескриптора с тремя методами get, set и delete. MyClass - это класс, который использует дескриптор my_attribute.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 397,
  "fields": {
    "question": "Пространство имен и область видимости?",
    "answer": "Пространство имен — это сопоставление имен с объектами. Это механизм, позволяющий избежать конфликтов имен в программе путем организации имен с помощью системы уникальных префиксов, называемых пространствами имен. Область видимости — это область кода, в которой доступно конкретное пространство имен. Это область программы, где переменная допустима и к ней можно получить доступ.\n\nПравило LEGB используется в Python для определения порядка поиска в различных областях для разрешения имени. Правило LEGB расшифровывается как Local, Enclosing, Global и Built-in. Когда имя встречается в программе, Python сначала ищет это имя в локальной области, затем ищет во всех окружающих областях, затем ищет в глобальной области и, наконец, ищет во встроенной области.\n\nТаким образом, пространства имен и области действия — это связанные понятия, поскольку пространства имен используются для организации объектов и предотвращения конфликтов имен, а области используются для определения областей в программе, где переменная допустима и доступна. Понимание этих концепций важно при работе с Python, так как это может помочь вам управлять конфликтами имен и писать более эффективный и удобный код.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 398,
  "fields": {
    "question": "Что такое MRO?",
    "answer": "MRO (Method Resolution Order) - порядок разрешения методов в Python. Это концепция, используемая при наследовании. Она определяет порядок, в котором методы ищутся в иерархии классов и особенно важна, когда есть дубликаты имен методов в родительских классах. При наследовании классов Python ищет вызываемый метод в текущем классе, затем в его родительском классе и так далее, пока не найдет его или не достигнет вершины иерархии. Вы можете получить доступ к порядку разрешения методов с помощью атрибута **mro**, который доступен на любом классе Python.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 399,
  "fields": {
    "question": "Когда использовать comprehensions списка и когда избегать comprehensions списка?",
    "answer": "Comprehensions списков может быть мощной функцией Python для создания новых списков на основе существующих списков, но в некоторых случаях лучше их избегать. Вот несколько рекомендаций:\n\n- Используйте понимание списка, когда логика короткая и ясная. Если логика, стоящая за пониманием списка, слишком длинная или сложная, лучше вместо этого использовать обычный цикл.\n- Используйте списки, когда результатом является небольшой список. Если вы создаете большой список, использование памяти для понимания списка может быть слишком большим, и вместо этого может быть лучше использовать выражение генератора.\n- Избегайте использования списков только для побочных эффектов. Генераторы списков предназначены для создания нового списка, а не для изменения существующего. Если вас интересуют только побочные эффекты, лучше использовать обычный цикл.\n\nВ конечном счете, важно писать ясный, лаконичный и простой в использовании код. понимать. Если понимание списка делает ваш код более читабельным (в отличие от его запутывания), во что бы то ни стало используйте его. Если нет, рассмотрите альтернативный подход.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 400,
  "fields": {
    "question": "Что такое функции отображения, фильтрации и сокращения?",
    "answer": "Функции отображения, фильтрации и сокращения (map, filter и reduce) - это встроенные функции высшего порядка в Python, которые обычно используются для преобразования и обработки данных в коллекциях (списках, кортежах и т. д.).\n\nФункция map() принимает функцию и последовательность в качестве аргументов. Она применяет функцию к каждому элементу последовательности и возвращает новую последовательность с результатами.\n\nФункция filter() также принимает функцию и последовательность в качестве аргументов. Она возвращает новую последовательность, содержащую только те элементы из исходной последовательности, для которых функция возвращает True.\n\nФункция reduce() принимает функцию и последовательность в качестве аргументов. Она последовательно применяет функцию к элементам последовательности, сокращая последовательность до единственного значения.\n\nВот примеры использования этих функций:\n\n```python\n# map()\nnumbers = [1, 2, 3, 4]\nsquares = list(map(lambda x: x**2, numbers)) # [1, 4, 9, 16]\n\n# filter()\nnumbers = [1, 2, 3, 4]\neven_numbers = list(filter(lambda x: x % 2 == 0, numbers)) # [2, 4]\n\n# reduce()\nfrom functools import reduce\nnumbers = [1, 2, 3, 4]\nproduct = reduce(lambda x, y: x * y, numbers) # 24\n```\n\nЗдесь мы использовали лямбда-функции в качестве аргументов для функций map() и filter(). Функция reduce() потребовала импорта модуля functools для использования сокращения.\n\n290. Какие типы исключений генерируются в Python?\n     Python генерирует множество встроенных исключений для обработки ошибок во время работы программы. Некоторые из наиболее часто используемых типов исключений в Python:\n\n- ArithmeticError: базовый класс для исключений, связанных с арифметическими операциями, например ZeroDivisionError.\n\n- AssertionError: возникает, когда утверждение assert оказывается ложным.\n\n- EOFError: возникает, когда функция input() достигает конца файла (End Of File).\n\n- KeyError: возникает, когда запрашиваемый ключ не найден в словаре.\n\n- NameError - возникает, когда локальная или глобальная переменная не определена.\n\n- TypeError - возникает, когда операция применяется к объекту несоответствующего типа.\n\n- ValueError - возникает, когда функции передаются неверные аргументы.\n\n- ZeroDivisionError - возникает, когда попытка деления на ноль.\n\n- IOError - возникает, когда происходит ошибка ввода-вывода.\n\n- IndexError - возникает, когда индекс выходит за пределы допустимого диапазона.\n\n- KeyError - возникает, когда ключ не найден в словаре.\n\n- AttributeError - возникает, когда объект не имеет запрашиваемого атрибута.\n- FileNotFoundError: вызывается, когда не удается найти запрашиваемый файл.\n\n- ImportError: вызывается, когда не удается импортировать модуль.\n\n- KeyboardInterrupt: вызывается, когда пользователь прерывает выполнение программы, нажав Ctrl + C.\n\nСписок исключений в Python не ограничивается только этими. В целом, в Python существует много типов исключений, которые могут возникнуть при выполнении вашей программы. Чтобы обрабатывать исключения в Python, вы можете использовать конструкцию try-except.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 401,
  "fields": {
    "question": "Как написать свою собственную обработку исключений?",
    "answer": "",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 402,
  "fields": {
    "question": "Разница между input и raw_input?",
    "answer": "input() и raw_input() - это встроенные функции в Python. В Python 2.x raw_input() используется для чтения пользовательского ввода в виде строки, а input() - для вычисления выражения, введенного пользователем и возвращения его в качестве значения. В Python 3.x версии функция raw_input() была удалена, и input() теперь используется для чтения пользовательского ввода в виде строки. Поэтому, если вы используете Python 3.x, вам следует использовать input().\n\nПример использования input():\n\n```python\nname = input(\"What is your name? \")\nprint(f\"Hello, {name}\")\n```\n\nЗдесь input() используется для чтения имени пользователя в виде строки, которая затем выводится на экран с приветствием.\n\nПример использования raw_input():\n\n```python\nname = raw_input(\"What is your name? \")\nprint \"Hello, \" + name\n```\n\nЭтот код эквивалентен примеру с input() в Python 3.x. В Python 2.x вы должны использовать raw_input(), чтобы прочитать строку и сохранить ее в переменной name.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 403,
  "fields": {
    "question": "Почему мы пишем `__name__` == `\"__main__\"` в скрипте Python?",
    "answer": "Мы пишем **name** == \"**main**\" в скрипте Python чтобы указать интерпретатору, что определенный блок кода должен быть выполнен только в том случае, если файл запущен непосредственно (как главный файл) и не импортирован как модуль в другой файл. Код, который находится в блоке \"if name == 'main':\" будет выполнен только когда модуль запущен как скрипт, и не будет выполнен при импорте в другой модуль.\n\nДля лучшего понимания, рассмотрим следующий пример:\n\n```python\ndef add_numbers(x, y):\n    return x + y\n\nif __name__ == \"__main__\":\n    print(add_numbers(5, 7))\n```\n\nЗдесь определение функции add_numbers() не будет выполнено, если файл импортируется как модуль. Однако, если этот файл запущен непосредственно, код в блоке if будет выполнен, и результатом будет выведено число 12.\n\nЭтот подход особенно полезен при написании ресурсоемких скриптов или тестовых сценариев, где многократный импорт модуля может привести к долгим задержкам.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 404,
  "fields": {
    "question": "Почему обработка исключений имеет блок finally?",
    "answer": "Блок finally в обработке исключений в Python используется для выполнения кода вне зависимости от того, было ли возбуждено исключение или нет. Код в блоке finally будет выполнен даже в случае возникновения исключения и выполнения блока except.\n\nЭто может быть полезно, например, для освобождения ресурсов, таких как файлы или сетевые соединения, которые были открыты в блоке try, вне зависимости от того, было или нет возбуждено исключение.\n\nПример кода:\n\n```python\ntry:\n    # some code that might raise an exception\nexcept SomeExceptionType:\n    # handle the exception\nfinally:\n    # code to be executed regardless of whether an exception was raised or not\n```\n\nТаким образом, блок finally помогает убедиться, то код, ответственный за очистку и управление ресурсами, будет выполнен в любом случае, даже если произойдет исключение.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 405,
  "fields": {
    "question": "Обеспечивает ли Python многопоточность?",
    "answer": "Да, Python обеспечивает многопоточность. Однако, из-за особенностей реализации интерпретатора, использование потоков в многопоточном приложении может быть ограничено GIL (Global Interpreter Lock). GIL гарантирует, что только один поток кода Python выполняется в любой момент времени, что может привести к проблемам производительности в некоторых сценариях использования. Для обхода GIL и увеличения производительности в Python часто используют процессы или асинхронность.\n\nPython имеет встроенную библиотеку threading для создания и управления потоками, а также библиотеки multiprocessing и concurrent.futures для создания и управления процессами. Также в Python есть сторонние асинхронные библиотеки, такие как asyncio и trio, которые позволяют создавать и управлять асинхронными задачами и корутинами.\n\nПример использования модуля threading для запуска функции в отдельном потоке:\n\n```python\nimport threading\n\ndef my_function():\n    # some code here\n\n# Создание нового потока\nmy_thread = threading.Thread(target=my_function)\n# Запуск потока\nmy_thread.start()\n# Ожидание завершения потока (если необходимо)\nmy_thread.join()\n```\n\nЭтот пример создает новый поток, который запускает функцию my_function. После запуска потока мы можем продолжить выполнять код в главном потоке, пока поток my_thread работает в фоновом режиме. Если нужно дождаться завершения my_thread, мы можем вызвать метод join().\n\nКак уже упоминалось, для параллельной работы нескольких процессов можно использовать модуль multiprocessing.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 406,
  "fields": {
    "question": "Что вы подразумеваете под неблокирующим вводом-выводом?",
    "answer": "Неблокирующий ввод-вывод - это техника в программировании, которая позволяет сделать асинхронный ввод-вывод без блокировки передачи управления от текущего потока выполнения до тех пор, пока операция ввода-вывода не будет завершена.\n\nВ языке Python неблокирующий ввод-вывод может быть реализован с использованием модуля asyncio, который позволяет создавать асинхронные функции и использовать их для выполнения неблокирующей операции ввода-вывода. Режим асинхронной работы позволяет программе максимально эффективно использовать вычислительные ресурсы и ускорить выполнение задач.\n\nНапример, вот как выглядит асинхронный HTTP-запрос с использованием библиотеки aiohttp в Python:\n\n```python\nimport aiohttp\nimport asyncio\n\nasync def make_request(url):\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url) as response:\n            html = await response.text()\n            return html\n\nloop = asyncio.get_event_loop()\nurl = \"https://www.example.com\"\nhtml = loop.run_until_complete(make_request(url))\n```\n\nЭтот код делает асинхронный GET-запрос по указанному URL-адресу, используя библиотеку aiohttp и не блокируя выполнение программы.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 407,
  "fields": {
    "question": "Что произойдет, если произойдет ошибка, которая не обрабатывается в блоке исключений?",
    "answer": "Если в блоке try-except не задан обработчик для ошибки, которая может возникнуть в блоке try, то эта ошибка не будет перехвачена и программа завершится с ошибкой, выводя информацию о том, что произошла неперехваченная ошибка. Например, вот такой код приведет к ошибке, так как блок except не покрывает тип ошибки NameError:\n\n```python\ntry:\n    print(some_undefined_variable)\nexcept ZeroDivisionError:\n    print(\"Деление на ноль\")\n```\n\nВ этом примере программа завершится с ошибкой NameError: name 'some_undefined_variable' is not defined.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 408,
  "fields": {
    "question": "Как модули используются в программе Python?",
    "answer": "Модули в Python используются для организации кода в логически связанные блоки и повторного использования кода. Модули могут содержать определения функций, классов и переменных, которые можно импортировать в другие модули или скрипты Python.\n\nДля импортирования модуля в Python используется оператор import. Например, чтобы импортировать модуль math, который содержит математические функции, можно написать следующий код:\n\n```python\nimport math\n\nx = math.sqrt(4)\nprint(x)\n```\n\nЭтот код импортирует модуль math и использует функцию sqrt() для вычисления квадратного корня из числа 4.\n\nВы также можете импортировать только определенные имена из модуля, используя ключевое слово from. Например, можно импортировать только функцию sqrt() из модуля math следующим образом:\n\n```python\nfrom math import sqrt\n\nx = sqrt(4)\nprint(x)\n```\n\nЭтот код импортирует только функцию sqrt() из модуля math и использует ее для вычисления квадратного корня из числа 4.\n\nТакже есть возможность использвать пакеты (packages), которые представляют собой иерархически организованные модули.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 409,
  "fields": {
    "question": "Как создать функцию Python?",
    "answer": "Для создания функции в Python используется ключевое слово \"def\" (от \"define\"). Ниже приведен пример определения функции в Python:\n\n```python\ndef my_function():\n    print(\"Hello World!\")\nФункция my_function определена без аргументов. Она просто выводит \"Hello World!\" в консоль. Вы можете вызвать функцию, используя ее имя, например:\n\nmy_function()\nЭто вызовет функцию и выведет сообщение \"Hello World!\" в консоль. Вы можете передавать аргументы в функцию, используя скобки. Например:\n\ndef greet(name):\n    print(\"Hello, \" + name + \"!\")\n\ngreet(\"Alice\")\ngreet(\"Bob\")\nВызовет этот код функцию greet() дважды. Первый раз вызов с аргументом \"Alice\" выведет \"Hello, Alice!\" в консоль, второй вызов с аргументом \"Bob\" выведет \"Hello, Bob!\".\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 410,
  "fields": {
    "question": "Как создается класс Python?",
    "answer": "Чтобы создать класс в Python, используйте ключевое слово \"class\", за которым следует имя класса, после чего идут двоеточие и блок кода, содержащий определения атрибутов и методов класса. Вот пример создания простого класса в Python:\n\n```python\nclass MyClass:\n    def __init__(self, value):\n        self.value = value\n\n    def my_method(self):\n        print(\"My value is:\", self.value)\n```\n\nВ этом примере мы создаем класс MyClass, который имеет атрибут value и метод my_method. Метод init — это метод-конструктор, который будет выполнен при создании экземпляра класса. Данный метод принимает параметр \"value\" и присваивает его значению атрибута value. Метод my_method — это простой метод, который выводит на экран значение атрибута value.\n\nЧтобы создать экземпляр класса, просто вызовите класс, как если бы это была функция, передавая необходимые аргументы:\n\n```python\nmy_instance = MyClass(\"Hello, World!\")\nmy_instance.my_method()  # выводит \"My value is: Hello, World!\"\n```\n\nЗдесь мы создаем экземпляр класса MyClass и присваиваем его переменной my_instance. Затем мы вызываем метод my_method на этом экземпляре, который выводит значение атрибута значение value на экран.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 411,
  "fields": {
    "question": "Как создается экземпляр класса Python?",
    "answer": "ля создания экземпляра класса в Python нужно сначала определить класс, а затем вызвать конструктор класса с помощью оператора new. В конструкторе можно задать начальные значения свойств объекта. Пример определения класса и создания экземпляра:\r\n\r\n```python\r\nclass MyClass:\r\n    def __init__(self, prop1, prop2):\r\n        self.prop1 = prop1\r\n        self.prop2 = prop2\r\n\r\nmy_object = MyClass(\"значение1\", \"значение2\")\r\n```\r\n\r\nВ этом примере мы создали класс MyClass с двумя свойствами prop1 и prop2. Затем мы создали новый объект класса MyClass, передав значения \"значение1\" и \"значение2\" в качестве аргументов конструктора. Этот объект сохраняется в переменной my_object.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 1,
    "adds": 0,
    "status": true
  }
},
{
  "model": "cards.card",
  "pk": 412,
  "fields": {
    "question": "Как функция возвращает значения?",
    "answer": "В Python функция может возвращать одно или несколько значений с помощью оператора return. Значения могут быть любого типа данных, включая целочисленные, строковые, списки, словари и другие объекты Python. Вот примеры:\n\n```python\n# Функция возвращает целое число\ndef add(x, y):\n    return x + y\n\n# Функция возвращает список\ndef get_names():\n    names = ['Alice', 'Bob', 'Charlie']\n    return names\n\n# Функция возвращает кортеж\ndef get_person():\n    name = 'Alice'\n    age = 25\n    return name, age\n\n# Функция возвращает словарь\ndef get_user():\n    user = {'username': 'alice', 'password': 'secret'}\n    return user\n```\n\nЧтобы получить значение, возвращаемое функцией, используйте оператор return в сочетании с сохранением возвращаемого значения в переменной. Например:\n\n```python\nresult = add(3, 4)  # result будет равен 7\nnames = get_names()  # names будет содержать список ['Alice', 'Bob', 'Charlie']\nperson = get_person()  # person будет содержать кортеж ('Alice', 25)\nuser = get_user()  # user будет содержать словарь {'username': 'alice', 'password': 'secret'}\n```\n\nВы также можете использовать кортеж прямо в операторе присваивания, чтобы распаковать значения, возвращаемые функцией. Например:\n\n```python\nname, age = get_person()  # name будет равен 'Alice', age будет равен 25\n```",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 413,
  "fields": {
    "question": "Что происходит, когда функция не имеет оператора возврата (return)?",
    "answer": "Если функция в Python не имеет оператора return, то она все равно завершится, как только выполнение кода достигнет конца функции. Однако, в этом случае функция не будет возвращать никакого значения, что может привести к непредсказуемому поведению кода, если результат работы функции используется в другой части программы.\n\nЕсли функция завершается без оператора return, она возвращает значение None по умолчанию.\n\nНапример, функция, которая не имеет оператора return:\n\n```python\ndef no_return():\n    print(\"Эта функция ничего не возвращает\")\n```\n\nТакая функция будет находиться в незавершенном состоянии после ее выполнения. Если результат функции будет использоваться где-либо в программе, это может привести к ошибке:\n\n```python\nresult = no_return()\nprint(result)  # будет выведено None\n```\n\nЕсли вы хотите вернуть некоторое значение из функции, убедитесь, что вы используете оператор return с нужным значением.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 414,
  "fields": {
    "question": "Как создать словарь, сохраняющий порядок пар?",
    "answer": "В Python есть два варианта для создания словаря, сохраняющего порядок пар ключ-значение: используйте OrderedDict из модуля collections или используйте новый стандарт Python 3.7 и новее, который поддерживает сортированные словари.\r\n\r\nПример использования OrderedDict в Python:\r\n\r\n```python\r\nfrom collections import OrderedDict\r\n\r\nd = OrderedDict()\r\nd['foo'] = 1\r\nd['bar'] = 2\r\nd['baz'] = 3\r\n\r\nfor key, value in d.items():\r\n    print(key, value)\r\n```\r\n\r\nЭтот код создает словарь, где ключи сохраняются в порядке их добавления в словарь, и выводит его элементы в том же порядке.\r\n\r\nПример использования сортированного словаря в Python 3.7 и новее:\r\n\r\n```python\r\nd = {'foo': 1, 'bar': 2, 'baz': 3}\r\nsorted_d = dict(sorted(d.items()))\r\n\r\nfor key, value in sorted_d.items():\r\n    print(key, value)\r\n```\r\n\r\nЭтот код создает словарь, сортируя его элементы по ключу и выводит каждый элемент словаря в порядке сортировки.\r\n\r\nНезависимо от выбранного метода, оба словаря могут использоваться так же, как и обычные словари.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 1,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 415,
  "fields": {
    "question": "Можно ли использовать изменяемую структуру данных в качестве ключа в словарях?",
    "answer": "",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 416,
  "fields": {
    "question": "В чем разница между кортежем и списком? Где вы будете использовать кортеж и где вы будете использовать список?",
    "answer": "В Python кортеж (tuple) и список (list) являются двумя различными типами последовательностей. Основное отличие между ними заключается в следующем:\n\n- Кортеж является неизменяемым (immutable), что означает, что его элементы не могут быть изменены после того, как он был создан, а список является изменяемым (mutable) и его элементы могут быть изменены.\n\n- Кортежы обычно используются для хранения набора значений, которые не должны изменяться, в то время как списки используются для хранения изменяемых наборов данных.\n\nКортежи также имеют несколько других преимуществ:\n\n- Они занимают меньше места в памяти, чем списки.\n\n- Кортежи могут использоваться в качестве ключей в словарях, тогда как списки этого сделать не могут.\n\n- Кортежи могут быть использованы в качестве элементов множества (set), тогда как списки этого не могут.\n\nВ целом, если нужен неизменяемый набор данных, то лучше использовать кортеж, а если нужна коллекция, которую можно изменять, то лучше использовать список.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 417,
  "fields": {
    "question": "Объясните все режимы обработки файлов, поддерживаемые Python?",
    "answer": "Объясните все режимы обработки файлов, поддерживаемые Python?\r\nPython поддерживает несколько режимов обработки файлов, в зависимости от того, как вы хотите использовать файл.\r\n\r\nРежимы обработки файлов в Python:\r\n\r\n- Чтение файла (Read): 'r' - открывает файл для чтения (по умолчанию)\r\n\r\n- Запись в файл (Write): 'w' - открывает файл для записи. Если файл не существует, он будет создан. Если файл уже существует, он будет перезаписан.\r\n\r\n- Добавление в файл (Append): 'a' - открывает файл для записи, но добавляет новые данные в конец файла, вместо перезаписи файла.\r\n\r\n- Режим чтения и записи ('r+') - используется для чтения и записи данных в файл. Если файл не существует, создается новый файл.\r\n\r\n- Режим записи и чтения ('w+') - используется для записи и чтения данных в файл. Если файл не существует, создается новый файл.\r\n\r\n- Режим добавления и чтения ('a+') - используется для добавления и чтения данных в конец файла. Если файл не существует, создается новый файл.\r\n\r\n- Бинарный режим (Binary): 'b' - открывает файл в двоичном режиме для чтения или записи данных в двоичном формате.\r\n- Режим двоичного чтения (rb): используется для чтения двоичных данных, таких как изображения, видео, аудиофайлы, и т.д.\r\n- Режим двоичной записи (wb): используется для записи двоичных данных, таких как изображения, видео, аудиофайлы, и т.д.\r\n- 't': открыть файл в режиме текстового формата (по умолчанию).\r\n\r\n- '+': открыть файл для обновления (чтения и записи).\r\n- 'x': открыть файл для записи только в том случае, если его не существует. Если файл уже существует, возникнет исключение.\r\n\r\nВсе эти режимы обработки файлов могут быть использованы как для текстовых, так и для бинарных файлов. Для текстовых файлов режимом по умолчанию является 'r', а для бинарных файлов - 'rb'.\r\n\r\nНапример, чтобы открыть файл для чтения в текстовом режиме, вы можете использовать следующий код:\r\n\r\n```python\r\nf = open('filename.txt', 'r')\r\n```\r\n\r\nЧтобы открыть файл для записи в двоичном режиме, вы можете использовать следующий код:\r\n\r\n```python\r\nf = open('filename.bin', 'wb')\r\n```\r\n\r\nОбратите внимание, что после завершения работы с файлом его необходимо закрыть с помощью метода close(), чтобы сохранить данные и освободить ресурсы:\r\n\r\n```python\r\nf.close()\r\n```\r\n\r\nЭти же функции можно использовать через контекстный менеджер with, который автоматически закроет файл после завершения блока:\r\n\r\n```python\r\nwith open('filename.txt', 'r') as f:\r\n    # do something with the file\r\n```\r\n\r\nЭто рекомендуется делать во избежание утечек памяти и других проблем с файлами.",
    "category": 7,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 1,
    "adds": 0,
    "status": true
  }
},
{
  "model": "cards.card",
  "pk": 418,
  "fields": {
    "question": "Какие параметры следует учитывать для проверки, когда сервер не работает?",
    "answer": "Если сервер не работает, можно проверить следующие параметры:\n\n- Состояние сервера: Проверьте, что сервер запущен и работает. Вы можете попробовать запустить сервер с помощью команды запуска и убедиться, что он запускается без ошибок.\n\n- Системные ресурсы: Проверьте, что сервер имеет достаточно ресурсов, таких как память и процессорное время. Вы можете использовать инструменты мониторинга системы, такие как top или htop, чтобы проверить использование ресурсов.\n\n- Доступность сети: Проверьте, что сервер доступен через сеть. Вы можете попробовать подключиться к серверу через сеть с помощью утилиты ping или telnet и убедиться, что соединение устанавливается.\n\n- Журналы: Посмотрите журналы сервера для определения ошибок. Это может помочь выявить проблемы и потенциальные причины сбоев.\n\n- Брандмауэр: Убедитесь, что брандмауэр на сервере не блокирует никакие входящие или исходящие соединения. Вы можете проверить настройки брандмауэра, чтобы убедиться, что он не блокирует необходимые порты.\n\nЭти параметры могут помочь определить причины сбоев и принять соответствующие меры по восстановлению работы сервера.",
    "category": 3,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 419,
  "fields": {
    "question": "## Что такое _«SQL»_?",
    "answer": "SQL, Structured query language («язык структурированных запросов») — формальный непроцедурный язык программирования, применяемый для создания, модификации и управления данными в произвольной реляционной базе данных, управляемой соответствующей системой управления базами данных (СУБД).\n\nФормальный - множество конечных слов (строк, цепочек) над конечным алфавитом. Различают языки естественные, на которых общаются люди, и искусственные (или формальные).\n\nНепроцедурный - каждый оператор выдает результат, соответствующий запрашиваемому выходу. Ответственность за то, как добиться соответствующего выхода, лежит, в значительной степени, на моторе (движке) базы данных.",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 420,
  "fields": {
    "question": "## Какие существуют операторы SQL?",
    "answer": "**операторы определения данных (Data Definition Language, DDL)**:\n\n- `CREATE` создает объект БД (базу, таблицу, представление, пользователя и т. д.),\n- `ALTER` изменяет объект,\n- `DROP` удаляет объект,\n- `TRUNCATE` - удаляет таблицу и создает ее заново. Причем если на эту таблицу есть ссылки `FOREGIN KEY` или таблица используется в репликации, то пересоздать такую таблицу не получится.\n- `RENAME` переименовыывает объект;\n\n**операторы манипуляции данными (Data Manipulation Language, DML)**:\n\n- `SELECT` выбирает данные, удовлетворяющие заданным условиям,\n- `INSERT` добавляет новые данные,\n- `UPDATE` изменяет существующие данные,\n- `DELETE` удаляет данные;\n\n**операторы определения доступа к данным (Data Control Language, DCL)**:\n\n- `GRANT` предоставляет пользователю (группе) разрешения на определенные операции с объектом,\n- `REVOKE` отзывает ранее выданные разрешения,\n- `DENY` задает запрет, имеющий приоритет над разрешением;\n\n**операторы управления транзакциями (Transaction Control Language, TCL)**:\n\n- `COMMIT` применяет транзакцию,\n- `ROLLBACK` откатывает все изменения, сделанные в контексте текущей транзакции,\n- `SAVEPOINT` разбивает транзакцию на более мелкие.",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 421,
  "fields": {
    "question": "## Что означает `NULL` в SQL?",
    "answer": "`NULL` - специальное значение (псевдозначение), которое может быть записано в поле таблицы базы данных. NULL соответствует понятию «пустое поле», то есть «поле, не содержащее никакого значения».\n\n`NULL` означает отсутствие, неизвестность информации. Значение `NULL` не является значением в полном смысле слова: по определению оно означает отсутствие значения и не принадлежит ни одному типу данных. Поэтому `NULL` не равно ни логическому значению `FALSE`, ни _пустой строке_, ни `0`. При сравнении `NULL` с любым значением будет получен результат `NULL`, а не `FALSE` и не `0`. Более того, `NULL` не равно `NULL`!",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 422,
  "fields": {
    "question": "## Что такое _«временная таблица»_? Для чего она используется?",
    "answer": "**Временная таблица** - это объект базы данных, который хранится и управляется системой базы данных на временной основе. Они могут быть локальными или глобальными. Используется для сохранения результатов вызова хранимой процедуры, уменьшение числа строк при соединениях, агрегирование данных из различных источников или как замена курсоров и параметризованных представлений.",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 423,
  "fields": {
    "question": "## Что такое _«представление» (view)_ и для чего оно применяется?",
    "answer": "**Представление**, View - виртуальная таблица, представляющая данные одной или более таблиц альтернативным образом. Представления широко используются когда необходимо представить структуру базы данных в удобном для восприятия человеком виде, а так же в соображениях безопасности, предоставляя пользователям возможность обращаться к данным, но не разрешая им доступ к исходным таблицам.\n\nВ действительности представление – всего лишь результат выполнения оператора `SELECT`, который хранится в структуре памяти, напоминающей SQL таблицу. Они работают в запросах и операторах DML точно также как и основные таблицы, но не содержат никаких собственных данных. Представления значительно расширяют возможности управления данными. Это способ дать публичный доступ к некоторой (но не всей) информации в таблице.\n\nДля создания представления используется оператор SQL CREATE и синтаксис выглядит следующим образом:\n\n```sql\nCREATE VIEW view_name\nAS SELECT column_name\nFROM table_name\nWHERE condition\n```",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 424,
  "fields": {
    "question": "## Каков общий синтаксис оператора `SELECT`?",
    "answer": "`SELECT` - оператор DML SQL, возвращающий набор данных (выборку) из базы данных, удовлетворяющих заданному условию. Имеет следующую структуру:\n\n```sql\nSELECT\n       [DISTINCT | DISTINCTROW | ALL]\n       select_expression,...\n   FROM table_references\n     [WHERE where_definition]\n     [GROUP BY {unsigned_integer | column | formula}]\n     [HAVING where_definition]\n     [ORDER BY {unsigned_integer | column | formula} [ASC | DESC], ...]\n```",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 425,
  "fields": {
    "question": "## Что такое `JOIN`?",
    "answer": "**JOIN** - оператор языка SQL, который является реализацией операции соединения реляционной алгебры. Предназначен для обеспечения выборки данных из двух таблиц и включения этих данных в один результирующий набор.\n\nОсобенностями операции соединения являются следующее:\n\n- в схему таблицы-результата входят столбцы обеих исходных таблиц (таблиц-операндов), то есть схема результата является «сцеплением» схем операндов;\n- каждая строка таблицы-результата является «сцеплением» строки из одной таблицы-операнда со строкой второй таблицы-операнда;\n- при необходимости соединения не двух, а нескольких таблиц, операция соединения применяется несколько раз (последовательно).\n\n```sql\nSELECT\n  field_name [,... n]\nFROM\n  Table1\n  {INNER | {LEFT | RIGHT | FULL} OUTER | CROSS } JOIN\n  Table2\n    {ON <condition> | USING (field_name [,... n])}\n```",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 426,
  "fields": {
    "question": "## Какие существуют типы `JOIN`?",
    "answer": "**(INNER) JOIN**\nРезультатом объединения таблиц являются записи, общие для левой и правой таблиц. Порядок таблиц для оператора не важен, поскольку оператор является симметричным.\n\n**LEFT (OUTER) JOIN**\nПроизводит выбор всех записей первой таблицы и соответствующих им записей второй таблицы. Если записи во второй таблице не найдены, то вместо них подставляется пустой результат (`NULL`). Порядок таблиц для оператора важен, поскольку оператор не является симметричным.\n\n**RIGHT (OUTER) JOIN**\n`LEFT JOIN` с операндами, расставленными в обратном порядке. Порядок таблиц для оператора важен, поскольку оператор не является симметричным.\n\n**FULL (OUTER) JOIN**\nРезультатом объединения таблиц являются все записи, которые присутствуют в таблицах. Порядок таблиц для оператора не важен, поскольку оператор является симметричным.\n\n**CROSS JOIN (декартово произведение)**\nПри выборе каждая строка одной таблицы объединяется с каждой строкой второй таблицы, давая тем самым все возможные сочетания строк двух таблиц. Порядок таблиц для оператора не важен, поскольку оператор является симметричным.",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 427,
  "fields": {
    "question": "## Что лучше использовать `JOIN` или подзапросы?",
    "answer": "Обычно лучше использовать `JOIN`, поскольку в большинстве случаев он более понятен и лучше оптимизируется СУБД (но 100% этого гарантировать нельзя). Так же `JOIN` имеет заметное преимущество над подзапросами в случае, когда список выбора `SELECT` содержит столбцы более чем из одной таблицы.\n\nПодзапросы лучше использовать в случаях, когда нужно вычислять агрегатные значения и использовать их для сравнений во внешних запросах.",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 428,
  "fields": {
    "question": "## Для чего используется оператор `HAVING`?",
    "answer": "`HAVING` используется для фильтрации результата `GROUP BY` по заданным логическим условиям.",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 429,
  "fields": {
    "question": "## В чем различие между операторами `HAVING` и `WHERE`?",
    "answer": "`WHERE` - это ограничивающее выражение. Оно выполняется до того, как будет получен результат операции. WHERE служит для задания дополнительного условия выборки, операций вставки, редактирования и удаления записей. Условие (condition) может включать в себя предикаты AND, OR, NOT, LIKE, BETWEEN, IS, IN, ключевое слово NULL, операторы сравнения и равенства (<, >, =).\n\n```sql\nSELECT * FROM Planets WHERE Radius BETWEEN 3000 AND 9000\n```\n\n`HAVING` - Оператор SQL HAVING является указателем на результат выполнения агрегатных функций. Агрегатной функцией в языке SQL называется функция, возвращающая какое-либо одно значение по набору значений столбца. Такими функциями являются: SQL COUNT(), SQL MIN(), SQL MAX(), SQL AVG(), SQL SUM().\n\n```sql\nSELECT Singer, SUM(Sale)\nFROM Artists\nGROUP BY Singer\nHAVING SUM(Sale) > 2000000\n```\n\nВыражения WHERE используются вместе с операциями SELECT, UPDATE, DELETE, в то время как HAVING только с SELECT и предложением GROUP BY.",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 430,
  "fields": {
    "question": "## Для чего используется оператор `ORDER BY`?",
    "answer": "**ORDER BY** упорядочивает вывод запроса согласно значениям в том или ином количестве выбранных столбцов. Многочисленные столбцы упорядочиваются один внутри другого. Возможно определять возрастание `ASC` или убывание `DESC` для каждого столбца. По умолчанию установлено - возрастание.",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 8,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 431,
  "fields": {
    "question": "## Для чего используется оператор `GROUP BY`?",
    "answer": "`GROUP BY` используется для агрегации записей результата по заданному столбцу.",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 432,
  "fields": {
    "question": "## Как `GROUP BY` обрабатывает значение `NULL`?",
    "answer": "При использовании `GROUP BY` все значения `NULL` считаются равными.",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 433,
  "fields": {
    "question": "## В чем разница между операторами `GROUP BY` и `DISTINCT`?",
    "answer": "`DISTINCT` указывает, что для вычислений используются только уникальные значения столбца. `NULL` считается как отдельное значение. DISTINCT нашел широкое применение в операторе SQL SELECT, для выборки уникальных значений. Так же используется в агрегатных функциях.\n\n```sql\nSELECT DISTINCT column_name FROM table_name\n```\n\n`GROUP BY` используется для объединения результатов выборки по одному или нескольким столбцам. создает отдельную группу для всех возможных значений (включая значение `NULL`).\n\nЕсли нужно удалить только дубликаты лучше использовать `DISTINCT`, `GROUP BY` лучше использовать для определения групп записей, к которым могут применяться агрегатные функции.",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 434,
  "fields": {
    "question": "## Перечислите основные агрегатные функции.",
    "answer": "**Агрегатных функции** - функции, которые берут группы значений и сводят их к одиночному значению.\n\nSQL предоставляет несколько агрегатных функций:\n\n`COUNT` - производит подсчет записей, удовлетворяющих условию запроса;\n`SUM` - вычисляет арифметическую сумму всех значений колонки;\n`AVG` - вычисляет среднее арифметическое всех значений;\n`MAX` - определяет наибольшее из всех выбранных значений;\n`MIN` - определяет наименьшее из всех выбранных значений.",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 435,
  "fields": {
    "question": "## В чем разница между `COUNT(*)` и `COUNT({column})`?",
    "answer": "`COUNT (*)` подсчитывает количество записей в таблице, не игнорируя значение NULL, поскольку эта функция оперирует записями, а не столбцами.\n\n`COUNT ({column})` подсчитывает количество значений в `{column}`. При подсчете количества значений столбца эта форма функции `COUNT` не принимает во внимание значение `NULL`.",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 436,
  "fields": {
    "question": "## Что делает оператор `EXISTS`?",
    "answer": "`EXISTS` берет подзапрос, как аргумент, и оценивает его как `TRUE`, если подзапрос возвращает какие-либо записи и `FALSE`, если нет.",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 437,
  "fields": {
    "question": "## Для чего используются операторы `IN`, `BETWEEN`, `LIKE`?",
    "answer": "`IN` - определяет набор значений.\n\n```sql\nSELECT * FROM Persons WHERE name IN ('Ivan','Petr','Pavel');\n```\n\n`BETWEEN` определяет диапазон значений. В отличие от `IN`, `BETWEEN` чувствителен к порядку, и первое значение в предложении должно быть первым по алфавитному или числовому порядку.\n\n```sql\nSELECT * FROM Persons WHERE age BETWEEN 20 AND 25;\n```\n\n`LIKE` применим только к полям типа `CHAR` или `VARCHAR`, с которыми он используется чтобы находить подстроки. В качестве условия используются _символы шаблонизации (wildkards_) - специальные символы, которые могут соответствовать чему-нибудь:\n\n- `_` замещает любой одиночный символ. Например, `'b_t'` будет соответствовать словам `'bat'` или `'bit'`, но не будет соответствовать `'brat'`.\n\n- `%` замещает последовательность любого числа символов. Например `'%p%t'` будет соответствовать словам `'put'`, `'posit'`, или `'opt'`, но не `'spite'`.\n\n```sql\nSELECT * FROM UNIVERSITY WHERE NAME LIKE '%o';\n```",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 438,
  "fields": {
    "question": "## Для чего применяется ключевое слово `UNION`?",
    "answer": "В языке SQL ключевое слово `UNION` применяется для объединения результатов двух SQL-запросов в единую таблицу, состоящую из схожих записей. Оба запроса должны возвращать одинаковое число столбцов и совместимые типы данных в соответствующих столбцах. Необходимо отметить, что `UNION` сам по себе не гарантирует порядок записей. Записи из второго запроса могут оказаться в начале, в конце или вообще перемешаться с записями из первого запроса. В случаях, когда требуется определенный порядок, необходимо использовать `ORDER BY`.\r\n\r\nС удалением дублей:\r\n\r\n```sql\r\nSELECT * FROM имя_таблицы1 WHERE условие\r\n\tUNION SELECT * FROM имя_таблицы2 WHERE условие\r\n```\r\n\r\nБез удаления дублей:\r\n\r\n```sql\r\nSELECT * FROM имя_таблицы1 WHERE условие\r\n\tUNION ALL SELECT * FROM имя_таблицы2 WHERE условие\r\n```\r\n\r\nМожно объединять не две таблицы, а три или более:\r\n\r\n```sql\r\nSELECT * FROM имя_таблицы1 WHERE условие\r\n\tUNION SELECT * FROM имя_таблицы2 WHERE условие\r\n\tUNION SELECT * FROM имя_таблицы3 WHERE условие\r\n\tUNION SELECT * FROM имя_таблицы4 WHERE услови\r\n```",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 5,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 439,
  "fields": {
    "question": "## Какие ограничения на целостность данных существуют в SQL?",
    "answer": "**sql constraint**\n\n`PRIMARY KEY` - набор полей (1 или более), значения которых образуют уникальную комбинацию и используются для однозначной идентификации записи в таблице. Для таблицы может быть создано только одно такое ограничение. Данное ограничение используется для обеспечения целостности сущности, которая описана таблицей.\n\n`CHECK` используется для ограничения множества значений, которые могут быть помещены в данный столбец. Это ограничение используется для обеспечения целостности предметной области, которую описывают таблицы в базе.\n\n`UNIQUE` обеспечивает отсутствие дубликатов в столбце или наборе столбцов.\n\n`FOREIGN KEY` защищает от действий, которые могут нарушить связи между таблицами. `FOREIGN KEY` в одной таблице указывает на `PRIMARY KEY` в другой. Поэтому данное ограничение нацелено на то, чтобы не было записей `FOREIGN KEY`, которым не отвечают записи `PRIMARY KEY`.",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 440,
  "fields": {
    "question": "## Какие отличия между ограничениями `PRIMARY` и `UNIQUE`?",
    "answer": "По умолчанию ограничение `PRIMARY` создает кластерный индекс на столбце, а `UNIQUE` - некластерный. Другим отличием является то, что `PRIMARY` не разрешает `NULL` записей, в то время как `UNIQUE` разрешает одну (а в некоторых СУБД несколько) `NULL` запись.",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 441,
  "fields": {
    "question": "## Может ли значение в столбце, на который наложено ограничение `FOREIGN KEY`, равняться `NULL`?",
    "answer": "Может, если на данный столбец не наложено ограничение `NOT NULL`.",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 442,
  "fields": {
    "question": "## Как создать индекс?",
    "answer": "Индекс можно создать либо с помощью выражения `CREATE INDEX`:\n\n```sql\nCREATE INDEX index_name ON table_name (column_name)\n```\n\nлибо указав ограничение целостности в виде уникального `UNIQUE` или первичного `PRIMARY` ключа в операторе создания таблицы `CREATE TABLE`.",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 443,
  "fields": {
    "question": "## Что делает оператор `MERGE`?",
    "answer": "`MERGE` позволяет осуществить слияние данных одной таблицы с данными другой таблицы. При слиянии таблиц проверяется условие, и если оно истинно, то выполняется `UPDATE`, а если нет - `INSERT`. При этом изменять поля таблицы в секции `UPDATE`, по которым идет связывание двух таблиц, нельзя.",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 444,
  "fields": {
    "question": "## В чем отличие между операторами `DELETE` и `TRUNCATE`?",
    "answer": "`DELETE` - оператор DML, удаляет записи из таблицы, которые удовлетворяют критерию `WHERE` при этом задействуются триггеры, ограничения и т.д.\n\n`TRUNCATE` - DDL оператор. удаляет таблицу (для мгновенной очистки всех строк) и создает ее заново. Причем если на эту таблицу есть ссылки `FOREGIN KEY` или таблица используется в репликации, то пересоздать такую таблицу не получится.\n\n- Оператор SQL TRUNCATE не ведет запись об удаленных данных в журнал событий.\n- SQL DELETE осуществляет блокировку построчно, оператор SQL TRUNCATE по всей странице целиком. Вследствие этого, оператор SQL TRUNCATE не возвращает никакого значения, SQL DELETE же, возвращает количество удаленных строк.\n- После применения оператора SQL DELETE возможно сделать откат операции и восстановить удаленные данные (команда ROLLBACK). При применении оператора SQL TRUNCATE этого сделать нельзя, однако в СУБД MS SQL Server, оператор может применяться в транзакциях.",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 445,
  "fields": {
    "question": "## Что делает оператор `EXPLAIN`?",
    "answer": "```sql\nEXPLAIN имя_таблицы\nEXPLAIN SELECT опции_выборки\n```\n\nЕсли оператор SELECT предваряется ключевым словом EXPLAIN, MySQL сообщит о том, как будет производиться обработка SELECT, и предоставит информацию о порядке и методе связывания таблиц.\n\nПри помощи EXPLAIN можно выяснить, когда стоит снабдить таблицы индексами, чтобы получить более быструю выборку, использующую индексы для поиска записей. Кроме того, можно проверить, насколько удачный порядок связывания таблиц был выбран оптимизатором. Заставить оптимизатор связывать таблицы в заданном порядке можно при помощи указания STRAIGHT_JOIN.\n\nДля непростых соединений EXPLAIN возвращает строку информации о каждой из использованных в работе оператора SELECT таблиц. Таблицы перечисляются в том порядке, в котором они будут считываться. MySQL выполняет все связывания за один проход (метод называется \"single-sweep multi-join\"). Делается это так: MySQL читает строку из первой таблицы, находит совпадающую строку во второй таблице, затем - в третьей, и так далее. Когда обработка всех таблиц завершается, MySQL выдает выбранные столбцы и обходит в обратном порядке список таблиц до тех пор, пока не будет найдена таблица с наибольшим совпадением строк. Следующая строка считывается из этой таблицы и процесс продолжается в следующей таблице.\n\n```sql\n********************** 1. row **********************\nid: 1\nselect_type: SIMPLE\ntable: categories\ntype: ALL\npossible_keys: NULL\nkey: NULL\nkey_len: NULL\nref: NULL\nrows: 4\nExtra:\n1 row in set (0.00 sec)\n```\n\n- id – порядковый номер для каждого SELECT’а внутри запроса (когда имеется несколько подзапросов)\n  select_type – тип запроса SELECT.\n\n- SIMPLE — Простой запрос SELECT без подзапросов или UNION’ов\n- PRIMARY – данный SELECT – самый внешний запрос в JOIN’е\n- DERIVED – данный SELECT является частью подзапроса внутри FROM\n- SUBQUERY – первый SELECT в подзапросе\n- DEPENDENT SUBQUERY – подзапрос, который зависит от внешнего запроса\n- UNCACHABLE SUBQUERY – не кешируемый подзапрос (существуют определенные условия для того, чтобы запрос кешировался)\n- UNION – второй или последующий SELECT в UNION’е\n- DEPENDENT UNION – второй или последующий SELECT в UNION’е, зависимый от внешнего запроса\n- UNION RESULT – результат UNION’а\n\n- Table – таблица, к которой относится выводимая строка\n- Type — указывает на то, как MySQL связывает используемые таблицы. Это одно из наиболее полезных полей в выводе потому, что может сообщать об отсутствующих индексах или почему написанный запрос должен быть пересмотрен и переписан.\n  Возможные значения:\n\n- System – таблица имеет только одну строку\n- Const – таблица имеет только одну соответствующую строку, которая проиндексирована. Это наиболее быстрый тип соединения потому, что таблица читается только один раз и значение строки может восприниматься при дальнейших соединениях как константа.\n- Eq_ref – все части индекса используются для связывания. Используемые индексы: PRIMARY KEY или UNIQUE NOT NULL. Это еще один наилучший возможный тип связывания.\n- Ref – все соответствующие строки индексного столбца считываются для каждой комбинации строк из предыдущей таблицы. Этот тип соединения для индексированных столбцов выглядит как использование операторов = или < = >\n- Fulltext – соединение использует полнотекстовый индекс таблицы\n- Ref_or_null – то же самое, что и ref, но также содержит строки со значением null для столбца\n- Index_merge – соединение использует список индексов для получения результирующего набора. Столбец key вывода команды EXPLAIN будет содержать список использованных индексов.\n- Unique_subquery – подзапрос IN возвращает только один результат из таблицы и использует первичный ключ.\n- Index_subquery – тоже, что и предыдущий, но возвращает более одного результата.\n- Range – индекс, использованный для нахождения соответствующей строки в определенном диапазоне, обычно, когда ключевой столбец сравнивается с константой, используя операторы вроде: BETWEEN, IN, >, >=, etc.\n- Index – сканируется все дерево индексов для нахождения соответствующих строк.\n- All – Для нахождения соответствующих строк используются сканирование всей таблицы. Это наихудший тип соединения и обычно указывает на отсутствие подходящих индексов в таблице.\n\n- Possible_keys – показывает индексы, которые могут быть использованы для нахождения строк в таблице. На практике они могут использоваться, а могут и не использоваться. Фактически, этот столбец может сослужить добрую службу в деле оптимизации запросов, т.к значение NULL указывает на то, что не найдено ни одного подходящего индекса .\n- Key– указывает на использованный индекс. Этот столбец может содержать индекс, не указанный в столбце possible_keys. В процессе соединения таблиц оптимизатор ищет наилучшие варианты и может найти ключи, которые не отображены в possible_keys, но являются более оптимальными для использования.\n- Key_len – длина индекса, которую оптимизатор MySQL выбрал для использования. Например, значение key_len, равное 4, означает, что памяти требуется для хранения 4 знаков. На эту тему вот cсылка\n- Ref – указываются столбцы или константы, которые сравниваются с индексом, указанным в поле key. MySQL выберет либо значение константы для сравнения, либо само поле, основываясь на плане выполнения запроса.\n- Rows – отображает число записей, обработанных для получения выходных данных. Это еще одно очень важное поле, которое дает повод оптимизировать запросы, особенно те, которые используют JOIN’ы и подзапросы.\n- Extra – содержит дополнительную информацию, относящуюся к плану выполнения запроса. Такие значения как “Using temporary”, “Using filesort” и т.д могут быть индикатором проблемного запроса. С полным списком возможных значений вы можете ознакомиться здесь",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 446,
  "fields": {
    "question": "## Что такое _«RETURNING»_?",
    "answer": "Иногда бывает полезно получать данные из модифицируемых строк в процессе их обработки. Это возможно с использованием предложения RETURNING, которое можно задать для команд INSERT, UPDATE и DELETE. Применение RETURNING позволяет обойтись без дополнительного запроса к базе для сбора данных и это особенно ценно, когда как-то иначе трудно получить изменённые строки надёжным образом.\n\nТочно работает в PostgreSQL\n\n```sql\nINSERT INTO users (firstname, lastname) VALUES ('Joe', 'Cool') RETURNING id;\n\nВ команде UPDATE данные, выдаваемые в RETURNING, образуются новым содержимым изменённой строки. Например:\nUPDATE products SET price = price * 1.10\n  WHERE price <= 99.99\n  RETURNING name, price AS new_price;\n\nВ команде DELETE данные, выдаваемые в RETURNING, образуются содержимым удалённой строки. Например:\nDELETE FROM products\n  WHERE obsoletion_date = 'today'\n  RETURNING *;\n```",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 447,
  "fields": {
    "question": "## Что такое _«хранимая процедура»_?",
    "answer": "**Хранимая процедура** — объект базы данных, представляющий собой набор SQL-инструкций, который хранится на сервере. Хранимые процедуры очень похожи на обыкновенные процедуры языков высокого уровня, у них могут быть входные и выходные параметры и локальные переменные, в них могут производиться числовые вычисления и операции над символьными данными, результаты которых могут присваиваться переменным и параметрам. В хранимых процедурах могут выполняться стандартные операции с базами данных (как DDL, так и DML). Кроме того, в хранимых процедурах возможны циклы и ветвления, то есть в них могут использоваться инструкции управления процессом исполнения.\r\n\r\nХранимые процедуры позволяют повысить производительность, расширяют возможности программирования и поддерживают функции безопасности данных. В большинстве СУБД при первом запуске хранимой процедуры она компилируется (выполняется синтаксический анализ и генерируется план доступа к данным) и в дальнейшем её обработка осуществляется быстрее.",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 448,
  "fields": {
    "question": "## Что такое _«триггер»_?",
    "answer": "**Триггер (trigger)** — это хранимая процедура особого типа, которую пользователь не вызывает непосредственно, а исполнение которой обусловлено действием по модификации данных: добавлением, удалением или изменением данных в заданной таблице реляционной базы данных. Триггеры применяются для обеспечения целостности данных и реализации сложной бизнес-логики. Триггер запускается сервером автоматически и все производимые им модификации данных рассматриваются как выполняемые в транзакции, в которой выполнено действие, вызвавшее срабатывание триггера. Соответственно, в случае обнаружения ошибки или нарушения целостности данных может произойти откат этой транзакции.\r\n\r\nМомент запуска триггера определяется с помощью ключевых слов `BEFORE` (триггер запускается до выполнения связанного с ним события) или `AFTER` (после события). В случае, если триггер вызывается до события, он может внести изменения в модифицируемую событием запись. Кроме того, триггеры могут быть привязаны не к таблице, а к представлению (VIEW). В этом случае с их помощью реализуется механизм «обновляемого представления». В этом случае ключевые слова `BEFORE` и `AFTER` влияют лишь на последовательность вызова триггеров, так как собственно событие (удаление, вставка или обновление) не происходит.",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 3,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 449,
  "fields": {
    "question": "## Что такое _«курсор»_?",
    "answer": "**Курсор** — это объект базы данных, который позволяет приложениям работать с записями «по-одной», а не сразу с множеством, как это делается в обычных SQL командах.\n\nПорядок работы с курсором такой:\n\n- Определить курсор (`DECLARE`)\n- Открыть курсор (`OPEN`)\n- Получить запись из курсора (`FETCH`)\n- Обработать запись...\n- Закрыть курсор (`CLOSE`)\n- Удалить ссылку курсора (`DEALLOCATE`). Когда удаляется последняя ссылка курсора, SQL освобождает структуры данных, составляющие курсор.",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 450,
  "fields": {
    "question": "## Опишите разницу типов данных `DATETIME` и `TIMESTAMP`.",
    "answer": "`DATETIME` предназначен для хранения целого числа: `YYYYMMDDHHMMSS`. И это время не зависит от временной зоны настроенной на сервере.\nРазмер: 8 байт\n\n`TIMESTAMP` хранит значение равное количеству секунд, прошедших с полуночи 1 января 1970 года по усреднённому времени Гринвича. При получении из базы отображается с учётом часового пояса. Размер: 4 байта",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 451,
  "fields": {
    "question": "## Для каких числовых типов недопустимо использовать операции сложения/вычитания?",
    "answer": "В качестве операндов операций сложения и вычитания нельзя использовать числовой тип `BIT`.",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 452,
  "fields": {
    "question": "## Какое назначение у операторов `PIVOT` и `UNPIVOT` в Transact-SQL?",
    "answer": "`PIVOT` и `UNPIVOT` являются нестандартными реляционными операторами, которые поддерживаются Transact-SQL.\n\nОператор `PIVOT` разворачивает возвращающее табличное значение выражение, преобразуя уникальные значения одного столбца выражения в несколько выходных столбцов, а также, в случае необходимости, объединяет оставшиеся повторяющиеся значения столбца и отображает их в выходных данных. Оператор `UNPIVOT` производит действия, обратные `PIVOT`, преобразуя столбцы возвращающего табличное значение выражения в значения столбца.",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 453,
  "fields": {
    "question": "## Расскажите об основных функциях ранжирования в Transact-SQL.",
    "answer": "Ранжирующие функции - это функции, которые возвращают значение для каждой записи группы в результирующем наборе данных. На практике они могут быть использованы, например, для простой нумерации списка, составления рейтинга или постраничной навигации.\n\n`ROW_NUMBER` – функция нумерации в Transact-SQL, которая возвращает просто номер записи.\n\n`RANK` возвращает ранг каждой записи. В данном случае, в отличие от `ROW_NUMBER`, идет уже анализ значений и в случае нахождения одинаковых возвращает одинаковый ранг с пропуском следующего.\n\n`DENSE_RANK` так же возвращает ранг каждой записи, но в отличие от `RANK` в случае нахождения одинаковых значений возвращает ранг без пропуска следующего.\n\n`NTILE` – функция Transact-SQL, которая делит результирующий набор на группы по определенному столбцу.",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 454,
  "fields": {
    "question": "## Для чего используются операторы `INTERSECT`, `EXCEPT` в Transact-SQL?",
    "answer": "Оператор `EXCEPT` возвращает уникальные записи из левого входного запроса, которые не выводятся правым входным запросом.\n\nОператор `INTERSECT` возвращает уникальные записи, выводимые левым и правым входными запросами.",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 0,
    "adds": 0,
    "status": false
  }
},
{
  "model": "cards.card",
  "pk": 455,
  "fields": {
    "question": "## Напишите запрос...",
    "answer": "```sql\r\nCREATE TABLE table (\r\n  id BIGINT(20) NOT NULL AUTO_INCREMENT,\r\n  created TIMESTAMP NOT NULL DEFAULT 0,\r\n  PRIMARY KEY (id)\r\n);\r\n```\r\n\r\nНужно написать запрос который вернет максимальное значение `id` и значение `created` для этого `id`:\r\n\r\n```sql\r\nSELECT id, created FROM table where id = (SELECT MAX(id) FROM table);\r\n```\r\n\r\n---\r\n\r\n```sql\r\nCREATE TABLE track_downloads (\r\n  download_id BIGINT(20) NOT NULL AUTO_INCREMENT,\r\n  track_id INT NOT NULL,\r\n  user_id BIGINT(20) NOT NULL,\r\n  download_time TIMESTAMP NOT NULL DEFAULT 0,\r\n  PRIMARY KEY (download_id)\r\n);\r\n```\r\n\r\nНапишите SQL-запрос, возвращающий все пары `(download_count, user_count)`, удовлетворяющие следующему условию: `user_count` — общее ненулевое число пользователей, сделавших ровно `download_count` скачиваний `19 ноября 2010 года`:\r\n\r\n```sql\r\nSELECT DISTINCT download_count, COUNT(*) AS user_count\r\nFROM (\r\n    SELECT COUNT(*) AS download_count\r\n    FROM track_downloads WHERE download_time=\"2010-11-19\"\r\n    GROUP BY user_id)\r\nAS download_count\r\nGROUP BY download_count;\r\n```",
    "category": 2,
    "upload_date": "2024-03-06T09:11:16Z",
    "views": 4,
    "adds": 2,
    "status": true
  }
},
{
  "model": "cards.tag",
  "pk": 1,
  "fields": {
    "name": "установка_библиотеки"
  }
},
{
  "model": "cards.tag",
  "pk": 2,
  "fields": {
    "name": "принадлежность_элемента"
  }
},
{
  "model": "cards.tag",
  "pk": 3,
  "fields": {
    "name": "соединение_таблиц"
  }
},
{
  "model": "cards.tag",
  "pk": 4,
  "fields": {
    "name": "cpython"
  }
},
{
  "model": "cards.tag",
  "pk": 5,
  "fields": {
    "name": ".pyc"
  }
},
{
  "model": "cards.tag",
  "pk": 6,
  "fields": {
    "name": "возвращение_значения"
  }
},
{
  "model": "cards.tag",
  "pk": 7,
  "fields": {
    "name": "аргументы_функции"
  }
},
{
  "model": "cards.tag",
  "pk": 8,
  "fields": {
    "name": "argmax"
  }
},
{
  "model": "cards.tag",
  "pk": 9,
  "fields": {
    "name": "модуль"
  }
},
{
  "model": "cards.tag",
  "pk": 10,
  "fields": {
    "name": "поиск_файла"
  }
},
{
  "model": "cards.tag",
  "pk": 11,
  "fields": {
    "name": "код"
  }
},
{
  "model": "cards.tag",
  "pk": 12,
  "fields": {
    "name": "процессорное_использование"
  }
},
{
  "model": "cards.tag",
  "pk": 13,
  "fields": {
    "name": "abc"
  }
},
{
  "model": "cards.tag",
  "pk": 14,
  "fields": {
    "name": "error_handling"
  }
},
{
  "model": "cards.tag",
  "pk": 15,
  "fields": {
    "name": "переворот_списка"
  }
},
{
  "model": "cards.tag",
  "pk": 16,
  "fields": {
    "name": "проблемы_python"
  }
},
{
  "model": "cards.tag",
  "pk": 17,
  "fields": {
    "name": "pylint"
  }
},
{
  "model": "cards.tag",
  "pk": 18,
  "fields": {
    "name": "асинхронный_ввод-вывод"
  }
},
{
  "model": "cards.tag",
  "pk": 19,
  "fields": {
    "name": "sql"
  }
},
{
  "model": "cards.tag",
  "pk": 20,
  "fields": {
    "name": "вычисление_длины_строки"
  }
},
{
  "model": "cards.tag",
  "pk": 21,
  "fields": {
    "name": "человекочитаемый_формат"
  }
},
{
  "model": "cards.tag",
  "pk": 22,
  "fields": {
    "name": "основы_python"
  }
},
{
  "model": "cards.tag",
  "pk": 23,
  "fields": {
    "name": "обертывание_функций"
  }
},
{
  "model": "cards.tag",
  "pk": 24,
  "fields": {
    "name": "nuitka"
  }
},
{
  "model": "cards.tag",
  "pk": 25,
  "fields": {
    "name": "exit"
  }
},
{
  "model": "cards.tag",
  "pk": 26,
  "fields": {
    "name": "сообщения_об_ошибках"
  }
},
{
  "model": "cards.tag",
  "pk": 27,
  "fields": {
    "name": "автоматическая_очистка_памяти"
  }
},
{
  "model": "cards.tag",
  "pk": 28,
  "fields": {
    "name": "обработка_ошибок"
  }
},
{
  "model": "cards.tag",
  "pk": 29,
  "fields": {
    "name": "getter_setter"
  }
},
{
  "model": "cards.tag",
  "pk": 30,
  "fields": {
    "name": "pathlib"
  }
},
{
  "model": "cards.tag",
  "pk": 31,
  "fields": {
    "name": "main"
  }
},
{
  "model": "cards.tag",
  "pk": 32,
  "fields": {
    "name": "is_not"
  }
},
{
  "model": "cards.tag",
  "pk": 33,
  "fields": {
    "name": "email_validation"
  }
},
{
  "model": "cards.tag",
  "pk": 34,
  "fields": {
    "name": "лямбда-функции"
  }
},
{
  "model": "cards.tag",
  "pk": 35,
  "fields": {
    "name": "обработка_null"
  }
},
{
  "model": "cards.tag",
  "pk": 36,
  "fields": {
    "name": "функция-генератор"
  }
},
{
  "model": "cards.tag",
  "pk": 37,
  "fields": {
    "name": "индексы_максимальных_значений"
  }
},
{
  "model": "cards.tag",
  "pk": 38,
  "fields": {
    "name": "сокращенная_запись"
  }
},
{
  "model": "cards.tag",
  "pk": 39,
  "fields": {
    "name": "python_пакеты"
  }
},
{
  "model": "cards.tag",
  "pk": 40,
  "fields": {
    "name": "подключение_к_базе"
  }
},
{
  "model": "cards.tag",
  "pk": 41,
  "fields": {
    "name": "exec"
  }
},
{
  "model": "cards.tag",
  "pk": 42,
  "fields": {
    "name": "фильтрация_результата"
  }
},
{
  "model": "cards.tag",
  "pk": 43,
  "fields": {
    "name": "статическая_переменная"
  }
},
{
  "model": "cards.tag",
  "pk": 44,
  "fields": {
    "name": "ошибки"
  }
},
{
  "model": "cards.tag",
  "pk": 45,
  "fields": {
    "name": "exists"
  }
},
{
  "model": "cards.tag",
  "pk": 46,
  "fields": {
    "name": "эффективность_алгоритмов"
  }
},
{
  "model": "cards.tag",
  "pk": 47,
  "fields": {
    "name": "работа_с_записями"
  }
},
{
  "model": "cards.tag",
  "pk": 48,
  "fields": {
    "name": "множественное_присваивание"
  }
},
{
  "model": "cards.tag",
  "pk": 49,
  "fields": {
    "name": "структура_проекта"
  }
},
{
  "model": "cards.tag",
  "pk": 50,
  "fields": {
    "name": "арифметические_операции"
  }
},
{
  "model": "cards.tag",
  "pk": 51,
  "fields": {
    "name": "распаковка_значений"
  }
},
{
  "model": "cards.tag",
  "pk": 52,
  "fields": {
    "name": "len"
  }
},
{
  "model": "cards.tag",
  "pk": 53,
  "fields": {
    "name": "модули"
  }
},
{
  "model": "cards.tag",
  "pk": 54,
  "fields": {
    "name": "целостность_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 55,
  "fields": {
    "name": "true_false"
  }
},
{
  "model": "cards.tag",
  "pk": 56,
  "fields": {
    "name": "sched"
  }
},
{
  "model": "cards.tag",
  "pk": 57,
  "fields": {
    "name": "windows"
  }
},
{
  "model": "cards.tag",
  "pk": 58,
  "fields": {
    "name": "pivot"
  }
},
{
  "model": "cards.tag",
  "pk": 59,
  "fields": {
    "name": "list_comprehension"
  }
},
{
  "model": "cards.tag",
  "pk": 60,
  "fields": {
    "name": "работа_со_словарями"
  }
},
{
  "model": "cards.tag",
  "pk": 61,
  "fields": {
    "name": "sympy"
  }
},
{
  "model": "cards.tag",
  "pk": 62,
  "fields": {
    "name": "интерпретация"
  }
},
{
  "model": "cards.tag",
  "pk": 63,
  "fields": {
    "name": "memory_profiler"
  }
},
{
  "model": "cards.tag",
  "pk": 64,
  "fields": {
    "name": "базовые_концепции"
  }
},
{
  "model": "cards.tag",
  "pk": 65,
  "fields": {
    "name": "select"
  }
},
{
  "model": "cards.tag",
  "pk": 66,
  "fields": {
    "name": "cherrypy"
  }
},
{
  "model": "cards.tag",
  "pk": 67,
  "fields": {
    "name": "scope"
  }
},
{
  "model": "cards.tag",
  "pk": 68,
  "fields": {
    "name": "middleware"
  }
},
{
  "model": "cards.tag",
  "pk": 69,
  "fields": {
    "name": "создание_словаря"
  }
},
{
  "model": "cards.tag",
  "pk": 70,
  "fields": {
    "name": "терминал"
  }
},
{
  "model": "cards.tag",
  "pk": 71,
  "fields": {
    "name": "основание_системы_счисления"
  }
},
{
  "model": "cards.tag",
  "pk": 72,
  "fields": {
    "name": "переменные_среды"
  }
},
{
  "model": "cards.tag",
  "pk": 73,
  "fields": {
    "name": "readline"
  }
},
{
  "model": "cards.tag",
  "pk": 74,
  "fields": {
    "name": "уязвимости"
  }
},
{
  "model": "cards.tag",
  "pk": 75,
  "fields": {
    "name": "исключение_stopiteration"
  }
},
{
  "model": "cards.tag",
  "pk": 76,
  "fields": {
    "name": "python/c_api"
  }
},
{
  "model": "cards.tag",
  "pk": 77,
  "fields": {
    "name": "fp"
  }
},
{
  "model": "cards.tag",
  "pk": 78,
  "fields": {
    "name": "индексы_и_значения"
  }
},
{
  "model": "cards.tag",
  "pk": 79,
  "fields": {
    "name": "внутренняя_функция"
  }
},
{
  "model": "cards.tag",
  "pk": 80,
  "fields": {
    "name": "аргументы_по_умолчанию"
  }
},
{
  "model": "cards.tag",
  "pk": 81,
  "fields": {
    "name": "gui"
  }
},
{
  "model": "cards.tag",
  "pk": 82,
  "fields": {
    "name": "неизменяемые_объекты"
  }
},
{
  "model": "cards.tag",
  "pk": 83,
  "fields": {
    "name": "возвращение_множественных_значений"
  }
},
{
  "model": "cards.tag",
  "pk": 84,
  "fields": {
    "name": "генератор_списков"
  }
},
{
  "model": "cards.tag",
  "pk": 85,
  "fields": {
    "name": "bonobo"
  }
},
{
  "model": "cards.tag",
  "pk": 86,
  "fields": {
    "name": "менеджеры_контекста"
  }
},
{
  "model": "cards.tag",
  "pk": 87,
  "fields": {
    "name": "интернирование_строк"
  }
},
{
  "model": "cards.tag",
  "pk": 88,
  "fields": {
    "name": "null"
  }
},
{
  "model": "cards.tag",
  "pk": 89,
  "fields": {
    "name": "immutable"
  }
},
{
  "model": "cards.tag",
  "pk": 90,
  "fields": {
    "name": "итеративный_подход"
  }
},
{
  "model": "cards.tag",
  "pk": 91,
  "fields": {
    "name": "деление_на_ноль"
  }
},
{
  "model": "cards.tag",
  "pk": 92,
  "fields": {
    "name": "os"
  }
},
{
  "model": "cards.tag",
  "pk": 93,
  "fields": {
    "name": "условные_выражения"
  }
},
{
  "model": "cards.tag",
  "pk": 94,
  "fields": {
    "name": "mypy"
  }
},
{
  "model": "cards.tag",
  "pk": 95,
  "fields": {
    "name": "if_else"
  }
},
{
  "model": "cards.tag",
  "pk": 96,
  "fields": {
    "name": "начинающие_разработчики"
  }
},
{
  "model": "cards.tag",
  "pk": 97,
  "fields": {
    "name": "оператор_плюс"
  }
},
{
  "model": "cards.tag",
  "pk": 98,
  "fields": {
    "name": "global_interpreter_lock"
  }
},
{
  "model": "cards.tag",
  "pk": 99,
  "fields": {
    "name": "python3.10"
  }
},
{
  "model": "cards.tag",
  "pk": 100,
  "fields": {
    "name": "iteration"
  }
},
{
  "model": "cards.tag",
  "pk": 101,
  "fields": {
    "name": "union"
  }
},
{
  "model": "cards.tag",
  "pk": 102,
  "fields": {
    "name": "python_frameworks"
  }
},
{
  "model": "cards.tag",
  "pk": 103,
  "fields": {
    "name": "динамическое_изменение_класса"
  }
},
{
  "model": "cards.tag",
  "pk": 104,
  "fields": {
    "name": "удаление_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 105,
  "fields": {
    "name": "обработка_исключений"
  }
},
{
  "model": "cards.tag",
  "pk": 106,
  "fields": {
    "name": "неизменяемый_тип"
  }
},
{
  "model": "cards.tag",
  "pk": 107,
  "fields": {
    "name": "delete"
  }
},
{
  "model": "cards.tag",
  "pk": 108,
  "fields": {
    "name": "pyqt"
  }
},
{
  "model": "cards.tag",
  "pk": 109,
  "fields": {
    "name": "pythonlegacywindowsstdio"
  }
},
{
  "model": "cards.tag",
  "pk": 110,
  "fields": {
    "name": "уникальные_записи"
  }
},
{
  "model": "cards.tag",
  "pk": 111,
  "fields": {
    "name": "работа_с_файлами"
  }
},
{
  "model": "cards.tag",
  "pk": 112,
  "fields": {
    "name": "поведение_функции"
  }
},
{
  "model": "cards.tag",
  "pk": 113,
  "fields": {
    "name": "namespaces"
  }
},
{
  "model": "cards.tag",
  "pk": 114,
  "fields": {
    "name": "недостатки"
  }
},
{
  "model": "cards.tag",
  "pk": 115,
  "fields": {
    "name": "асинхронное_программирование"
  }
},
{
  "model": "cards.tag",
  "pk": 116,
  "fields": {
    "name": "вывод_символов"
  }
},
{
  "model": "cards.tag",
  "pk": 117,
  "fields": {
    "name": "flask-wtf"
  }
},
{
  "model": "cards.tag",
  "pk": 118,
  "fields": {
    "name": "цикл"
  }
},
{
  "model": "cards.tag",
  "pk": 119,
  "fields": {
    "name": "отладка"
  }
},
{
  "model": "cards.tag",
  "pk": 120,
  "fields": {
    "name": "использование_подчеркивания"
  }
},
{
  "model": "cards.tag",
  "pk": 121,
  "fields": {
    "name": "магические_методы"
  }
},
{
  "model": "cards.tag",
  "pk": 122,
  "fields": {
    "name": "читаемость_кода"
  }
},
{
  "model": "cards.tag",
  "pk": 123,
  "fields": {
    "name": "приватные_атрибуты"
  }
},
{
  "model": "cards.tag",
  "pk": 124,
  "fields": {
    "name": "интеграция_с_java"
  }
},
{
  "model": "cards.tag",
  "pk": 125,
  "fields": {
    "name": "команды_pdb"
  }
},
{
  "model": "cards.tag",
  "pk": 126,
  "fields": {
    "name": "адрес_в_памяти"
  }
},
{
  "model": "cards.tag",
  "pk": 127,
  "fields": {
    "name": "интеграция"
  }
},
{
  "model": "cards.tag",
  "pk": 128,
  "fields": {
    "name": "читабельность_кода"
  }
},
{
  "model": "cards.tag",
  "pk": 129,
  "fields": {
    "name": "фреймворк_vs_библиотека"
  }
},
{
  "model": "cards.tag",
  "pk": 130,
  "fields": {
    "name": "valgrind"
  }
},
{
  "model": "cards.tag",
  "pk": 131,
  "fields": {
    "name": "проверка_строк"
  }
},
{
  "model": "cards.tag",
  "pk": 132,
  "fields": {
    "name": "значение_по_умолчанию"
  }
},
{
  "model": "cards.tag",
  "pk": 133,
  "fields": {
    "name": "ошибка"
  }
},
{
  "model": "cards.tag",
  "pk": 134,
  "fields": {
    "name": "ctrl_c"
  }
},
{
  "model": "cards.tag",
  "pk": 135,
  "fields": {
    "name": "управление_пакетами"
  }
},
{
  "model": "cards.tag",
  "pk": 136,
  "fields": {
    "name": "__name__"
  }
},
{
  "model": "cards.tag",
  "pk": 137,
  "fields": {
    "name": "слияние_списков"
  }
},
{
  "model": "cards.tag",
  "pk": 138,
  "fields": {
    "name": "печать_символов"
  }
},
{
  "model": "cards.tag",
  "pk": 139,
  "fields": {
    "name": "перебор_элементов"
  }
},
{
  "model": "cards.tag",
  "pk": 140,
  "fields": {
    "name": "планирование_задач"
  }
},
{
  "model": "cards.tag",
  "pk": 141,
  "fields": {
    "name": "break"
  }
},
{
  "model": "cards.tag",
  "pk": 142,
  "fields": {
    "name": "исполнение_скрипта"
  }
},
{
  "model": "cards.tag",
  "pk": 143,
  "fields": {
    "name": "скомпилированные_файлы"
  }
},
{
  "model": "cards.tag",
  "pk": 144,
  "fields": {
    "name": "глобальные_переменные"
  }
},
{
  "model": "cards.tag",
  "pk": 145,
  "fields": {
    "name": "изменяемые_значения"
  }
},
{
  "model": "cards.tag",
  "pk": 146,
  "fields": {
    "name": "стилевые_соглашения"
  }
},
{
  "model": "cards.tag",
  "pk": 147,
  "fields": {
    "name": "пространства_имен"
  }
},
{
  "model": "cards.tag",
  "pk": 148,
  "fields": {
    "name": "importlib"
  }
},
{
  "model": "cards.tag",
  "pk": 149,
  "fields": {
    "name": "анонимная_функция"
  }
},
{
  "model": "cards.tag",
  "pk": 150,
  "fields": {
    "name": "tuple"
  }
},
{
  "model": "cards.tag",
  "pk": 151,
  "fields": {
    "name": "освобождение_памяти"
  }
},
{
  "model": "cards.tag",
  "pk": 152,
  "fields": {
    "name": "вставка_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 153,
  "fields": {
    "name": "производительность_python"
  }
},
{
  "model": "cards.tag",
  "pk": 154,
  "fields": {
    "name": "scikit-learn"
  }
},
{
  "model": "cards.tag",
  "pk": 155,
  "fields": {
    "name": "синтаксическая_ошибка"
  }
},
{
  "model": "cards.tag",
  "pk": 156,
  "fields": {
    "name": "аномальное_завершение"
  }
},
{
  "model": "cards.tag",
  "pk": 157,
  "fields": {
    "name": "мутабельность"
  }
},
{
  "model": "cards.tag",
  "pk": 158,
  "fields": {
    "name": "принципы_разработки"
  }
},
{
  "model": "cards.tag",
  "pk": 159,
  "fields": {
    "name": "оператор_соединения"
  }
},
{
  "model": "cards.tag",
  "pk": 160,
  "fields": {
    "name": "sys.path"
  }
},
{
  "model": "cards.tag",
  "pk": 161,
  "fields": {
    "name": "копирование_объектов"
  }
},
{
  "model": "cards.tag",
  "pk": 162,
  "fields": {
    "name": "образование"
  }
},
{
  "model": "cards.tag",
  "pk": 163,
  "fields": {
    "name": "установка"
  }
},
{
  "model": "cards.tag",
  "pk": 164,
  "fields": {
    "name": "dir()"
  }
},
{
  "model": "cards.tag",
  "pk": 165,
  "fields": {
    "name": "обновление_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 166,
  "fields": {
    "name": "glob"
  }
},
{
  "model": "cards.tag",
  "pk": 167,
  "fields": {
    "name": "интеграция_с_.net"
  }
},
{
  "model": "cards.tag",
  "pk": 168,
  "fields": {
    "name": "python_vs_java"
  }
},
{
  "model": "cards.tag",
  "pk": 169,
  "fields": {
    "name": "хранимая_процедура"
  }
},
{
  "model": "cards.tag",
  "pk": 170,
  "fields": {
    "name": "статическая_типизация"
  }
},
{
  "model": "cards.tag",
  "pk": 171,
  "fields": {
    "name": "хэш-таблицы"
  }
},
{
  "model": "cards.tag",
  "pk": 172,
  "fields": {
    "name": "файлы"
  }
},
{
  "model": "cards.tag",
  "pk": 173,
  "fields": {
    "name": "протокол_контекстного_менеджера"
  }
},
{
  "model": "cards.tag",
  "pk": 174,
  "fields": {
    "name": "вложенные_функции"
  }
},
{
  "model": "cards.tag",
  "pk": 175,
  "fields": {
    "name": "global"
  }
},
{
  "model": "cards.tag",
  "pk": 176,
  "fields": {
    "name": "замыкания"
  }
},
{
  "model": "cards.tag",
  "pk": 177,
  "fields": {
    "name": "null_значения"
  }
},
{
  "model": "cards.tag",
  "pk": 178,
  "fields": {
    "name": "unique_key"
  }
},
{
  "model": "cards.tag",
  "pk": 179,
  "fields": {
    "name": "сборка_мусора"
  }
},
{
  "model": "cards.tag",
  "pk": 180,
  "fields": {
    "name": "integer_division"
  }
},
{
  "model": "cards.tag",
  "pk": 181,
  "fields": {
    "name": "виртуальное_окружение"
  }
},
{
  "model": "cards.tag",
  "pk": 182,
  "fields": {
    "name": "иммутабельные"
  }
},
{
  "model": "cards.tag",
  "pk": 183,
  "fields": {
    "name": "локальные_переменные"
  }
},
{
  "model": "cards.tag",
  "pk": 184,
  "fields": {
    "name": "argsort"
  }
},
{
  "model": "cards.tag",
  "pk": 185,
  "fields": {
    "name": "разработка"
  }
},
{
  "model": "cards.tag",
  "pk": 186,
  "fields": {
    "name": "spark"
  }
},
{
  "model": "cards.tag",
  "pk": 187,
  "fields": {
    "name": "чтение_и_запись"
  }
},
{
  "model": "cards.tag",
  "pk": 188,
  "fields": {
    "name": "копирование_файлов"
  }
},
{
  "model": "cards.tag",
  "pk": 189,
  "fields": {
    "name": "pass"
  }
},
{
  "model": "cards.tag",
  "pk": 190,
  "fields": {
    "name": "top"
  }
},
{
  "model": "cards.tag",
  "pk": 191,
  "fields": {
    "name": "legb"
  }
},
{
  "model": "cards.tag",
  "pk": 192,
  "fields": {
    "name": "kwargs"
  }
},
{
  "model": "cards.tag",
  "pk": 193,
  "fields": {
    "name": "programming_languages"
  }
},
{
  "model": "cards.tag",
  "pk": 194,
  "fields": {
    "name": "изменяемые_и_неизменяемые_типы"
  }
},
{
  "model": "cards.tag",
  "pk": 195,
  "fields": {
    "name": "extend"
  }
},
{
  "model": "cards.tag",
  "pk": 196,
  "fields": {
    "name": "встраиваемые_устройства"
  }
},
{
  "model": "cards.tag",
  "pk": 197,
  "fields": {
    "name": "оптимизация_запросов"
  }
},
{
  "model": "cards.tag",
  "pk": 198,
  "fields": {
    "name": "глобальная_переменная"
  }
},
{
  "model": "cards.tag",
  "pk": 199,
  "fields": {
    "name": "булевы_значения"
  }
},
{
  "model": "cards.tag",
  "pk": 200,
  "fields": {
    "name": "ordereddict"
  }
},
{
  "model": "cards.tag",
  "pk": 201,
  "fields": {
    "name": "except"
  }
},
{
  "model": "cards.tag",
  "pk": 202,
  "fields": {
    "name": "неизменяемые_типы"
  }
},
{
  "model": "cards.tag",
  "pk": 203,
  "fields": {
    "name": "runtime_error"
  }
},
{
  "model": "cards.tag",
  "pk": 204,
  "fields": {
    "name": "индексы_списка"
  }
},
{
  "model": "cards.tag",
  "pk": 205,
  "fields": {
    "name": "автоматическая_регистрация"
  }
},
{
  "model": "cards.tag",
  "pk": 206,
  "fields": {
    "name": "io"
  }
},
{
  "model": "cards.tag",
  "pk": 207,
  "fields": {
    "name": "изоляция_окружения"
  }
},
{
  "model": "cards.tag",
  "pk": 208,
  "fields": {
    "name": "обмен_значениями"
  }
},
{
  "model": "cards.tag",
  "pk": 209,
  "fields": {
    "name": "json"
  }
},
{
  "model": "cards.tag",
  "pk": 210,
  "fields": {
    "name": "python_dictionary"
  }
},
{
  "model": "cards.tag",
  "pk": 211,
  "fields": {
    "name": "глубокое_копирование"
  }
},
{
  "model": "cards.tag",
  "pk": 212,
  "fields": {
    "name": "максимальное_значение"
  }
},
{
  "model": "cards.tag",
  "pk": 213,
  "fields": {
    "name": "язык_программирования"
  }
},
{
  "model": "cards.tag",
  "pk": 214,
  "fields": {
    "name": "pipenv"
  }
},
{
  "model": "cards.tag",
  "pk": 215,
  "fields": {
    "name": "геттер_и_сеттер"
  }
},
{
  "model": "cards.tag",
  "pk": 216,
  "fields": {
    "name": "transact_sql"
  }
},
{
  "model": "cards.tag",
  "pk": 217,
  "fields": {
    "name": "sys.argv"
  }
},
{
  "model": "cards.tag",
  "pk": 218,
  "fields": {
    "name": "оптимизация_кода"
  }
},
{
  "model": "cards.tag",
  "pk": 219,
  "fields": {
    "name": "синтаксис"
  }
},
{
  "model": "cards.tag",
  "pk": 220,
  "fields": {
    "name": "pythondontwritebytecode"
  }
},
{
  "model": "cards.tag",
  "pk": 221,
  "fields": {
    "name": "try_except_finally"
  }
},
{
  "model": "cards.tag",
  "pk": 222,
  "fields": {
    "name": "непроцедурный_язык"
  }
},
{
  "model": "cards.tag",
  "pk": 223,
  "fields": {
    "name": "функции_python"
  }
},
{
  "model": "cards.tag",
  "pk": 224,
  "fields": {
    "name": "requirements.txt"
  }
},
{
  "model": "cards.tag",
  "pk": 225,
  "fields": {
    "name": "обработка_сигналов"
  }
},
{
  "model": "cards.tag",
  "pk": 226,
  "fields": {
    "name": "операторы"
  }
},
{
  "model": "cards.tag",
  "pk": 227,
  "fields": {
    "name": "веб-фреймворк"
  }
},
{
  "model": "cards.tag",
  "pk": 228,
  "fields": {
    "name": "микрофреймворк"
  }
},
{
  "model": "cards.tag",
  "pk": 229,
  "fields": {
    "name": "unittest"
  }
},
{
  "model": "cards.tag",
  "pk": 230,
  "fields": {
    "name": "ntile"
  }
},
{
  "model": "cards.tag",
  "pk": 231,
  "fields": {
    "name": "исключение_пробелов"
  }
},
{
  "model": "cards.tag",
  "pk": 232,
  "fields": {
    "name": "поиск_элемента"
  }
},
{
  "model": "cards.tag",
  "pk": 233,
  "fields": {
    "name": "автоматизация_задач"
  }
},
{
  "model": "cards.tag",
  "pk": 234,
  "fields": {
    "name": "dunder"
  }
},
{
  "model": "cards.tag",
  "pk": 235,
  "fields": {
    "name": "использование_ресурсов"
  }
},
{
  "model": "cards.tag",
  "pk": 236,
  "fields": {
    "name": "reference_counting"
  }
},
{
  "model": "cards.tag",
  "pk": 237,
  "fields": {
    "name": "проверка_наследования"
  }
},
{
  "model": "cards.tag",
  "pk": 238,
  "fields": {
    "name": "isalpha"
  }
},
{
  "model": "cards.tag",
  "pk": 239,
  "fields": {
    "name": "jit"
  }
},
{
  "model": "cards.tag",
  "pk": 240,
  "fields": {
    "name": "многопоточность"
  }
},
{
  "model": "cards.tag",
  "pk": 241,
  "fields": {
    "name": "truncate"
  }
},
{
  "model": "cards.tag",
  "pk": 242,
  "fields": {
    "name": "работа_с_строками"
  }
},
{
  "model": "cards.tag",
  "pk": 243,
  "fields": {
    "name": "вычисления"
  }
},
{
  "model": "cards.tag",
  "pk": 244,
  "fields": {
    "name": "дескрипторы"
  }
},
{
  "model": "cards.tag",
  "pk": 245,
  "fields": {
    "name": "управление_ресурсами"
  }
},
{
  "model": "cards.tag",
  "pk": 246,
  "fields": {
    "name": "срезы"
  }
},
{
  "model": "cards.tag",
  "pk": 247,
  "fields": {
    "name": "выборка_подстроки"
  }
},
{
  "model": "cards.tag",
  "pk": 248,
  "fields": {
    "name": "azure"
  }
},
{
  "model": "cards.tag",
  "pk": 249,
  "fields": {
    "name": "языки_программирования"
  }
},
{
  "model": "cards.tag",
  "pk": 250,
  "fields": {
    "name": "список"
  }
},
{
  "model": "cards.tag",
  "pk": 251,
  "fields": {
    "name": "новые_функции"
  }
},
{
  "model": "cards.tag",
  "pk": 252,
  "fields": {
    "name": "переопределение_метода"
  }
},
{
  "model": "cards.tag",
  "pk": 253,
  "fields": {
    "name": "numpy"
  }
},
{
  "model": "cards.tag",
  "pk": 254,
  "fields": {
    "name": "статический_анализ"
  }
},
{
  "model": "cards.tag",
  "pk": 255,
  "fields": {
    "name": "модули_python"
  }
},
{
  "model": "cards.tag",
  "pk": 256,
  "fields": {
    "name": "comprehensions"
  }
},
{
  "model": "cards.tag",
  "pk": 257,
  "fields": {
    "name": "syntax_error"
  }
},
{
  "model": "cards.tag",
  "pk": 258,
  "fields": {
    "name": "абсолютный_импорт"
  }
},
{
  "model": "cards.tag",
  "pk": 259,
  "fields": {
    "name": "конфликты_имен"
  }
},
{
  "model": "cards.tag",
  "pk": 260,
  "fields": {
    "name": "классы_типов"
  }
},
{
  "model": "cards.tag",
  "pk": 261,
  "fields": {
    "name": "virtualenv"
  }
},
{
  "model": "cards.tag",
  "pk": 262,
  "fields": {
    "name": "ввод_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 263,
  "fields": {
    "name": "встроенные_методы"
  }
},
{
  "model": "cards.tag",
  "pk": 264,
  "fields": {
    "name": "sequences"
  }
},
{
  "model": "cards.tag",
  "pk": 265,
  "fields": {
    "name": "сетевое_программирование"
  }
},
{
  "model": "cards.tag",
  "pk": 266,
  "fields": {
    "name": "наследование"
  }
},
{
  "model": "cards.tag",
  "pk": 267,
  "fields": {
    "name": "хэш-таблица"
  }
},
{
  "model": "cards.tag",
  "pk": 268,
  "fields": {
    "name": "промежуточное_программное_обеспечение"
  }
},
{
  "model": "cards.tag",
  "pk": 269,
  "fields": {
    "name": "поиск_совпадений"
  }
},
{
  "model": "cards.tag",
  "pk": 270,
  "fields": {
    "name": "распаковка_кортежа"
  }
},
{
  "model": "cards.tag",
  "pk": 271,
  "fields": {
    "name": "модуль_json"
  }
},
{
  "model": "cards.tag",
  "pk": 272,
  "fields": {
    "name": "устаревание_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 273,
  "fields": {
    "name": "pygame"
  }
},
{
  "model": "cards.tag",
  "pk": 274,
  "fields": {
    "name": "unicode"
  }
},
{
  "model": "cards.tag",
  "pk": 275,
  "fields": {
    "name": "создание_экземпляра"
  }
},
{
  "model": "cards.tag",
  "pk": 276,
  "fields": {
    "name": "while"
  }
},
{
  "model": "cards.tag",
  "pk": 277,
  "fields": {
    "name": "блок_finally"
  }
},
{
  "model": "cards.tag",
  "pk": 278,
  "fields": {
    "name": "mvc"
  }
},
{
  "model": "cards.tag",
  "pk": 279,
  "fields": {
    "name": "эффективное_использование_памяти"
  }
},
{
  "model": "cards.tag",
  "pk": 280,
  "fields": {
    "name": "перебор_символов"
  }
},
{
  "model": "cards.tag",
  "pk": 281,
  "fields": {
    "name": "имплементация"
  }
},
{
  "model": "cards.tag",
  "pk": 282,
  "fields": {
    "name": "порядок_разрешения_методов"
  }
},
{
  "model": "cards.tag",
  "pk": 283,
  "fields": {
    "name": "блок_else"
  }
},
{
  "model": "cards.tag",
  "pk": 284,
  "fields": {
    "name": "многопроцессорность"
  }
},
{
  "model": "cards.tag",
  "pk": 285,
  "fields": {
    "name": "буквенно-цифровые_символы"
  }
},
{
  "model": "cards.tag",
  "pk": 286,
  "fields": {
    "name": "closure"
  }
},
{
  "model": "cards.tag",
  "pk": 287,
  "fields": {
    "name": "индексы"
  }
},
{
  "model": "cards.tag",
  "pk": 288,
  "fields": {
    "name": "метаклассы"
  }
},
{
  "model": "cards.tag",
  "pk": 289,
  "fields": {
    "name": "custom_exception"
  }
},
{
  "model": "cards.tag",
  "pk": 290,
  "fields": {
    "name": "filter"
  }
},
{
  "model": "cards.tag",
  "pk": 291,
  "fields": {
    "name": "concurrent.futures"
  }
},
{
  "model": "cards.tag",
  "pk": 292,
  "fields": {
    "name": "примеры_кода"
  }
},
{
  "model": "cards.tag",
  "pk": 293,
  "fields": {
    "name": "поверхностная_копия"
  }
},
{
  "model": "cards.tag",
  "pk": 294,
  "fields": {
    "name": "chmod"
  }
},
{
  "model": "cards.tag",
  "pk": 295,
  "fields": {
    "name": "chr()"
  }
},
{
  "model": "cards.tag",
  "pk": 296,
  "fields": {
    "name": "код_качество"
  }
},
{
  "model": "cards.tag",
  "pk": 297,
  "fields": {
    "name": "методы_строк"
  }
},
{
  "model": "cards.tag",
  "pk": 298,
  "fields": {
    "name": "raw_input"
  }
},
{
  "model": "cards.tag",
  "pk": 299,
  "fields": {
    "name": "black"
  }
},
{
  "model": "cards.tag",
  "pk": 300,
  "fields": {
    "name": "пустой_список"
  }
},
{
  "model": "cards.tag",
  "pk": 301,
  "fields": {
    "name": "after"
  }
},
{
  "model": "cards.tag",
  "pk": 302,
  "fields": {
    "name": "декларативный_язык"
  }
},
{
  "model": "cards.tag",
  "pk": 303,
  "fields": {
    "name": "vulture"
  }
},
{
  "model": "cards.tag",
  "pk": 304,
  "fields": {
    "name": "структурированный_язык_запросов"
  }
},
{
  "model": "cards.tag",
  "pk": 305,
  "fields": {
    "name": "оператор_merge"
  }
},
{
  "model": "cards.tag",
  "pk": 306,
  "fields": {
    "name": "машинное_обучение"
  }
},
{
  "model": "cards.tag",
  "pk": 307,
  "fields": {
    "name": "выбор_языка_программирования"
  }
},
{
  "model": "cards.tag",
  "pk": 308,
  "fields": {
    "name": "преобразование_в_список"
  }
},
{
  "model": "cards.tag",
  "pk": 309,
  "fields": {
    "name": "генерация_последовательностей"
  }
},
{
  "model": "cards.tag",
  "pk": 310,
  "fields": {
    "name": "notimplementederror"
  }
},
{
  "model": "cards.tag",
  "pk": 311,
  "fields": {
    "name": "xss_защита"
  }
},
{
  "model": "cards.tag",
  "pk": 312,
  "fields": {
    "name": "итерируемый_объект"
  }
},
{
  "model": "cards.tag",
  "pk": 313,
  "fields": {
    "name": "потоки"
  }
},
{
  "model": "cards.tag",
  "pk": 314,
  "fields": {
    "name": "динамическое_изменение_поведения"
  }
},
{
  "model": "cards.tag",
  "pk": 315,
  "fields": {
    "name": "обработка_коллекций"
  }
},
{
  "model": "cards.tag",
  "pk": 316,
  "fields": {
    "name": "операции"
  }
},
{
  "model": "cards.tag",
  "pk": 317,
  "fields": {
    "name": "фильтрация_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 318,
  "fields": {
    "name": "subn"
  }
},
{
  "model": "cards.tag",
  "pk": 319,
  "fields": {
    "name": "обнаружение_циклов"
  }
},
{
  "model": "cards.tag",
  "pk": 320,
  "fields": {
    "name": "debugging"
  }
},
{
  "model": "cards.tag",
  "pk": 321,
  "fields": {
    "name": "decimal"
  }
},
{
  "model": "cards.tag",
  "pk": 322,
  "fields": {
    "name": "эффективность_кода"
  }
},
{
  "model": "cards.tag",
  "pk": 323,
  "fields": {
    "name": "экземпляры_классов"
  }
},
{
  "model": "cards.tag",
  "pk": 324,
  "fields": {
    "name": "python_basics"
  }
},
{
  "model": "cards.tag",
  "pk": 325,
  "fields": {
    "name": "научное_моделирование"
  }
},
{
  "model": "cards.tag",
  "pk": 326,
  "fields": {
    "name": "текущий_каталог"
  }
},
{
  "model": "cards.tag",
  "pk": 327,
  "fields": {
    "name": "input"
  }
},
{
  "model": "cards.tag",
  "pk": 328,
  "fields": {
    "name": "выполнение_java_кода"
  }
},
{
  "model": "cards.tag",
  "pk": 329,
  "fields": {
    "name": "mutex"
  }
},
{
  "model": "cards.tag",
  "pk": 330,
  "fields": {
    "name": "улучшения_производительности"
  }
},
{
  "model": "cards.tag",
  "pk": 331,
  "fields": {
    "name": "множества"
  }
},
{
  "model": "cards.tag",
  "pk": 332,
  "fields": {
    "name": "управление_потоком"
  }
},
{
  "model": "cards.tag",
  "pk": 333,
  "fields": {
    "name": "etl"
  }
},
{
  "model": "cards.tag",
  "pk": 334,
  "fields": {
    "name": "начало"
  }
},
{
  "model": "cards.tag",
  "pk": 335,
  "fields": {
    "name": "union_all"
  }
},
{
  "model": "cards.tag",
  "pk": 336,
  "fields": {
    "name": "создание_списков"
  }
},
{
  "model": "cards.tag",
  "pk": 337,
  "fields": {
    "name": "алмазное_наследование"
  }
},
{
  "model": "cards.tag",
  "pk": 338,
  "fields": {
    "name": "программирование"
  }
},
{
  "model": "cards.tag",
  "pk": 339,
  "fields": {
    "name": "redis"
  }
},
{
  "model": "cards.tag",
  "pk": 340,
  "fields": {
    "name": "sorting_algorithms"
  }
},
{
  "model": "cards.tag",
  "pk": 341,
  "fields": {
    "name": "формальный_язык"
  }
},
{
  "model": "cards.tag",
  "pk": 342,
  "fields": {
    "name": "right_join"
  }
},
{
  "model": "cards.tag",
  "pk": 343,
  "fields": {
    "name": "функции"
  }
},
{
  "model": "cards.tag",
  "pk": 344,
  "fields": {
    "name": "python-memcached"
  }
},
{
  "model": "cards.tag",
  "pk": 345,
  "fields": {
    "name": "браузерные_приложения"
  }
},
{
  "model": "cards.tag",
  "pk": 346,
  "fields": {
    "name": "динамическая_библиотека"
  }
},
{
  "model": "cards.tag",
  "pk": 347,
  "fields": {
    "name": "создание_массива"
  }
},
{
  "model": "cards.tag",
  "pk": 348,
  "fields": {
    "name": "pdb"
  }
},
{
  "model": "cards.tag",
  "pk": 349,
  "fields": {
    "name": "исполняемый_скрипт"
  }
},
{
  "model": "cards.tag",
  "pk": 350,
  "fields": {
    "name": "super()"
  }
},
{
  "model": "cards.tag",
  "pk": 351,
  "fields": {
    "name": "implementation"
  }
},
{
  "model": "cards.tag",
  "pk": 352,
  "fields": {
    "name": "присваивание_ссылок"
  }
},
{
  "model": "cards.tag",
  "pk": 353,
  "fields": {
    "name": "avg"
  }
},
{
  "model": "cards.tag",
  "pk": 354,
  "fields": {
    "name": "code_structure"
  }
},
{
  "model": "cards.tag",
  "pk": 355,
  "fields": {
    "name": "арифметические_операторы"
  }
},
{
  "model": "cards.tag",
  "pk": 356,
  "fields": {
    "name": "наука_о_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 357,
  "fields": {
    "name": "ключевое_слово"
  }
},
{
  "model": "cards.tag",
  "pk": 358,
  "fields": {
    "name": "регулярные_выражения"
  }
},
{
  "model": "cards.tag",
  "pk": 359,
  "fields": {
    "name": "фильтрация"
  }
},
{
  "model": "cards.tag",
  "pk": 360,
  "fields": {
    "name": "network"
  }
},
{
  "model": "cards.tag",
  "pk": 361,
  "fields": {
    "name": "in-place"
  }
},
{
  "model": "cards.tag",
  "pk": 362,
  "fields": {
    "name": "необязательные_параметры"
  }
},
{
  "model": "cards.tag",
  "pk": 363,
  "fields": {
    "name": "расширение_функциональности"
  }
},
{
  "model": "cards.tag",
  "pk": 364,
  "fields": {
    "name": "импорт"
  }
},
{
  "model": "cards.tag",
  "pk": 365,
  "fields": {
    "name": "temp_variable"
  }
},
{
  "model": "cards.tag",
  "pk": 366,
  "fields": {
    "name": "python_разработка"
  }
},
{
  "model": "cards.tag",
  "pk": 367,
  "fields": {
    "name": "специальные_переменные"
  }
},
{
  "model": "cards.tag",
  "pk": 368,
  "fields": {
    "name": "sys"
  }
},
{
  "model": "cards.tag",
  "pk": 369,
  "fields": {
    "name": "конструкторы"
  }
},
{
  "model": "cards.tag",
  "pk": 370,
  "fields": {
    "name": "глубокая_копия"
  }
},
{
  "model": "cards.tag",
  "pk": 371,
  "fields": {
    "name": "csrf_защита"
  }
},
{
  "model": "cards.tag",
  "pk": 372,
  "fields": {
    "name": "крупномасштабные_приложения"
  }
},
{
  "model": "cards.tag",
  "pk": 373,
  "fields": {
    "name": "сохранение_порядка"
  }
},
{
  "model": "cards.tag",
  "pk": 374,
  "fields": {
    "name": "различие"
  }
},
{
  "model": "cards.tag",
  "pk": 375,
  "fields": {
    "name": "присваивание"
  }
},
{
  "model": "cards.tag",
  "pk": 376,
  "fields": {
    "name": "итерируемые_объекты"
  }
},
{
  "model": "cards.tag",
  "pk": 377,
  "fields": {
    "name": "заглушка_функции"
  }
},
{
  "model": "cards.tag",
  "pk": 378,
  "fields": {
    "name": "лямбда-функция"
  }
},
{
  "model": "cards.tag",
  "pk": 379,
  "fields": {
    "name": "форматы_пакетов"
  }
},
{
  "model": "cards.tag",
  "pk": 380,
  "fields": {
    "name": "многофункциональность"
  }
},
{
  "model": "cards.tag",
  "pk": 381,
  "fields": {
    "name": "операторы_потока_управления"
  }
},
{
  "model": "cards.tag",
  "pk": 382,
  "fields": {
    "name": "ключевые_особенности"
  }
},
{
  "model": "cards.tag",
  "pk": 383,
  "fields": {
    "name": "with"
  }
},
{
  "model": "cards.tag",
  "pk": 384,
  "fields": {
    "name": "тестовые_случаи"
  }
},
{
  "model": "cards.tag",
  "pk": 385,
  "fields": {
    "name": "locals()"
  }
},
{
  "model": "cards.tag",
  "pk": 386,
  "fields": {
    "name": "логические_операторы"
  }
},
{
  "model": "cards.tag",
  "pk": 387,
  "fields": {
    "name": "суперкласс"
  }
},
{
  "model": "cards.tag",
  "pk": 388,
  "fields": {
    "name": "многострочные_строки"
  }
},
{
  "model": "cards.tag",
  "pk": 389,
  "fields": {
    "name": "биты"
  }
},
{
  "model": "cards.tag",
  "pk": 390,
  "fields": {
    "name": "состояния_потоков"
  }
},
{
  "model": "cards.tag",
  "pk": 391,
  "fields": {
    "name": "sql_запросы"
  }
},
{
  "model": "cards.tag",
  "pk": 392,
  "fields": {
    "name": "переполнение_стека"
  }
},
{
  "model": "cards.tag",
  "pk": 393,
  "fields": {
    "name": "объединение_таблиц"
  }
},
{
  "model": "cards.tag",
  "pk": 394,
  "fields": {
    "name": "срез"
  }
},
{
  "model": "cards.tag",
  "pk": 395,
  "fields": {
    "name": "oop"
  }
},
{
  "model": "cards.tag",
  "pk": 396,
  "fields": {
    "name": "хешируемые_объекты"
  }
},
{
  "model": "cards.tag",
  "pk": 397,
  "fields": {
    "name": "multiprocessing"
  }
},
{
  "model": "cards.tag",
  "pk": 398,
  "fields": {
    "name": "гибкость"
  }
},
{
  "model": "cards.tag",
  "pk": 399,
  "fields": {
    "name": "returning"
  }
},
{
  "model": "cards.tag",
  "pk": 400,
  "fields": {
    "name": "итераторы"
  }
},
{
  "model": "cards.tag",
  "pk": 401,
  "fields": {
    "name": "list_vs_tuple"
  }
},
{
  "model": "cards.tag",
  "pk": 402,
  "fields": {
    "name": "ресурсы_компьютера"
  }
},
{
  "model": "cards.tag",
  "pk": 403,
  "fields": {
    "name": "pyscript"
  }
},
{
  "model": "cards.tag",
  "pk": 404,
  "fields": {
    "name": "удаление_пробелов"
  }
},
{
  "model": "cards.tag",
  "pk": 405,
  "fields": {
    "name": "командная_строка"
  }
},
{
  "model": "cards.tag",
  "pk": 406,
  "fields": {
    "name": "python3.7+"
  }
},
{
  "model": "cards.tag",
  "pk": 407,
  "fields": {
    "name": "реляционная_алгебра"
  }
},
{
  "model": "cards.tag",
  "pk": 408,
  "fields": {
    "name": "gc_collect"
  }
},
{
  "model": "cards.tag",
  "pk": 409,
  "fields": {
    "name": "обязательные_аргументы"
  }
},
{
  "model": "cards.tag",
  "pk": 410,
  "fields": {
    "name": "системы_счисления"
  }
},
{
  "model": "cards.tag",
  "pk": 411,
  "fields": {
    "name": "walrus_оператор"
  }
},
{
  "model": "cards.tag",
  "pk": 412,
  "fields": {
    "name": "преобразование_типов"
  }
},
{
  "model": "cards.tag",
  "pk": 413,
  "fields": {
    "name": "классы_нового_стиля"
  }
},
{
  "model": "cards.tag",
  "pk": 414,
  "fields": {
    "name": "fetch"
  }
},
{
  "model": "cards.tag",
  "pk": 415,
  "fields": {
    "name": "числовые_вычисления"
  }
},
{
  "model": "cards.tag",
  "pk": 416,
  "fields": {
    "name": "append_vs_extend"
  }
},
{
  "model": "cards.tag",
  "pk": 417,
  "fields": {
    "name": "преимущества_python"
  }
},
{
  "model": "cards.tag",
  "pk": 418,
  "fields": {
    "name": "краткость_и_понятность"
  }
},
{
  "model": "cards.tag",
  "pk": 419,
  "fields": {
    "name": "retry"
  }
},
{
  "model": "cards.tag",
  "pk": 420,
  "fields": {
    "name": "capitalize"
  }
},
{
  "model": "cards.tag",
  "pk": 421,
  "fields": {
    "name": "высокопроизводительные_вычисления"
  }
},
{
  "model": "cards.tag",
  "pk": 422,
  "fields": {
    "name": "перевод_строки_в_число"
  }
},
{
  "model": "cards.tag",
  "pk": 423,
  "fields": {
    "name": "isupper"
  }
},
{
  "model": "cards.tag",
  "pk": 424,
  "fields": {
    "name": "методы_класса"
  }
},
{
  "model": "cards.tag",
  "pk": 425,
  "fields": {
    "name": "кодирование"
  }
},
{
  "model": "cards.tag",
  "pk": 426,
  "fields": {
    "name": "получение_документации"
  }
},
{
  "model": "cards.tag",
  "pk": 427,
  "fields": {
    "name": "проверка_содержания_элементов"
  }
},
{
  "model": "cards.tag",
  "pk": 428,
  "fields": {
    "name": "интерактивная_консоль"
  }
},
{
  "model": "cards.tag",
  "pk": 429,
  "fields": {
    "name": "базовый_класс"
  }
},
{
  "model": "cards.tag",
  "pk": 430,
  "fields": {
    "name": "ограничивающее_выражение"
  }
},
{
  "model": "cards.tag",
  "pk": 431,
  "fields": {
    "name": "permutations"
  }
},
{
  "model": "cards.tag",
  "pk": 432,
  "fields": {
    "name": "модуль_shutil"
  }
},
{
  "model": "cards.tag",
  "pk": 433,
  "fields": {
    "name": "описание_api"
  }
},
{
  "model": "cards.tag",
  "pk": 434,
  "fields": {
    "name": "преимущества_numpy"
  }
},
{
  "model": "cards.tag",
  "pk": 435,
  "fields": {
    "name": "ранжирующие_функции"
  }
},
{
  "model": "cards.tag",
  "pk": 436,
  "fields": {
    "name": "классификация"
  }
},
{
  "model": "cards.tag",
  "pk": 437,
  "fields": {
    "name": "последовательность_значений"
  }
},
{
  "model": "cards.tag",
  "pk": 438,
  "fields": {
    "name": "выбор_языка"
  }
},
{
  "model": "cards.tag",
  "pk": 439,
  "fields": {
    "name": "memcached"
  }
},
{
  "model": "cards.tag",
  "pk": 440,
  "fields": {
    "name": "изменение_переменных"
  }
},
{
  "model": "cards.tag",
  "pk": 441,
  "fields": {
    "name": "gil"
  }
},
{
  "model": "cards.tag",
  "pk": 442,
  "fields": {
    "name": "linux"
  }
},
{
  "model": "cards.tag",
  "pk": 443,
  "fields": {
    "name": "pycharm"
  }
},
{
  "model": "cards.tag",
  "pk": 444,
  "fields": {
    "name": "веб_разработка"
  }
},
{
  "model": "cards.tag",
  "pk": 445,
  "fields": {
    "name": "сборщики"
  }
},
{
  "model": "cards.tag",
  "pk": 446,
  "fields": {
    "name": "запуск_скрипта"
  }
},
{
  "model": "cards.tag",
  "pk": 447,
  "fields": {
    "name": "многомерные_массивы"
  }
},
{
  "model": "cards.tag",
  "pk": 448,
  "fields": {
    "name": "modulus"
  }
},
{
  "model": "cards.tag",
  "pk": 449,
  "fields": {
    "name": "разница"
  }
},
{
  "model": "cards.tag",
  "pk": 450,
  "fields": {
    "name": "анонимные_функции"
  }
},
{
  "model": "cards.tag",
  "pk": 451,
  "fields": {
    "name": "explain"
  }
},
{
  "model": "cards.tag",
  "pk": 452,
  "fields": {
    "name": "вставка_обновление_удаление"
  }
},
{
  "model": "cards.tag",
  "pk": 453,
  "fields": {
    "name": "модульное_тестирование"
  }
},
{
  "model": "cards.tag",
  "pk": 454,
  "fields": {
    "name": "контроллер"
  }
},
{
  "model": "cards.tag",
  "pk": 455,
  "fields": {
    "name": "поверхностное_копирование"
  }
},
{
  "model": "cards.tag",
  "pk": 456,
  "fields": {
    "name": "multiline"
  }
},
{
  "model": "cards.tag",
  "pk": 457,
  "fields": {
    "name": "matplotlib"
  }
},
{
  "model": "cards.tag",
  "pk": 458,
  "fields": {
    "name": "order_by"
  }
},
{
  "model": "cards.tag",
  "pk": 459,
  "fields": {
    "name": "seaborn"
  }
},
{
  "model": "cards.tag",
  "pk": 460,
  "fields": {
    "name": "оператор_with"
  }
},
{
  "model": "cards.tag",
  "pk": 461,
  "fields": {
    "name": "дистрибутив"
  }
},
{
  "model": "cards.tag",
  "pk": 462,
  "fields": {
    "name": "внутренняя_реализация"
  }
},
{
  "model": "cards.tag",
  "pk": 463,
  "fields": {
    "name": "работа_с_списками"
  }
},
{
  "model": "cards.tag",
  "pk": 464,
  "fields": {
    "name": "безопасность_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 465,
  "fields": {
    "name": "относительный_импорт"
  }
},
{
  "model": "cards.tag",
  "pk": 466,
  "fields": {
    "name": "try_except_else"
  }
},
{
  "model": "cards.tag",
  "pk": 467,
  "fields": {
    "name": "рекурсия"
  }
},
{
  "model": "cards.tag",
  "pk": 468,
  "fields": {
    "name": "встроенные_функции"
  }
},
{
  "model": "cards.tag",
  "pk": 469,
  "fields": {
    "name": "staticmethod"
  }
},
{
  "model": "cards.tag",
  "pk": 470,
  "fields": {
    "name": "интеграция_c_и_python"
  }
},
{
  "model": "cards.tag",
  "pk": 471,
  "fields": {
    "name": "создание_функции"
  }
},
{
  "model": "cards.tag",
  "pk": 472,
  "fields": {
    "name": "valueerror"
  }
},
{
  "model": "cards.tag",
  "pk": 473,
  "fields": {
    "name": "бесконечный_цикл"
  }
},
{
  "model": "cards.tag",
  "pk": 474,
  "fields": {
    "name": "иммутабельность"
  }
},
{
  "model": "cards.tag",
  "pk": 475,
  "fields": {
    "name": "экономия_памяти"
  }
},
{
  "model": "cards.tag",
  "pk": 476,
  "fields": {
    "name": "установка_пакетов"
  }
},
{
  "model": "cards.tag",
  "pk": 477,
  "fields": {
    "name": "import"
  }
},
{
  "model": "cards.tag",
  "pk": 478,
  "fields": {
    "name": "эффективный_код"
  }
},
{
  "model": "cards.tag",
  "pk": 479,
  "fields": {
    "name": "масштабируемость"
  }
},
{
  "model": "cards.tag",
  "pk": 480,
  "fields": {
    "name": "cffi"
  }
},
{
  "model": "cards.tag",
  "pk": 481,
  "fields": {
    "name": "интеграция_java_python"
  }
},
{
  "model": "cards.tag",
  "pk": 482,
  "fields": {
    "name": "работа_с_c_в_python"
  }
},
{
  "model": "cards.tag",
  "pk": 483,
  "fields": {
    "name": "combinations"
  }
},
{
  "model": "cards.tag",
  "pk": 484,
  "fields": {
    "name": "isalnum"
  }
},
{
  "model": "cards.tag",
  "pk": 485,
  "fields": {
    "name": "строковые_константы"
  }
},
{
  "model": "cards.tag",
  "pk": 486,
  "fields": {
    "name": "next"
  }
},
{
  "model": "cards.tag",
  "pk": 487,
  "fields": {
    "name": "stackless_python"
  }
},
{
  "model": "cards.tag",
  "pk": 488,
  "fields": {
    "name": "интерпретатор"
  }
},
{
  "model": "cards.tag",
  "pk": 489,
  "fields": {
    "name": "merge"
  }
},
{
  "model": "cards.tag",
  "pk": 490,
  "fields": {
    "name": "aiohttp"
  }
},
{
  "model": "cards.tag",
  "pk": 491,
  "fields": {
    "name": "set"
  }
},
{
  "model": "cards.tag",
  "pk": 492,
  "fields": {
    "name": "python_vs_scala"
  }
},
{
  "model": "cards.tag",
  "pk": 493,
  "fields": {
    "name": "statsmodels"
  }
},
{
  "model": "cards.tag",
  "pk": 494,
  "fields": {
    "name": "python2"
  }
},
{
  "model": "cards.tag",
  "pk": 495,
  "fields": {
    "name": "стандартная_библиотека"
  }
},
{
  "model": "cards.tag",
  "pk": 496,
  "fields": {
    "name": "системы_контроля_версий"
  }
},
{
  "model": "cards.tag",
  "pk": 497,
  "fields": {
    "name": "переменные_класса"
  }
},
{
  "model": "cards.tag",
  "pk": 498,
  "fields": {
    "name": "оптимизация_памяти"
  }
},
{
  "model": "cards.tag",
  "pk": 499,
  "fields": {
    "name": "args_kwargs"
  }
},
{
  "model": "cards.tag",
  "pk": 500,
  "fields": {
    "name": "стандарт_кодирования"
  }
},
{
  "model": "cards.tag",
  "pk": 501,
  "fields": {
    "name": "библиотеки"
  }
},
{
  "model": "cards.tag",
  "pk": 502,
  "fields": {
    "name": "без_return"
  }
},
{
  "model": "cards.tag",
  "pk": 503,
  "fields": {
    "name": "добавление_в_файл"
  }
},
{
  "model": "cards.tag",
  "pk": 504,
  "fields": {
    "name": "пакет"
  }
},
{
  "model": "cards.tag",
  "pk": 505,
  "fields": {
    "name": "объединение_списков"
  }
},
{
  "model": "cards.tag",
  "pk": 506,
  "fields": {
    "name": "интерфейсы"
  }
},
{
  "model": "cards.tag",
  "pk": 507,
  "fields": {
    "name": "сортировка"
  }
},
{
  "model": "cards.tag",
  "pk": 508,
  "fields": {
    "name": "контейнеры"
  }
},
{
  "model": "cards.tag",
  "pk": 509,
  "fields": {
    "name": "file_handling"
  }
},
{
  "model": "cards.tag",
  "pk": 510,
  "fields": {
    "name": "left_join"
  }
},
{
  "model": "cards.tag",
  "pk": 511,
  "fields": {
    "name": "petl"
  }
},
{
  "model": "cards.tag",
  "pk": 512,
  "fields": {
    "name": "row_number"
  }
},
{
  "model": "cards.tag",
  "pk": 513,
  "fields": {
    "name": "best_practices"
  }
},
{
  "model": "cards.tag",
  "pk": 514,
  "fields": {
    "name": "императивный_язык"
  }
},
{
  "model": "cards.tag",
  "pk": 515,
  "fields": {
    "name": "список_чисел"
  }
},
{
  "model": "cards.tag",
  "pk": 516,
  "fields": {
    "name": "pythonpath"
  }
},
{
  "model": "cards.tag",
  "pk": 517,
  "fields": {
    "name": "аналог_switch-case"
  }
},
{
  "model": "cards.tag",
  "pk": 518,
  "fields": {
    "name": "атрибуты_объекта"
  }
},
{
  "model": "cards.tag",
  "pk": 519,
  "fields": {
    "name": "web_разработка"
  }
},
{
  "model": "cards.tag",
  "pk": 520,
  "fields": {
    "name": "is"
  }
},
{
  "model": "cards.tag",
  "pk": 521,
  "fields": {
    "name": "sum_function"
  }
},
{
  "model": "cards.tag",
  "pk": 522,
  "fields": {
    "name": "экранирование"
  }
},
{
  "model": "cards.tag",
  "pk": 523,
  "fields": {
    "name": "позиционные_аргументы"
  }
},
{
  "model": "cards.tag",
  "pk": 524,
  "fields": {
    "name": "объекты"
  }
},
{
  "model": "cards.tag",
  "pk": 525,
  "fields": {
    "name": "операторы_sql"
  }
},
{
  "model": "cards.tag",
  "pk": 526,
  "fields": {
    "name": "работа_с_числами"
  }
},
{
  "model": "cards.tag",
  "pk": 527,
  "fields": {
    "name": "обработка_текста"
  }
},
{
  "model": "cards.tag",
  "pk": 528,
  "fields": {
    "name": "pyinstaller"
  }
},
{
  "model": "cards.tag",
  "pk": 529,
  "fields": {
    "name": "неэффективный_код"
  }
},
{
  "model": "cards.tag",
  "pk": 530,
  "fields": {
    "name": "asc_desc"
  }
},
{
  "model": "cards.tag",
  "pk": 531,
  "fields": {
    "name": "работа_с_функциями"
  }
},
{
  "model": "cards.tag",
  "pk": 532,
  "fields": {
    "name": "форматирование_кода"
  }
},
{
  "model": "cards.tag",
  "pk": 533,
  "fields": {
    "name": "расширяемость"
  }
},
{
  "model": "cards.tag",
  "pk": 534,
  "fields": {
    "name": "создание_игр"
  }
},
{
  "model": "cards.tag",
  "pk": 535,
  "fields": {
    "name": "высокий_уровень"
  }
},
{
  "model": "cards.tag",
  "pk": 536,
  "fields": {
    "name": "bit"
  }
},
{
  "model": "cards.tag",
  "pk": 537,
  "fields": {
    "name": "shutil"
  }
},
{
  "model": "cards.tag",
  "pk": 538,
  "fields": {
    "name": "индексация"
  }
},
{
  "model": "cards.tag",
  "pk": 539,
  "fields": {
    "name": "readlines"
  }
},
{
  "model": "cards.tag",
  "pk": 540,
  "fields": {
    "name": "before"
  }
},
{
  "model": "cards.tag",
  "pk": 541,
  "fields": {
    "name": "строка_юникода"
  }
},
{
  "model": "cards.tag",
  "pk": 542,
  "fields": {
    "name": "ограничения_целостности"
  }
},
{
  "model": "cards.tag",
  "pk": 543,
  "fields": {
    "name": "операторы_управления"
  }
},
{
  "model": "cards.tag",
  "pk": 544,
  "fields": {
    "name": "globals()"
  }
},
{
  "model": "cards.tag",
  "pk": 545,
  "fields": {
    "name": "добавление_пути"
  }
},
{
  "model": "cards.tag",
  "pk": 546,
  "fields": {
    "name": "без_дублей"
  }
},
{
  "model": "cards.tag",
  "pk": 547,
  "fields": {
    "name": "name"
  }
},
{
  "model": "cards.tag",
  "pk": 548,
  "fields": {
    "name": "SQL"
  }
},
{
  "model": "cards.tag",
  "pk": 549,
  "fields": {
    "name": "применение_функций"
  }
},
{
  "model": "cards.tag",
  "pk": 550,
  "fields": {
    "name": "именованный_кортеж"
  }
},
{
  "model": "cards.tag",
  "pk": 551,
  "fields": {
    "name": "locals"
  }
},
{
  "model": "cards.tag",
  "pk": 552,
  "fields": {
    "name": "monkey_patching"
  }
},
{
  "model": "cards.tag",
  "pk": 553,
  "fields": {
    "name": "генератор_списка"
  }
},
{
  "model": "cards.tag",
  "pk": 554,
  "fields": {
    "name": "статистические_вычисления"
  }
},
{
  "model": "cards.tag",
  "pk": 555,
  "fields": {
    "name": "скорость_доступа"
  }
},
{
  "model": "cards.tag",
  "pk": 556,
  "fields": {
    "name": "организация_кода"
  }
},
{
  "model": "cards.tag",
  "pk": 557,
  "fields": {
    "name": "утечка_памяти"
  }
},
{
  "model": "cards.tag",
  "pk": 558,
  "fields": {
    "name": "инструкции"
  }
},
{
  "model": "cards.tag",
  "pk": 559,
  "fields": {
    "name": "параллелизм"
  }
},
{
  "model": "cards.tag",
  "pk": 560,
  "fields": {
    "name": "автоматическое_управление_памятью"
  }
},
{
  "model": "cards.tag",
  "pk": 561,
  "fields": {
    "name": "обратный_порядок"
  }
},
{
  "model": "cards.tag",
  "pk": 562,
  "fields": {
    "name": "условия"
  }
},
{
  "model": "cards.tag",
  "pk": 563,
  "fields": {
    "name": "конструкция_try_except"
  }
},
{
  "model": "cards.tag",
  "pk": 564,
  "fields": {
    "name": "разработка_программного_обеспечения"
  }
},
{
  "model": "cards.tag",
  "pk": 565,
  "fields": {
    "name": "прерывание_цикла"
  }
},
{
  "model": "cards.tag",
  "pk": 566,
  "fields": {
    "name": "пространства_имён"
  }
},
{
  "model": "cards.tag",
  "pk": 567,
  "fields": {
    "name": "оператор_while"
  }
},
{
  "model": "cards.tag",
  "pk": 568,
  "fields": {
    "name": "строки_в_числа"
  }
},
{
  "model": "cards.tag",
  "pk": 569,
  "fields": {
    "name": "lstrip"
  }
},
{
  "model": "cards.tag",
  "pk": 570,
  "fields": {
    "name": "рифма"
  }
},
{
  "model": "cards.tag",
  "pk": 571,
  "fields": {
    "name": "замыкание"
  }
},
{
  "model": "cards.tag",
  "pk": 572,
  "fields": {
    "name": "sub"
  }
},
{
  "model": "cards.tag",
  "pk": 573,
  "fields": {
    "name": "лаконичный_код"
  }
},
{
  "model": "cards.tag",
  "pk": 574,
  "fields": {
    "name": "логические_выражения"
  }
},
{
  "model": "cards.tag",
  "pk": 575,
  "fields": {
    "name": "pytorch"
  }
},
{
  "model": "cards.tag",
  "pk": 576,
  "fields": {
    "name": "garbage_collection"
  }
},
{
  "model": "cards.tag",
  "pk": 577,
  "fields": {
    "name": "структура_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 578,
  "fields": {
    "name": "основы"
  }
},
{
  "model": "cards.tag",
  "pk": 579,
  "fields": {
    "name": "hashable"
  }
},
{
  "model": "cards.tag",
  "pk": 580,
  "fields": {
    "name": "itertools"
  }
},
{
  "model": "cards.tag",
  "pk": 581,
  "fields": {
    "name": "shuffle"
  }
},
{
  "model": "cards.tag",
  "pk": 582,
  "fields": {
    "name": "ввод_вывод"
  }
},
{
  "model": "cards.tag",
  "pk": 583,
  "fields": {
    "name": "однострочник"
  }
},
{
  "model": "cards.tag",
  "pk": 584,
  "fields": {
    "name": "tracemalloc"
  }
},
{
  "model": "cards.tag",
  "pk": 585,
  "fields": {
    "name": "pep8"
  }
},
{
  "model": "cards.tag",
  "pk": 586,
  "fields": {
    "name": "добавление_элементов"
  }
},
{
  "model": "cards.tag",
  "pk": 587,
  "fields": {
    "name": "pylintbear"
  }
},
{
  "model": "cards.tag",
  "pk": 588,
  "fields": {
    "name": "sys.setrecursionlimit"
  }
},
{
  "model": "cards.tag",
  "pk": 589,
  "fields": {
    "name": "reduce"
  }
},
{
  "model": "cards.tag",
  "pk": 590,
  "fields": {
    "name": "суммирование_элементов"
  }
},
{
  "model": "cards.tag",
  "pk": 591,
  "fields": {
    "name": "framework"
  }
},
{
  "model": "cards.tag",
  "pk": 592,
  "fields": {
    "name": "pythonioencoding"
  }
},
{
  "model": "cards.tag",
  "pk": 593,
  "fields": {
    "name": "оператор_select"
  }
},
{
  "model": "cards.tag",
  "pk": 594,
  "fields": {
    "name": "title"
  }
},
{
  "model": "cards.tag",
  "pk": 595,
  "fields": {
    "name": "namedtuple"
  }
},
{
  "model": "cards.tag",
  "pk": 596,
  "fields": {
    "name": "eggs"
  }
},
{
  "model": "cards.tag",
  "pk": 597,
  "fields": {
    "name": "удаленный_доступ"
  }
},
{
  "model": "cards.tag",
  "pk": 598,
  "fields": {
    "name": "csv"
  }
},
{
  "model": "cards.tag",
  "pk": 599,
  "fields": {
    "name": "циклы"
  }
},
{
  "model": "cards.tag",
  "pk": 600,
  "fields": {
    "name": "проектирование_языка"
  }
},
{
  "model": "cards.tag",
  "pk": 601,
  "fields": {
    "name": "set_trace"
  }
},
{
  "model": "cards.tag",
  "pk": 602,
  "fields": {
    "name": "подзапросы"
  }
},
{
  "model": "cards.tag",
  "pk": 603,
  "fields": {
    "name": "ограничения_python"
  }
},
{
  "model": "cards.tag",
  "pk": 604,
  "fields": {
    "name": "web-формы"
  }
},
{
  "model": "cards.tag",
  "pk": 605,
  "fields": {
    "name": "случайная_строка"
  }
},
{
  "model": "cards.tag",
  "pk": 606,
  "fields": {
    "name": "кортеж"
  }
},
{
  "model": "cards.tag",
  "pk": 607,
  "fields": {
    "name": "векторизация"
  }
},
{
  "model": "cards.tag",
  "pk": 608,
  "fields": {
    "name": "garbage_collector"
  }
},
{
  "model": "cards.tag",
  "pk": 609,
  "fields": {
    "name": "ключи_словаря"
  }
},
{
  "model": "cards.tag",
  "pk": 610,
  "fields": {
    "name": "nonlocal"
  }
},
{
  "model": "cards.tag",
  "pk": 611,
  "fields": {
    "name": "модель-представление-контроллер"
  }
},
{
  "model": "cards.tag",
  "pk": 612,
  "fields": {
    "name": "динамическая_типизация"
  }
},
{
  "model": "cards.tag",
  "pk": 613,
  "fields": {
    "name": "память"
  }
},
{
  "model": "cards.tag",
  "pk": 614,
  "fields": {
    "name": "переменная"
  }
},
{
  "model": "cards.tag",
  "pk": 615,
  "fields": {
    "name": "create_index"
  }
},
{
  "model": "cards.tag",
  "pk": 616,
  "fields": {
    "name": "структурное_сопоставление_с_шаблоном"
  }
},
{
  "model": "cards.tag",
  "pk": 617,
  "fields": {
    "name": "курсор"
  }
},
{
  "model": "cards.tag",
  "pk": 618,
  "fields": {
    "name": "python_структуры_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 619,
  "fields": {
    "name": "сессии"
  }
},
{
  "model": "cards.tag",
  "pk": 620,
  "fields": {
    "name": "пустой_оператор"
  }
},
{
  "model": "cards.tag",
  "pk": 621,
  "fields": {
    "name": "min"
  }
},
{
  "model": "cards.tag",
  "pk": 622,
  "fields": {
    "name": "графический_интерфейс"
  }
},
{
  "model": "cards.tag",
  "pk": 623,
  "fields": {
    "name": "управление_директориями"
  }
},
{
  "model": "cards.tag",
  "pk": 624,
  "fields": {
    "name": "обработка_аргументов"
  }
},
{
  "model": "cards.tag",
  "pk": 625,
  "fields": {
    "name": "ssh"
  }
},
{
  "model": "cards.tag",
  "pk": 626,
  "fields": {
    "name": "mysql"
  }
},
{
  "model": "cards.tag",
  "pk": 627,
  "fields": {
    "name": "ускорение_кода"
  }
},
{
  "model": "cards.tag",
  "pk": 628,
  "fields": {
    "name": "method_resolution_order"
  }
},
{
  "model": "cards.tag",
  "pk": 629,
  "fields": {
    "name": "__doc__"
  }
},
{
  "model": "cards.tag",
  "pk": 630,
  "fields": {
    "name": "выполнение_кода"
  }
},
{
  "model": "cards.tag",
  "pk": 631,
  "fields": {
    "name": "модель"
  }
},
{
  "model": "cards.tag",
  "pk": 632,
  "fields": {
    "name": "файловая_система"
  }
},
{
  "model": "cards.tag",
  "pk": 633,
  "fields": {
    "name": "субд"
  }
},
{
  "model": "cards.tag",
  "pk": 634,
  "fields": {
    "name": "groupby"
  }
},
{
  "model": "cards.tag",
  "pk": 635,
  "fields": {
    "name": "проверка_сервера"
  }
},
{
  "model": "cards.tag",
  "pk": 636,
  "fields": {
    "name": "group_by"
  }
},
{
  "model": "cards.tag",
  "pk": 637,
  "fields": {
    "name": "создание_индекса"
  }
},
{
  "model": "cards.tag",
  "pk": 638,
  "fields": {
    "name": "работа_с_датой"
  }
},
{
  "model": "cards.tag",
  "pk": 639,
  "fields": {
    "name": "системные_ресурсы"
  }
},
{
  "model": "cards.tag",
  "pk": 640,
  "fields": {
    "name": "keyboardinterrupt"
  }
},
{
  "model": "cards.tag",
  "pk": 641,
  "fields": {
    "name": "reversed"
  }
},
{
  "model": "cards.tag",
  "pk": 642,
  "fields": {
    "name": "работа_с_базами_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 643,
  "fields": {
    "name": "psycopg2"
  }
},
{
  "model": "cards.tag",
  "pk": 644,
  "fields": {
    "name": "создание_таблицы"
  }
},
{
  "model": "cards.tag",
  "pk": 645,
  "fields": {
    "name": "подсчет_записей"
  }
},
{
  "model": "cards.tag",
  "pk": 646,
  "fields": {
    "name": "threading"
  }
},
{
  "model": "cards.tag",
  "pk": 647,
  "fields": {
    "name": "cx_freeze"
  }
},
{
  "model": "cards.tag",
  "pk": 648,
  "fields": {
    "name": "контроль_доступа"
  }
},
{
  "model": "cards.tag",
  "pk": 649,
  "fields": {
    "name": "comprehension"
  }
},
{
  "model": "cards.tag",
  "pk": 650,
  "fields": {
    "name": "bottle"
  }
},
{
  "model": "cards.tag",
  "pk": 651,
  "fields": {
    "name": "модуль_pickle"
  }
},
{
  "model": "cards.tag",
  "pk": 652,
  "fields": {
    "name": "разница_между_append_extend"
  }
},
{
  "model": "cards.tag",
  "pk": 653,
  "fields": {
    "name": "байты"
  }
},
{
  "model": "cards.tag",
  "pk": 654,
  "fields": {
    "name": "defaultdict"
  }
},
{
  "model": "cards.tag",
  "pk": 655,
  "fields": {
    "name": "класс_counter"
  }
},
{
  "model": "cards.tag",
  "pk": 656,
  "fields": {
    "name": "jython"
  }
},
{
  "model": "cards.tag",
  "pk": 657,
  "fields": {
    "name": "синхронный_код"
  }
},
{
  "model": "cards.tag",
  "pk": 658,
  "fields": {
    "name": "__main__"
  }
},
{
  "model": "cards.tag",
  "pk": 659,
  "fields": {
    "name": "тернарный_оператор"
  }
},
{
  "model": "cards.tag",
  "pk": 660,
  "fields": {
    "name": "baseexception"
  }
},
{
  "model": "cards.tag",
  "pk": 661,
  "fields": {
    "name": "property"
  }
},
{
  "model": "cards.tag",
  "pk": 662,
  "fields": {
    "name": "distinct"
  }
},
{
  "model": "cards.tag",
  "pk": 663,
  "fields": {
    "name": "полиморфизм"
  }
},
{
  "model": "cards.tag",
  "pk": 664,
  "fields": {
    "name": "конструктор"
  }
},
{
  "model": "cards.tag",
  "pk": 665,
  "fields": {
    "name": "диапазон_чисел"
  }
},
{
  "model": "cards.tag",
  "pk": 666,
  "fields": {
    "name": "tcl"
  }
},
{
  "model": "cards.tag",
  "pk": 667,
  "fields": {
    "name": "проверка_синтаксиса"
  }
},
{
  "model": "cards.tag",
  "pk": 668,
  "fields": {
    "name": "определение_декоратора"
  }
},
{
  "model": "cards.tag",
  "pk": 669,
  "fields": {
    "name": "value_error"
  }
},
{
  "model": "cards.tag",
  "pk": 670,
  "fields": {
    "name": "триггер"
  }
},
{
  "model": "cards.tag",
  "pk": 671,
  "fields": {
    "name": "адаптация_кода"
  }
},
{
  "model": "cards.tag",
  "pk": 672,
  "fields": {
    "name": "foreign_key"
  }
},
{
  "model": "cards.tag",
  "pk": 673,
  "fields": {
    "name": "paramiko"
  }
},
{
  "model": "cards.tag",
  "pk": 674,
  "fields": {
    "name": "использование_памяти"
  }
},
{
  "model": "cards.tag",
  "pk": 675,
  "fields": {
    "name": "свободные_переменные"
  }
},
{
  "model": "cards.tag",
  "pk": 676,
  "fields": {
    "name": "isinstance"
  }
},
{
  "model": "cards.tag",
  "pk": 677,
  "fields": {
    "name": "генераторы"
  }
},
{
  "model": "cards.tag",
  "pk": 678,
  "fields": {
    "name": "автоматизация"
  }
},
{
  "model": "cards.tag",
  "pk": 679,
  "fields": {
    "name": "получение_пути"
  }
},
{
  "model": "cards.tag",
  "pk": 680,
  "fields": {
    "name": "типы_соединений"
  }
},
{
  "model": "cards.tag",
  "pk": 681,
  "fields": {
    "name": "документация"
  }
},
{
  "model": "cards.tag",
  "pk": 682,
  "fields": {
    "name": "модульное_деление"
  }
},
{
  "model": "cards.tag",
  "pk": 683,
  "fields": {
    "name": "объектно-ориентированное_программирование"
  }
},
{
  "model": "cards.tag",
  "pk": 684,
  "fields": {
    "name": "блоки_кода"
  }
},
{
  "model": "cards.tag",
  "pk": 685,
  "fields": {
    "name": "синтаксический_анализ"
  }
},
{
  "model": "cards.tag",
  "pk": 686,
  "fields": {
    "name": "мутабельные"
  }
},
{
  "model": "cards.tag",
  "pk": 687,
  "fields": {
    "name": "генерация_случайных_чисел"
  }
},
{
  "model": "cards.tag",
  "pk": 688,
  "fields": {
    "name": "логические_условия"
  }
},
{
  "model": "cards.tag",
  "pk": 689,
  "fields": {
    "name": "уникальные_значения"
  }
},
{
  "model": "cards.tag",
  "pk": 690,
  "fields": {
    "name": "constructor"
  }
},
{
  "model": "cards.tag",
  "pk": 691,
  "fields": {
    "name": "изменяемые_структуры_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 692,
  "fields": {
    "name": "python_реализации"
  }
},
{
  "model": "cards.tag",
  "pk": 693,
  "fields": {
    "name": "mro"
  }
},
{
  "model": "cards.tag",
  "pk": 694,
  "fields": {
    "name": "язык_запросов"
  }
},
{
  "model": "cards.tag",
  "pk": 695,
  "fields": {
    "name": "векторизованные_вычисления"
  }
},
{
  "model": "cards.tag",
  "pk": 696,
  "fields": {
    "name": "строковое_представление"
  }
},
{
  "model": "cards.tag",
  "pk": 697,
  "fields": {
    "name": "ord()"
  }
},
{
  "model": "cards.tag",
  "pk": 698,
  "fields": {
    "name": "вывод_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 699,
  "fields": {
    "name": "скомпилированный_код"
  }
},
{
  "model": "cards.tag",
  "pk": 700,
  "fields": {
    "name": "poetry"
  }
},
{
  "model": "cards.tag",
  "pk": 701,
  "fields": {
    "name": "временная_таблица"
  }
},
{
  "model": "cards.tag",
  "pk": 702,
  "fields": {
    "name": "пути_к_модулям"
  }
},
{
  "model": "cards.tag",
  "pk": 703,
  "fields": {
    "name": "условие"
  }
},
{
  "model": "cards.tag",
  "pk": 704,
  "fields": {
    "name": "memory_leak"
  }
},
{
  "model": "cards.tag",
  "pk": 705,
  "fields": {
    "name": "совместимость"
  }
},
{
  "model": "cards.tag",
  "pk": 706,
  "fields": {
    "name": "классы"
  }
},
{
  "model": "cards.tag",
  "pk": 707,
  "fields": {
    "name": "mutable_data_types"
  }
},
{
  "model": "cards.tag",
  "pk": 708,
  "fields": {
    "name": "yaml"
  }
},
{
  "model": "cards.tag",
  "pk": 709,
  "fields": {
    "name": "machine_learning"
  }
},
{
  "model": "cards.tag",
  "pk": 710,
  "fields": {
    "name": "вычисление_суммы"
  }
},
{
  "model": "cards.tag",
  "pk": 711,
  "fields": {
    "name": "*args"
  }
},
{
  "model": "cards.tag",
  "pk": 712,
  "fields": {
    "name": "строки"
  }
},
{
  "model": "cards.tag",
  "pk": 713,
  "fields": {
    "name": "pychecker"
  }
},
{
  "model": "cards.tag",
  "pk": 714,
  "fields": {
    "name": "условный_блок"
  }
},
{
  "model": "cards.tag",
  "pk": 715,
  "fields": {
    "name": "упрощение_кода"
  }
},
{
  "model": "cards.tag",
  "pk": 716,
  "fields": {
    "name": "базы_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 717,
  "fields": {
    "name": "преобразование_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 718,
  "fields": {
    "name": "итератор"
  }
},
{
  "model": "cards.tag",
  "pk": 719,
  "fields": {
    "name": "разница_между_дескрипторами_и_декораторами"
  }
},
{
  "model": "cards.tag",
  "pk": 720,
  "fields": {
    "name": "return"
  }
},
{
  "model": "cards.tag",
  "pk": 721,
  "fields": {
    "name": "утиная_типизация"
  }
},
{
  "model": "cards.tag",
  "pk": 722,
  "fields": {
    "name": "random"
  }
},
{
  "model": "cards.tag",
  "pk": 723,
  "fields": {
    "name": "вызов_родительского_метода"
  }
},
{
  "model": "cards.tag",
  "pk": 724,
  "fields": {
    "name": "functions"
  }
},
{
  "model": "cards.tag",
  "pk": 725,
  "fields": {
    "name": "менеджеры_пакетов"
  }
},
{
  "model": "cards.tag",
  "pk": 726,
  "fields": {
    "name": "веб-фреймворки"
  }
},
{
  "model": "cards.tag",
  "pk": 727,
  "fields": {
    "name": "реализация"
  }
},
{
  "model": "cards.tag",
  "pk": 728,
  "fields": {
    "name": "sequence"
  }
},
{
  "model": "cards.tag",
  "pk": 729,
  "fields": {
    "name": "реализации_python"
  }
},
{
  "model": "cards.tag",
  "pk": 730,
  "fields": {
    "name": "sql_constraints"
  }
},
{
  "model": "cards.tag",
  "pk": 731,
  "fields": {
    "name": "easy_install"
  }
},
{
  "model": "cards.tag",
  "pk": 732,
  "fields": {
    "name": "кросс-платформенность"
  }
},
{
  "model": "cards.tag",
  "pk": 733,
  "fields": {
    "name": "условия_выхода_из_цикла"
  }
},
{
  "model": "cards.tag",
  "pk": 734,
  "fields": {
    "name": "бинарный_режим"
  }
},
{
  "model": "cards.tag",
  "pk": 735,
  "fields": {
    "name": "runtime"
  }
},
{
  "model": "cards.tag",
  "pk": 736,
  "fields": {
    "name": "сложность_операций"
  }
},
{
  "model": "cards.tag",
  "pk": 737,
  "fields": {
    "name": "ddl"
  }
},
{
  "model": "cards.tag",
  "pk": 738,
  "fields": {
    "name": "разработка_игр"
  }
},
{
  "model": "cards.tag",
  "pk": 739,
  "fields": {
    "name": "стандартные_библиотеки"
  }
},
{
  "model": "cards.tag",
  "pk": 740,
  "fields": {
    "name": "http-ответы"
  }
},
{
  "model": "cards.tag",
  "pk": 741,
  "fields": {
    "name": "оператор_деления"
  }
},
{
  "model": "cards.tag",
  "pk": 742,
  "fields": {
    "name": "профилирование"
  }
},
{
  "model": "cards.tag",
  "pk": 743,
  "fields": {
    "name": "iter"
  }
},
{
  "model": "cards.tag",
  "pk": 744,
  "fields": {
    "name": "автоматическое_закрытие"
  }
},
{
  "model": "cards.tag",
  "pk": 745,
  "fields": {
    "name": "особенности_языка"
  }
},
{
  "model": "cards.tag",
  "pk": 746,
  "fields": {
    "name": "обработка_массивов"
  }
},
{
  "model": "cards.tag",
  "pk": 747,
  "fields": {
    "name": "цикл_for"
  }
},
{
  "model": "cards.tag",
  "pk": 748,
  "fields": {
    "name": "шебанг"
  }
},
{
  "model": "cards.tag",
  "pk": 749,
  "fields": {
    "name": "кроссплатформенность"
  }
},
{
  "model": "cards.tag",
  "pk": 750,
  "fields": {
    "name": "обновление_кода"
  }
},
{
  "model": "cards.tag",
  "pk": 751,
  "fields": {
    "name": "изменение_поведения"
  }
},
{
  "model": "cards.tag",
  "pk": 752,
  "fields": {
    "name": "легкость_языка"
  }
},
{
  "model": "cards.tag",
  "pk": 753,
  "fields": {
    "name": "id()"
  }
},
{
  "model": "cards.tag",
  "pk": 754,
  "fields": {
    "name": "подсчет_ссылок"
  }
},
{
  "model": "cards.tag",
  "pk": 755,
  "fields": {
    "name": "dictionary_methods"
  }
},
{
  "model": "cards.tag",
  "pk": 756,
  "fields": {
    "name": "методы"
  }
},
{
  "model": "cards.tag",
  "pk": 757,
  "fields": {
    "name": "работа_с_модулями"
  }
},
{
  "model": "cards.tag",
  "pk": 758,
  "fields": {
    "name": "типизация"
  }
},
{
  "model": "cards.tag",
  "pk": 759,
  "fields": {
    "name": "argparse"
  }
},
{
  "model": "cards.tag",
  "pk": 760,
  "fields": {
    "name": "блок_except"
  }
},
{
  "model": "cards.tag",
  "pk": 761,
  "fields": {
    "name": "enter"
  }
},
{
  "model": "cards.tag",
  "pk": 762,
  "fields": {
    "name": "if_elif_else"
  }
},
{
  "model": "cards.tag",
  "pk": 763,
  "fields": {
    "name": "извлечение_части"
  }
},
{
  "model": "cards.tag",
  "pk": 764,
  "fields": {
    "name": "asyncio"
  }
},
{
  "model": "cards.tag",
  "pk": 765,
  "fields": {
    "name": "особенности_python"
  }
},
{
  "model": "cards.tag",
  "pk": 766,
  "fields": {
    "name": "map"
  }
},
{
  "model": "cards.tag",
  "pk": 767,
  "fields": {
    "name": "метод_iter"
  }
},
{
  "model": "cards.tag",
  "pk": 768,
  "fields": {
    "name": "точка_останова"
  }
},
{
  "model": "cards.tag",
  "pk": 769,
  "fields": {
    "name": "работа_с_данными"
  }
},
{
  "model": "cards.tag",
  "pk": 770,
  "fields": {
    "name": "оператор_членства"
  }
},
{
  "model": "cards.tag",
  "pk": 771,
  "fields": {
    "name": "последовательное_выполнение"
  }
},
{
  "model": "cards.tag",
  "pk": 772,
  "fields": {
    "name": "производительность"
  }
},
{
  "model": "cards.tag",
  "pk": 773,
  "fields": {
    "name": "слияние_таблиц"
  }
},
{
  "model": "cards.tag",
  "pk": 774,
  "fields": {
    "name": "длина_списка"
  }
},
{
  "model": "cards.tag",
  "pk": 775,
  "fields": {
    "name": "проверка_утечки_памяти"
  }
},
{
  "model": "cards.tag",
  "pk": 776,
  "fields": {
    "name": "group_by_оператор"
  }
},
{
  "model": "cards.tag",
  "pk": 777,
  "fields": {
    "name": "кэширование"
  }
},
{
  "model": "cards.tag",
  "pk": 778,
  "fields": {
    "name": "случайные_числа"
  }
},
{
  "model": "cards.tag",
  "pk": 779,
  "fields": {
    "name": "python_код"
  }
},
{
  "model": "cards.tag",
  "pk": 780,
  "fields": {
    "name": "генерационный_сборщик_мусора"
  }
},
{
  "model": "cards.tag",
  "pk": 781,
  "fields": {
    "name": "pypy"
  }
},
{
  "model": "cards.tag",
  "pk": 782,
  "fields": {
    "name": "десериализация"
  }
},
{
  "model": "cards.tag",
  "pk": 783,
  "fields": {
    "name": "docker"
  }
},
{
  "model": "cards.tag",
  "pk": 784,
  "fields": {
    "name": "prospector"
  }
},
{
  "model": "cards.tag",
  "pk": 785,
  "fields": {
    "name": "бизнес-логика"
  }
},
{
  "model": "cards.tag",
  "pk": 786,
  "fields": {
    "name": "django"
  }
},
{
  "model": "cards.tag",
  "pk": 787,
  "fields": {
    "name": "определение_типа"
  }
},
{
  "model": "cards.tag",
  "pk": 788,
  "fields": {
    "name": "мутаторы"
  }
},
{
  "model": "cards.tag",
  "pk": 789,
  "fields": {
    "name": "поиск_ошибок"
  }
},
{
  "model": "cards.tag",
  "pk": 790,
  "fields": {
    "name": "issubclass"
  }
},
{
  "model": "cards.tag",
  "pk": 791,
  "fields": {
    "name": "логирование"
  }
},
{
  "model": "cards.tag",
  "pk": 792,
  "fields": {
    "name": "full_outer_join"
  }
},
{
  "model": "cards.tag",
  "pk": 793,
  "fields": {
    "name": "raise"
  }
},
{
  "model": "cards.tag",
  "pk": 794,
  "fields": {
    "name": "безопасность"
  }
},
{
  "model": "cards.tag",
  "pk": 795,
  "fields": {
    "name": "антивирусное_программное_обеспечение"
  }
},
{
  "model": "cards.tag",
  "pk": 796,
  "fields": {
    "name": "tuple_unpacking"
  }
},
{
  "model": "cards.tag",
  "pk": 797,
  "fields": {
    "name": "транзакция"
  }
},
{
  "model": "cards.tag",
  "pk": 798,
  "fields": {
    "name": "сортировка_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 799,
  "fields": {
    "name": "автоматическая_генерация_документации"
  }
},
{
  "model": "cards.tag",
  "pk": 800,
  "fields": {
    "name": "последний_элемент"
  }
},
{
  "model": "cards.tag",
  "pk": 801,
  "fields": {
    "name": "Python"
  }
},
{
  "model": "cards.tag",
  "pk": 802,
  "fields": {
    "name": "транзитивные_зависимости"
  }
},
{
  "model": "cards.tag",
  "pk": 803,
  "fields": {
    "name": "возведение_в_степень"
  }
},
{
  "model": "cards.tag",
  "pk": 804,
  "fields": {
    "name": "метод_join"
  }
},
{
  "model": "cards.tag",
  "pk": 805,
  "fields": {
    "name": "управление_зависимостями"
  }
},
{
  "model": "cards.tag",
  "pk": 806,
  "fields": {
    "name": "сообщество"
  }
},
{
  "model": "cards.tag",
  "pk": 807,
  "fields": {
    "name": "декораторы"
  }
},
{
  "model": "cards.tag",
  "pk": 808,
  "fields": {
    "name": "чтение_файлов"
  }
},
{
  "model": "cards.tag",
  "pk": 809,
  "fields": {
    "name": "операции_над_множествами"
  }
},
{
  "model": "cards.tag",
  "pk": 810,
  "fields": {
    "name": "агрегация"
  }
},
{
  "model": "cards.tag",
  "pk": 811,
  "fields": {
    "name": "pytest"
  }
},
{
  "model": "cards.tag",
  "pk": 812,
  "fields": {
    "name": "flake8"
  }
},
{
  "model": "cards.tag",
  "pk": 813,
  "fields": {
    "name": "ос_модуль"
  }
},
{
  "model": "cards.tag",
  "pk": 814,
  "fields": {
    "name": "лучшие_практики"
  }
},
{
  "model": "cards.tag",
  "pk": 815,
  "fields": {
    "name": "оператор_break"
  }
},
{
  "model": "cards.tag",
  "pk": 816,
  "fields": {
    "name": "просмотр_методов"
  }
},
{
  "model": "cards.tag",
  "pk": 817,
  "fields": {
    "name": "функциональное_программирование"
  }
},
{
  "model": "cards.tag",
  "pk": 818,
  "fields": {
    "name": "жизненный_цикл_потоков"
  }
},
{
  "model": "cards.tag",
  "pk": 819,
  "fields": {
    "name": "classmethod"
  }
},
{
  "model": "cards.tag",
  "pk": 820,
  "fields": {
    "name": "from_import"
  }
},
{
  "model": "cards.tag",
  "pk": 821,
  "fields": {
    "name": "unique"
  }
},
{
  "model": "cards.tag",
  "pk": 822,
  "fields": {
    "name": "специальные_методы"
  }
},
{
  "model": "cards.tag",
  "pk": 823,
  "fields": {
    "name": "assert"
  }
},
{
  "model": "cards.tag",
  "pk": 824,
  "fields": {
    "name": "инициализация_объектов"
  }
},
{
  "model": "cards.tag",
  "pk": 825,
  "fields": {
    "name": "синтаксические_ошибки"
  }
},
{
  "model": "cards.tag",
  "pk": 826,
  "fields": {
    "name": "управление_данными"
  }
},
{
  "model": "cards.tag",
  "pk": 827,
  "fields": {
    "name": "инициализация"
  }
},
{
  "model": "cards.tag",
  "pk": 828,
  "fields": {
    "name": "официальное_представление"
  }
},
{
  "model": "cards.tag",
  "pk": 829,
  "fields": {
    "name": "pip"
  }
},
{
  "model": "cards.tag",
  "pk": 830,
  "fields": {
    "name": "коллекции"
  }
},
{
  "model": "cards.tag",
  "pk": 831,
  "fields": {
    "name": "builtins"
  }
},
{
  "model": "cards.tag",
  "pk": 832,
  "fields": {
    "name": "оператор_continue"
  }
},
{
  "model": "cards.tag",
  "pk": 833,
  "fields": {
    "name": "перезагрузка_модуля"
  }
},
{
  "model": "cards.tag",
  "pk": 834,
  "fields": {
    "name": "ide"
  }
},
{
  "model": "cards.tag",
  "pk": 835,
  "fields": {
    "name": "ограничения"
  }
},
{
  "model": "cards.tag",
  "pk": 836,
  "fields": {
    "name": "операторы_присваивания"
  }
},
{
  "model": "cards.tag",
  "pk": 837,
  "fields": {
    "name": "сериализация"
  }
},
{
  "model": "cards.tag",
  "pk": 838,
  "fields": {
    "name": "устойчивость_кода"
  }
},
{
  "model": "cards.tag",
  "pk": 839,
  "fields": {
    "name": "заполнитель_кода"
  }
},
{
  "model": "cards.tag",
  "pk": 840,
  "fields": {
    "name": "условные_операторы"
  }
},
{
  "model": "cards.tag",
  "pk": 841,
  "fields": {
    "name": "модуль_random"
  }
},
{
  "model": "cards.tag",
  "pk": 842,
  "fields": {
    "name": "удаление_файлов"
  }
},
{
  "model": "cards.tag",
  "pk": 843,
  "fields": {
    "name": "bandit"
  }
},
{
  "model": "cards.tag",
  "pk": 844,
  "fields": {
    "name": "импорт_модуля"
  }
},
{
  "model": "cards.tag",
  "pk": 845,
  "fields": {
    "name": "байт-код"
  }
},
{
  "model": "cards.tag",
  "pk": 846,
  "fields": {
    "name": "атрибуты_и_методы"
  }
},
{
  "model": "cards.tag",
  "pk": 847,
  "fields": {
    "name": "преимущества"
  }
},
{
  "model": "cards.tag",
  "pk": 848,
  "fields": {
    "name": "принципы_oop"
  }
},
{
  "model": "cards.tag",
  "pk": 849,
  "fields": {
    "name": "операторы_сравнения"
  }
},
{
  "model": "cards.tag",
  "pk": 850,
  "fields": {
    "name": "инициализация_массива"
  }
},
{
  "model": "cards.tag",
  "pk": 851,
  "fields": {
    "name": "системы_реального_времени"
  }
},
{
  "model": "cards.tag",
  "pk": 852,
  "fields": {
    "name": "фреймворки"
  }
},
{
  "model": "cards.tag",
  "pk": 853,
  "fields": {
    "name": "факториал"
  }
},
{
  "model": "cards.tag",
  "pk": 854,
  "fields": {
    "name": "исходный_код"
  }
},
{
  "model": "cards.tag",
  "pk": 855,
  "fields": {
    "name": "len()"
  }
},
{
  "model": "cards.tag",
  "pk": 856,
  "fields": {
    "name": "python_c/c++_интеграция"
  }
},
{
  "model": "cards.tag",
  "pk": 857,
  "fields": {
    "name": "переменная_подчеркивание"
  }
},
{
  "model": "cards.tag",
  "pk": 858,
  "fields": {
    "name": "мобильные_приложения"
  }
},
{
  "model": "cards.tag",
  "pk": 859,
  "fields": {
    "name": "представление"
  }
},
{
  "model": "cards.tag",
  "pk": 860,
  "fields": {
    "name": "конструкции"
  }
},
{
  "model": "cards.tag",
  "pk": 861,
  "fields": {
    "name": "sys.getrefcount"
  }
},
{
  "model": "cards.tag",
  "pk": 862,
  "fields": {
    "name": "исключение_символов"
  }
},
{
  "model": "cards.tag",
  "pk": 863,
  "fields": {
    "name": "вложенные_кавычки"
  }
},
{
  "model": "cards.tag",
  "pk": 864,
  "fields": {
    "name": "http-запросы"
  }
},
{
  "model": "cards.tag",
  "pk": 865,
  "fields": {
    "name": "пространство_имен"
  }
},
{
  "model": "cards.tag",
  "pk": 866,
  "fields": {
    "name": "балансировщик_нагрузки"
  }
},
{
  "model": "cards.tag",
  "pk": 867,
  "fields": {
    "name": "база_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 868,
  "fields": {
    "name": "открытие_файла"
  }
},
{
  "model": "cards.tag",
  "pk": 869,
  "fields": {
    "name": "close"
  }
},
{
  "model": "cards.tag",
  "pk": 870,
  "fields": {
    "name": "having_vs_where"
  }
},
{
  "model": "cards.tag",
  "pk": 871,
  "fields": {
    "name": "обработка_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 872,
  "fields": {
    "name": "научные_исследования"
  }
},
{
  "model": "cards.tag",
  "pk": 873,
  "fields": {
    "name": "разработка_мобильных_приложений"
  }
},
{
  "model": "cards.tag",
  "pk": 874,
  "fields": {
    "name": "dry"
  }
},
{
  "model": "cards.tag",
  "pk": 875,
  "fields": {
    "name": "двоичное_число"
  }
},
{
  "model": "cards.tag",
  "pk": 876,
  "fields": {
    "name": "кодировка"
  }
},
{
  "model": "cards.tag",
  "pk": 877,
  "fields": {
    "name": "размер_целого_числа"
  }
},
{
  "model": "cards.tag",
  "pk": 878,
  "fields": {
    "name": "оператор_распаковки"
  }
},
{
  "model": "cards.tag",
  "pk": 879,
  "fields": {
    "name": "асинхронность"
  }
},
{
  "model": "cards.tag",
  "pk": 880,
  "fields": {
    "name": "простота_использования"
  }
},
{
  "model": "cards.tag",
  "pk": 881,
  "fields": {
    "name": "sqlite3"
  }
},
{
  "model": "cards.tag",
  "pk": 882,
  "fields": {
    "name": "условное_выражение"
  }
},
{
  "model": "cards.tag",
  "pk": 883,
  "fields": {
    "name": "postgresql"
  }
},
{
  "model": "cards.tag",
  "pk": 884,
  "fields": {
    "name": "пример_кода"
  }
},
{
  "model": "cards.tag",
  "pk": 885,
  "fields": {
    "name": "else"
  }
},
{
  "model": "cards.tag",
  "pk": 886,
  "fields": {
    "name": "виртуальная_машина"
  }
},
{
  "model": "cards.tag",
  "pk": 887,
  "fields": {
    "name": "брандмауэр"
  }
},
{
  "model": "cards.tag",
  "pk": 888,
  "fields": {
    "name": "pyramid"
  }
},
{
  "model": "cards.tag",
  "pk": 889,
  "fields": {
    "name": "массивы"
  }
},
{
  "model": "cards.tag",
  "pk": 890,
  "fields": {
    "name": "интерактивный_режим"
  }
},
{
  "model": "cards.tag",
  "pk": 891,
  "fields": {
    "name": "continue"
  }
},
{
  "model": "cards.tag",
  "pk": 892,
  "fields": {
    "name": "get_set_delete"
  }
},
{
  "model": "cards.tag",
  "pk": 893,
  "fields": {
    "name": "big_data"
  }
},
{
  "model": "cards.tag",
  "pk": 894,
  "fields": {
    "name": "join"
  }
},
{
  "model": "cards.tag",
  "pk": 895,
  "fields": {
    "name": "журналы"
  }
},
{
  "model": "cards.tag",
  "pk": 896,
  "fields": {
    "name": "модули_работы_с_файлами"
  }
},
{
  "model": "cards.tag",
  "pk": 897,
  "fields": {
    "name": "кортежи"
  }
},
{
  "model": "cards.tag",
  "pk": 898,
  "fields": {
    "name": "классы_старого_стиля"
  }
},
{
  "model": "cards.tag",
  "pk": 899,
  "fields": {
    "name": "join_vs_подзапросы"
  }
},
{
  "model": "cards.tag",
  "pk": 900,
  "fields": {
    "name": "ошибка_init"
  }
},
{
  "model": "cards.tag",
  "pk": 901,
  "fields": {
    "name": "software_development"
  }
},
{
  "model": "cards.tag",
  "pk": 902,
  "fields": {
    "name": "бездействие"
  }
},
{
  "model": "cards.tag",
  "pk": 903,
  "fields": {
    "name": "валидация"
  }
},
{
  "model": "cards.tag",
  "pk": 904,
  "fields": {
    "name": "инкапсуляция"
  }
},
{
  "model": "cards.tag",
  "pk": 905,
  "fields": {
    "name": "sqlite"
  }
},
{
  "model": "cards.tag",
  "pk": 906,
  "fields": {
    "name": "pandas"
  }
},
{
  "model": "cards.tag",
  "pk": 907,
  "fields": {
    "name": "файлы_pth"
  }
},
{
  "model": "cards.tag",
  "pk": 908,
  "fields": {
    "name": "оператор_return"
  }
},
{
  "model": "cards.tag",
  "pk": 909,
  "fields": {
    "name": "замок"
  }
},
{
  "model": "cards.tag",
  "pk": 910,
  "fields": {
    "name": "типы_ошибок"
  }
},
{
  "model": "cards.tag",
  "pk": 911,
  "fields": {
    "name": "агрегатные_функции"
  }
},
{
  "model": "cards.tag",
  "pk": 912,
  "fields": {
    "name": "sqlalchemy"
  }
},
{
  "model": "cards.tag",
  "pk": 913,
  "fields": {
    "name": "runtime_errors"
  }
},
{
  "model": "cards.tag",
  "pk": 914,
  "fields": {
    "name": "pep_8"
  }
},
{
  "model": "cards.tag",
  "pk": 915,
  "fields": {
    "name": "обработка_файлов"
  }
},
{
  "model": "cards.tag",
  "pk": 916,
  "fields": {
    "name": "none"
  }
},
{
  "model": "cards.tag",
  "pk": 917,
  "fields": {
    "name": "help"
  }
},
{
  "model": "cards.tag",
  "pk": 918,
  "fields": {
    "name": "упаковка_кода"
  }
},
{
  "model": "cards.tag",
  "pk": 919,
  "fields": {
    "name": "по_ссылке"
  }
},
{
  "model": "cards.tag",
  "pk": 920,
  "fields": {
    "name": "передача_параметров"
  }
},
{
  "model": "cards.tag",
  "pk": 921,
  "fields": {
    "name": "матричные_операции"
  }
},
{
  "model": "cards.tag",
  "pk": 922,
  "fields": {
    "name": "исполняемый_файл"
  }
},
{
  "model": "cards.tag",
  "pk": 923,
  "fields": {
    "name": "between"
  }
},
{
  "model": "cards.tag",
  "pk": 924,
  "fields": {
    "name": "кортеж_vs_список"
  }
},
{
  "model": "cards.tag",
  "pk": 925,
  "fields": {
    "name": "иерархическое_наследование"
  }
},
{
  "model": "cards.tag",
  "pk": 926,
  "fields": {
    "name": "выражения"
  }
},
{
  "model": "cards.tag",
  "pk": 927,
  "fields": {
    "name": "async/await"
  }
},
{
  "model": "cards.tag",
  "pk": 928,
  "fields": {
    "name": "рандомизация_списка"
  }
},
{
  "model": "cards.tag",
  "pk": 929,
  "fields": {
    "name": "команды"
  }
},
{
  "model": "cards.tag",
  "pk": 930,
  "fields": {
    "name": "администрирование"
  }
},
{
  "model": "cards.tag",
  "pk": 931,
  "fields": {
    "name": "logs"
  }
},
{
  "model": "cards.tag",
  "pk": 932,
  "fields": {
    "name": "переменные_экземпляра"
  }
},
{
  "model": "cards.tag",
  "pk": 933,
  "fields": {
    "name": "замороженный_набор"
  }
},
{
  "model": "cards.tag",
  "pk": 934,
  "fields": {
    "name": "typeerror"
  }
},
{
  "model": "cards.tag",
  "pk": 935,
  "fields": {
    "name": "free_variables"
  }
},
{
  "model": "cards.tag",
  "pk": 936,
  "fields": {
    "name": "перехват_ошибок"
  }
},
{
  "model": "cards.tag",
  "pk": 937,
  "fields": {
    "name": "менеджер_контекста"
  }
},
{
  "model": "cards.tag",
  "pk": 938,
  "fields": {
    "name": "переменное_количество_аргументов"
  }
},
{
  "model": "cards.tag",
  "pk": 939,
  "fields": {
    "name": "название"
  }
},
{
  "model": "cards.tag",
  "pk": 940,
  "fields": {
    "name": "open"
  }
},
{
  "model": "cards.tag",
  "pk": 941,
  "fields": {
    "name": "dict_keys"
  }
},
{
  "model": "cards.tag",
  "pk": 942,
  "fields": {
    "name": "целочисленное_деление"
  }
},
{
  "model": "cards.tag",
  "pk": 943,
  "fields": {
    "name": "1980-е"
  }
},
{
  "model": "cards.tag",
  "pk": 944,
  "fields": {
    "name": "ключи_в_словарях"
  }
},
{
  "model": "cards.tag",
  "pk": 945,
  "fields": {
    "name": "недостатки_python"
  }
},
{
  "model": "cards.tag",
  "pk": 946,
  "fields": {
    "name": "system_resources"
  }
},
{
  "model": "cards.tag",
  "pk": 947,
  "fields": {
    "name": "аргументы_командной_строки"
  }
},
{
  "model": "cards.tag",
  "pk": 948,
  "fields": {
    "name": "**kwargs"
  }
},
{
  "model": "cards.tag",
  "pk": 949,
  "fields": {
    "name": "структура_sql"
  }
},
{
  "model": "cards.tag",
  "pk": 950,
  "fields": {
    "name": "заглушка"
  }
},
{
  "model": "cards.tag",
  "pk": 951,
  "fields": {
    "name": "итерация"
  }
},
{
  "model": "cards.tag",
  "pk": 952,
  "fields": {
    "name": "статические_методы"
  }
},
{
  "model": "cards.tag",
  "pk": 953,
  "fields": {
    "name": "gc_module"
  }
},
{
  "model": "cards.tag",
  "pk": 954,
  "fields": {
    "name": "пакеты"
  }
},
{
  "model": "cards.tag",
  "pk": 955,
  "fields": {
    "name": "exponentiation"
  }
},
{
  "model": "cards.tag",
  "pk": 956,
  "fields": {
    "name": "работа_с_библиотеками"
  }
},
{
  "model": "cards.tag",
  "pk": 957,
  "fields": {
    "name": "веб_приложения"
  }
},
{
  "model": "cards.tag",
  "pk": 958,
  "fields": {
    "name": "default_arguments"
  }
},
{
  "model": "cards.tag",
  "pk": 959,
  "fields": {
    "name": "подклассы"
  }
},
{
  "model": "cards.tag",
  "pk": 960,
  "fields": {
    "name": "расписание"
  }
},
{
  "model": "cards.tag",
  "pk": 961,
  "fields": {
    "name": "менеджер_пакетов"
  }
},
{
  "model": "cards.tag",
  "pk": 962,
  "fields": {
    "name": "временная_сложность"
  }
},
{
  "model": "cards.tag",
  "pk": 963,
  "fields": {
    "name": "языковые_улучшения"
  }
},
{
  "model": "cards.tag",
  "pk": 964,
  "fields": {
    "name": "контроль_потока"
  }
},
{
  "model": "cards.tag",
  "pk": 965,
  "fields": {
    "name": "max"
  }
},
{
  "model": "cards.tag",
  "pk": 966,
  "fields": {
    "name": "конкатенация"
  }
},
{
  "model": "cards.tag",
  "pk": 967,
  "fields": {
    "name": "slots"
  }
},
{
  "model": "cards.tag",
  "pk": 968,
  "fields": {
    "name": "isdigit"
  }
},
{
  "model": "cards.tag",
  "pk": 969,
  "fields": {
    "name": "ключевые_параметры"
  }
},
{
  "model": "cards.tag",
  "pk": 970,
  "fields": {
    "name": "подсчет_заглавных_букв"
  }
},
{
  "model": "cards.tag",
  "pk": 971,
  "fields": {
    "name": "чтение_файла"
  }
},
{
  "model": "cards.tag",
  "pk": 972,
  "fields": {
    "name": "интерпретаторы"
  }
},
{
  "model": "cards.tag",
  "pk": 973,
  "fields": {
    "name": "правописание"
  }
},
{
  "model": "cards.tag",
  "pk": 974,
  "fields": {
    "name": "передача_значений"
  }
},
{
  "model": "cards.tag",
  "pk": 975,
  "fields": {
    "name": "memory_management"
  }
},
{
  "model": "cards.tag",
  "pk": 976,
  "fields": {
    "name": "sum"
  }
},
{
  "model": "cards.tag",
  "pk": 977,
  "fields": {
    "name": "str"
  }
},
{
  "model": "cards.tag",
  "pk": 978,
  "fields": {
    "name": "globals"
  }
},
{
  "model": "cards.tag",
  "pk": 979,
  "fields": {
    "name": "ссылки"
  }
},
{
  "model": "cards.tag",
  "pk": 980,
  "fields": {
    "name": "datetime"
  }
},
{
  "model": "cards.tag",
  "pk": 981,
  "fields": {
    "name": "count"
  }
},
{
  "model": "cards.tag",
  "pk": 982,
  "fields": {
    "name": "методы_списков"
  }
},
{
  "model": "cards.tag",
  "pk": 983,
  "fields": {
    "name": "setuptools"
  }
},
{
  "model": "cards.tag",
  "pk": 984,
  "fields": {
    "name": "реляционная_база_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 985,
  "fields": {
    "name": "версии_python"
  }
},
{
  "model": "cards.tag",
  "pk": 986,
  "fields": {
    "name": "абстрактные_методы"
  }
},
{
  "model": "cards.tag",
  "pk": 987,
  "fields": {
    "name": "быстрый_прототип"
  }
},
{
  "model": "cards.tag",
  "pk": 988,
  "fields": {
    "name": "inner_join"
  }
},
{
  "model": "cards.tag",
  "pk": 989,
  "fields": {
    "name": "gc"
  }
},
{
  "model": "cards.tag",
  "pk": 990,
  "fields": {
    "name": "assert_statements"
  }
},
{
  "model": "cards.tag",
  "pk": 991,
  "fields": {
    "name": "оператор_pass"
  }
},
{
  "model": "cards.tag",
  "pk": 992,
  "fields": {
    "name": "self"
  }
},
{
  "model": "cards.tag",
  "pk": 993,
  "fields": {
    "name": "метод_next"
  }
},
{
  "model": "cards.tag",
  "pk": 994,
  "fields": {
    "name": "сжатие_словарей"
  }
},
{
  "model": "cards.tag",
  "pk": 995,
  "fields": {
    "name": "написание_кода"
  }
},
{
  "model": "cards.tag",
  "pk": 996,
  "fields": {
    "name": "импорт_модулей"
  }
},
{
  "model": "cards.tag",
  "pk": 997,
  "fields": {
    "name": "разработка_веб-приложений"
  }
},
{
  "model": "cards.tag",
  "pk": 998,
  "fields": {
    "name": "неизменяемость"
  }
},
{
  "model": "cards.tag",
  "pk": 999,
  "fields": {
    "name": "GIL"
  }
},
{
  "model": "cards.tag",
  "pk": 1000,
  "fields": {
    "name": "rank"
  }
},
{
  "model": "cards.tag",
  "pk": 1001,
  "fields": {
    "name": "динамический_тип"
  }
},
{
  "model": "cards.tag",
  "pk": 1002,
  "fields": {
    "name": "ускорение_выполнения"
  }
},
{
  "model": "cards.tag",
  "pk": 1003,
  "fields": {
    "name": "чувствительность_к_регистру"
  }
},
{
  "model": "cards.tag",
  "pk": 1004,
  "fields": {
    "name": "атрибуты"
  }
},
{
  "model": "cards.tag",
  "pk": 1005,
  "fields": {
    "name": "scipy"
  }
},
{
  "model": "cards.tag",
  "pk": 1006,
  "fields": {
    "name": "gmail"
  }
},
{
  "model": "cards.tag",
  "pk": 1007,
  "fields": {
    "name": "именованные_аргументы"
  }
},
{
  "model": "cards.tag",
  "pk": 1008,
  "fields": {
    "name": "enumerate"
  }
},
{
  "model": "cards.tag",
  "pk": 1009,
  "fields": {
    "name": "протокол_доступа_к_атрибутам"
  }
},
{
  "model": "cards.tag",
  "pk": 1010,
  "fields": {
    "name": "параметры_запуска"
  }
},
{
  "model": "cards.tag",
  "pk": 1011,
  "fields": {
    "name": "вызов_функций"
  }
},
{
  "model": "cards.tag",
  "pk": 1012,
  "fields": {
    "name": "проверка_типов"
  }
},
{
  "model": "cards.tag",
  "pk": 1013,
  "fields": {
    "name": "машинный_язык"
  }
},
{
  "model": "cards.tag",
  "pk": 1014,
  "fields": {
    "name": "модульность"
  }
},
{
  "model": "cards.tag",
  "pk": 1015,
  "fields": {
    "name": "split"
  }
},
{
  "model": "cards.tag",
  "pk": 1016,
  "fields": {
    "name": "pymemcache"
  }
},
{
  "model": "cards.tag",
  "pk": 1017,
  "fields": {
    "name": "серверы"
  }
},
{
  "model": "cards.tag",
  "pk": 1018,
  "fields": {
    "name": "управление_циклом"
  }
},
{
  "model": "cards.tag",
  "pk": 1019,
  "fields": {
    "name": "различия_python2_python3"
  }
},
{
  "model": "cards.tag",
  "pk": 1020,
  "fields": {
    "name": "str_vs_repr"
  }
},
{
  "model": "cards.tag",
  "pk": 1021,
  "fields": {
    "name": "вывод_в_консоль"
  }
},
{
  "model": "cards.tag",
  "pk": 1022,
  "fields": {
    "name": "специальные_символы"
  }
},
{
  "model": "cards.tag",
  "pk": 1023,
  "fields": {
    "name": "множественное_наследование"
  }
},
{
  "model": "cards.tag",
  "pk": 1024,
  "fields": {
    "name": "match-case"
  }
},
{
  "model": "cards.tag",
  "pk": 1025,
  "fields": {
    "name": "firewall"
  }
},
{
  "model": "cards.tag",
  "pk": 1026,
  "fields": {
    "name": "python_import"
  }
},
{
  "model": "cards.tag",
  "pk": 1027,
  "fields": {
    "name": "docstrings"
  }
},
{
  "model": "cards.tag",
  "pk": 1028,
  "fields": {
    "name": "html"
  }
},
{
  "model": "cards.tag",
  "pk": 1029,
  "fields": {
    "name": "удаление_элемента"
  }
},
{
  "model": "cards.tag",
  "pk": 1030,
  "fields": {
    "name": "композиция"
  }
},
{
  "model": "cards.tag",
  "pk": 1031,
  "fields": {
    "name": "инварианты"
  }
},
{
  "model": "cards.tag",
  "pk": 1032,
  "fields": {
    "name": "запуск_python"
  }
},
{
  "model": "cards.tag",
  "pk": 1033,
  "fields": {
    "name": "objgraph"
  }
},
{
  "model": "cards.tag",
  "pk": 1034,
  "fields": {
    "name": "эффективность_памяти"
  }
},
{
  "model": "cards.tag",
  "pk": 1035,
  "fields": {
    "name": "class"
  }
},
{
  "model": "cards.tag",
  "pk": 1036,
  "fields": {
    "name": "создание_пакета"
  }
},
{
  "model": "cards.tag",
  "pk": 1037,
  "fields": {
    "name": "кэширование_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 1038,
  "fields": {
    "name": "re"
  }
},
{
  "model": "cards.tag",
  "pk": 1039,
  "fields": {
    "name": "специальное_значение"
  }
},
{
  "model": "cards.tag",
  "pk": 1040,
  "fields": {
    "name": "изменение_методов"
  }
},
{
  "model": "cards.tag",
  "pk": 1041,
  "fields": {
    "name": "exceptions"
  }
},
{
  "model": "cards.tag",
  "pk": 1042,
  "fields": {
    "name": "форматирование"
  }
},
{
  "model": "cards.tag",
  "pk": 1043,
  "fields": {
    "name": "переменные_окружения"
  }
},
{
  "model": "cards.tag",
  "pk": 1044,
  "fields": {
    "name": "methods"
  }
},
{
  "model": "cards.tag",
  "pk": 1045,
  "fields": {
    "name": "обращение_к_элементам"
  }
},
{
  "model": "cards.tag",
  "pk": 1046,
  "fields": {
    "name": "uppercase_count"
  }
},
{
  "model": "cards.tag",
  "pk": 1047,
  "fields": {
    "name": "couchbase"
  }
},
{
  "model": "cards.tag",
  "pk": 1048,
  "fields": {
    "name": "duck_typing"
  }
},
{
  "model": "cards.tag",
  "pk": 1049,
  "fields": {
    "name": "приватные_идентификаторы"
  }
},
{
  "model": "cards.tag",
  "pk": 1050,
  "fields": {
    "name": "variables"
  }
},
{
  "model": "cards.tag",
  "pk": 1051,
  "fields": {
    "name": "ключ-значение"
  }
},
{
  "model": "cards.tag",
  "pk": 1052,
  "fields": {
    "name": "асинхронные_функции"
  }
},
{
  "model": "cards.tag",
  "pk": 1053,
  "fields": {
    "name": "побитовые_операторы"
  }
},
{
  "model": "cards.tag",
  "pk": 1054,
  "fields": {
    "name": "mysql_connector_python"
  }
},
{
  "model": "cards.tag",
  "pk": 1055,
  "fields": {
    "name": "управление_памятью"
  }
},
{
  "model": "cards.tag",
  "pk": 1056,
  "fields": {
    "name": "контекстный_процессор"
  }
},
{
  "model": "cards.tag",
  "pk": 1057,
  "fields": {
    "name": "оптимизация"
  }
},
{
  "model": "cards.tag",
  "pk": 1058,
  "fields": {
    "name": "отсутствие_значения"
  }
},
{
  "model": "cards.tag",
  "pk": 1059,
  "fields": {
    "name": "асинхронный_http-запрос"
  }
},
{
  "model": "cards.tag",
  "pk": 1060,
  "fields": {
    "name": "java"
  }
},
{
  "model": "cards.tag",
  "pk": 1061,
  "fields": {
    "name": "подсчет_строк"
  }
},
{
  "model": "cards.tag",
  "pk": 1062,
  "fields": {
    "name": "списки"
  }
},
{
  "model": "cards.tag",
  "pk": 1063,
  "fields": {
    "name": "управление_потоками"
  }
},
{
  "model": "cards.tag",
  "pk": 1064,
  "fields": {
    "name": "запись_в_файл"
  }
},
{
  "model": "cards.tag",
  "pk": 1065,
  "fields": {
    "name": "подсчет_символов"
  }
},
{
  "model": "cards.tag",
  "pk": 1066,
  "fields": {
    "name": "counter"
  }
},
{
  "model": "cards.tag",
  "pk": 1067,
  "fields": {
    "name": "collections"
  }
},
{
  "model": "cards.tag",
  "pk": 1068,
  "fields": {
    "name": "блокировка"
  }
},
{
  "model": "cards.tag",
  "pk": 1069,
  "fields": {
    "name": "in_not_in"
  }
},
{
  "model": "cards.tag",
  "pk": 1070,
  "fields": {
    "name": "интерактивный_отладчик"
  }
},
{
  "model": "cards.tag",
  "pk": 1071,
  "fields": {
    "name": "срезы_списка"
  }
},
{
  "model": "cards.tag",
  "pk": 1072,
  "fields": {
    "name": "mock"
  }
},
{
  "model": "cards.tag",
  "pk": 1073,
  "fields": {
    "name": "chain"
  }
},
{
  "model": "cards.tag",
  "pk": 1074,
  "fields": {
    "name": "regex"
  }
},
{
  "model": "cards.tag",
  "pk": 1075,
  "fields": {
    "name": "динамическое_выполнение_кода"
  }
},
{
  "model": "cards.tag",
  "pk": 1076,
  "fields": {
    "name": "try_except"
  }
},
{
  "model": "cards.tag",
  "pk": 1077,
  "fields": {
    "name": "абстрактные_базовые_классы"
  }
},
{
  "model": "cards.tag",
  "pk": 1078,
  "fields": {
    "name": "исправления_ошибок"
  }
},
{
  "model": "cards.tag",
  "pk": 1079,
  "fields": {
    "name": "инструкция_yield"
  }
},
{
  "model": "cards.tag",
  "pk": 1080,
  "fields": {
    "name": "время_выполнения"
  }
},
{
  "model": "cards.tag",
  "pk": 1081,
  "fields": {
    "name": "булево_значение"
  }
},
{
  "model": "cards.tag",
  "pk": 1082,
  "fields": {
    "name": "функция_range"
  }
},
{
  "model": "cards.tag",
  "pk": 1083,
  "fields": {
    "name": "range"
  }
},
{
  "model": "cards.tag",
  "pk": 1084,
  "fields": {
    "name": "int"
  }
},
{
  "model": "cards.tag",
  "pk": 1085,
  "fields": {
    "name": "все_объекты"
  }
},
{
  "model": "cards.tag",
  "pk": 1086,
  "fields": {
    "name": "переопределение_методов"
  }
},
{
  "model": "cards.tag",
  "pk": 1087,
  "fields": {
    "name": "timestamp"
  }
},
{
  "model": "cards.tag",
  "pk": 1088,
  "fields": {
    "name": "корутины"
  }
},
{
  "model": "cards.tag",
  "pk": 1089,
  "fields": {
    "name": "работа_с_объектами"
  }
},
{
  "model": "cards.tag",
  "pk": 1090,
  "fields": {
    "name": "условия_выборки"
  }
},
{
  "model": "cards.tag",
  "pk": 1091,
  "fields": {
    "name": "язык_программирования_abc"
  }
},
{
  "model": "cards.tag",
  "pk": 1092,
  "fields": {
    "name": "airflow"
  }
},
{
  "model": "cards.tag",
  "pk": 1093,
  "fields": {
    "name": "работа_с_текстом"
  }
},
{
  "model": "cards.tag",
  "pk": 1094,
  "fields": {
    "name": "cmd_c"
  }
},
{
  "model": "cards.tag",
  "pk": 1095,
  "fields": {
    "name": "lambda"
  }
},
{
  "model": "cards.tag",
  "pk": 1096,
  "fields": {
    "name": "маршруты"
  }
},
{
  "model": "cards.tag",
  "pk": 1097,
  "fields": {
    "name": "управляющие_структуры"
  }
},
{
  "model": "cards.tag",
  "pk": 1098,
  "fields": {
    "name": "инструменты_приема_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 1099,
  "fields": {
    "name": "инициализация_объекта"
  }
},
{
  "model": "cards.tag",
  "pk": 1100,
  "fields": {
    "name": "library"
  }
},
{
  "model": "cards.tag",
  "pk": 1101,
  "fields": {
    "name": "словари"
  }
},
{
  "model": "cards.tag",
  "pk": 1102,
  "fields": {
    "name": "web-разработка"
  }
},
{
  "model": "cards.tag",
  "pk": 1103,
  "fields": {
    "name": "python_operators"
  }
},
{
  "model": "cards.tag",
  "pk": 1104,
  "fields": {
    "name": "минимизация_простоя"
  }
},
{
  "model": "cards.tag",
  "pk": 1105,
  "fields": {
    "name": "xml"
  }
},
{
  "model": "cards.tag",
  "pk": 1106,
  "fields": {
    "name": "python3"
  }
},
{
  "model": "cards.tag",
  "pk": 1107,
  "fields": {
    "name": "агрегирование_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 1108,
  "fields": {
    "name": "эффект_dogpile"
  }
},
{
  "model": "cards.tag",
  "pk": 1109,
  "fields": {
    "name": "ключевое_слово_dict"
  }
},
{
  "model": "cards.tag",
  "pk": 1110,
  "fields": {
    "name": "binary_to_decimal"
  }
},
{
  "model": "cards.tag",
  "pk": 1111,
  "fields": {
    "name": "сортировка_пузырьком"
  }
},
{
  "model": "cards.tag",
  "pk": 1112,
  "fields": {
    "name": "палиндром"
  }
},
{
  "model": "cards.tag",
  "pk": 1113,
  "fields": {
    "name": "коллизии"
  }
},
{
  "model": "cards.tag",
  "pk": 1114,
  "fields": {
    "name": "разница_count"
  }
},
{
  "model": "cards.tag",
  "pk": 1115,
  "fields": {
    "name": "хранение_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 1116,
  "fields": {
    "name": "setup.py"
  }
},
{
  "model": "cards.tag",
  "pk": 1117,
  "fields": {
    "name": "взаимодействие_python_c"
  }
},
{
  "model": "cards.tag",
  "pk": 1118,
  "fields": {
    "name": "распаковка_списка"
  }
},
{
  "model": "cards.tag",
  "pk": 1119,
  "fields": {
    "name": "создание_списка"
  }
},
{
  "model": "cards.tag",
  "pk": 1120,
  "fields": {
    "name": "вложенные_запросы"
  }
},
{
  "model": "cards.tag",
  "pk": 1121,
  "fields": {
    "name": "операторы_идентификации"
  }
},
{
  "model": "cards.tag",
  "pk": 1122,
  "fields": {
    "name": "методы_iter_и_next"
  }
},
{
  "model": "cards.tag",
  "pk": 1123,
  "fields": {
    "name": "конвертация_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 1124,
  "fields": {
    "name": "unix"
  }
},
{
  "model": "cards.tag",
  "pk": 1125,
  "fields": {
    "name": "zero_division_error"
  }
},
{
  "model": "cards.tag",
  "pk": 1126,
  "fields": {
    "name": "primary_key"
  }
},
{
  "model": "cards.tag",
  "pk": 1127,
  "fields": {
    "name": "имя_модуля"
  }
},
{
  "model": "cards.tag",
  "pk": 1128,
  "fields": {
    "name": "tuples"
  }
},
{
  "model": "cards.tag",
  "pk": 1129,
  "fields": {
    "name": "алгоритм_c3"
  }
},
{
  "model": "cards.tag",
  "pk": 1130,
  "fields": {
    "name": "научные_вычисления"
  }
},
{
  "model": "cards.tag",
  "pk": 1131,
  "fields": {
    "name": "for_loop"
  }
},
{
  "model": "cards.tag",
  "pk": 1132,
  "fields": {
    "name": "хвостовая_рекурсия"
  }
},
{
  "model": "cards.tag",
  "pk": 1133,
  "fields": {
    "name": "ресурсы"
  }
},
{
  "model": "cards.tag",
  "pk": 1134,
  "fields": {
    "name": "изоляция_зависимостей"
  }
},
{
  "model": "cards.tag",
  "pk": 1135,
  "fields": {
    "name": "тройные_кавычки"
  }
},
{
  "model": "cards.tag",
  "pk": 1136,
  "fields": {
    "name": "создание_словарей"
  }
},
{
  "model": "cards.tag",
  "pk": 1137,
  "fields": {
    "name": "None"
  }
},
{
  "model": "cards.tag",
  "pk": 1138,
  "fields": {
    "name": "публичные_методы"
  }
},
{
  "model": "cards.tag",
  "pk": 1139,
  "fields": {
    "name": "data_structures"
  }
},
{
  "model": "cards.tag",
  "pk": 1140,
  "fields": {
    "name": "запись_файла"
  }
},
{
  "model": "cards.tag",
  "pk": 1141,
  "fields": {
    "name": "глобальное_пространство"
  }
},
{
  "model": "cards.tag",
  "pk": 1142,
  "fields": {
    "name": "определение_класса"
  }
},
{
  "model": "cards.tag",
  "pk": 1143,
  "fields": {
    "name": "@property"
  }
},
{
  "model": "cards.tag",
  "pk": 1144,
  "fields": {
    "name": "декартово_произведение"
  }
},
{
  "model": "cards.tag",
  "pk": 1145,
  "fields": {
    "name": "скрипты"
  }
},
{
  "model": "cards.tag",
  "pk": 1146,
  "fields": {
    "name": "последовательности"
  }
},
{
  "model": "cards.tag",
  "pk": 1147,
  "fields": {
    "name": "остаток_от_деления"
  }
},
{
  "model": "cards.tag",
  "pk": 1148,
  "fields": {
    "name": "batteries_included"
  }
},
{
  "model": "cards.tag",
  "pk": 1149,
  "fields": {
    "name": "micropython"
  }
},
{
  "model": "cards.tag",
  "pk": 1150,
  "fields": {
    "name": "python_debugging"
  }
},
{
  "model": "cards.tag",
  "pk": 1151,
  "fields": {
    "name": "dml"
  }
},
{
  "model": "cards.tag",
  "pk": 1152,
  "fields": {
    "name": "выполнение_запросов"
  }
},
{
  "model": "cards.tag",
  "pk": 1153,
  "fields": {
    "name": "dictionary"
  }
},
{
  "model": "cards.tag",
  "pk": 1154,
  "fields": {
    "name": "хранение_даты"
  }
},
{
  "model": "cards.tag",
  "pk": 1155,
  "fields": {
    "name": "signal"
  }
},
{
  "model": "cards.tag",
  "pk": 1156,
  "fields": {
    "name": "алгоритм_хэширования"
  }
},
{
  "model": "cards.tag",
  "pk": 1157,
  "fields": {
    "name": "ленивая_генерация"
  }
},
{
  "model": "cards.tag",
  "pk": 1158,
  "fields": {
    "name": "списковые_включения"
  }
},
{
  "model": "cards.tag",
  "pk": 1159,
  "fields": {
    "name": "reload"
  }
},
{
  "model": "cards.tag",
  "pk": 1160,
  "fields": {
    "name": "архитектура_приложения"
  }
},
{
  "model": "cards.tag",
  "pk": 1161,
  "fields": {
    "name": "блок_кода"
  }
},
{
  "model": "cards.tag",
  "pk": 1162,
  "fields": {
    "name": "like"
  }
},
{
  "model": "cards.tag",
  "pk": 1163,
  "fields": {
    "name": "бинарные_зависимости"
  }
},
{
  "model": "cards.tag",
  "pk": 1164,
  "fields": {
    "name": "бинарные_операции"
  }
},
{
  "model": "cards.tag",
  "pk": 1165,
  "fields": {
    "name": "programming"
  }
},
{
  "model": "cards.tag",
  "pk": 1166,
  "fields": {
    "name": "генерация_списков"
  }
},
{
  "model": "cards.tag",
  "pk": 1167,
  "fields": {
    "name": "работа_с_базами"
  }
},
{
  "model": "cards.tag",
  "pk": 1168,
  "fields": {
    "name": "eval"
  }
},
{
  "model": "cards.tag",
  "pk": 1169,
  "fields": {
    "name": "внешние_библиотеки"
  }
},
{
  "model": "cards.tag",
  "pk": 1170,
  "fields": {
    "name": "dict"
  }
},
{
  "model": "cards.tag",
  "pk": 1171,
  "fields": {
    "name": "операции_со_списками"
  }
},
{
  "model": "cards.tag",
  "pk": 1172,
  "fields": {
    "name": "доступ_к_атрибутам"
  }
},
{
  "model": "cards.tag",
  "pk": 1173,
  "fields": {
    "name": "declare"
  }
},
{
  "model": "cards.tag",
  "pk": 1174,
  "fields": {
    "name": "компиляция"
  }
},
{
  "model": "cards.tag",
  "pk": 1175,
  "fields": {
    "name": "списковое_включение"
  }
},
{
  "model": "cards.tag",
  "pk": 1176,
  "fields": {
    "name": "javascript"
  }
},
{
  "model": "cards.tag",
  "pk": 1177,
  "fields": {
    "name": "help()"
  }
},
{
  "model": "cards.tag",
  "pk": 1178,
  "fields": {
    "name": "работа_с_директориями"
  }
},
{
  "model": "cards.tag",
  "pk": 1179,
  "fields": {
    "name": "кодировка_ascii"
  }
},
{
  "model": "cards.tag",
  "pk": 1180,
  "fields": {
    "name": "аксессоры"
  }
},
{
  "model": "cards.tag",
  "pk": 1181,
  "fields": {
    "name": "view"
  }
},
{
  "model": "cards.tag",
  "pk": 1182,
  "fields": {
    "name": "присвоение_значений"
  }
},
{
  "model": "cards.tag",
  "pk": 1183,
  "fields": {
    "name": "yield"
  }
},
{
  "model": "cards.tag",
  "pk": 1184,
  "fields": {
    "name": "отладка_кода"
  }
},
{
  "model": "cards.tag",
  "pk": 1185,
  "fields": {
    "name": "интерпретируемый_язык"
  }
},
{
  "model": "cards.tag",
  "pk": 1186,
  "fields": {
    "name": "битовые_операции"
  }
},
{
  "model": "cards.tag",
  "pk": 1187,
  "fields": {
    "name": "удаление_объектов"
  }
},
{
  "model": "cards.tag",
  "pk": 1188,
  "fields": {
    "name": "числа"
  }
},
{
  "model": "cards.tag",
  "pk": 1189,
  "fields": {
    "name": "programming_language"
  }
},
{
  "model": "cards.tag",
  "pk": 1190,
  "fields": {
    "name": "управление_исключениями"
  }
},
{
  "model": "cards.tag",
  "pk": 1191,
  "fields": {
    "name": "десктопные_приложения"
  }
},
{
  "model": "cards.tag",
  "pk": 1192,
  "fields": {
    "name": "динамические_атрибуты"
  }
},
{
  "model": "cards.tag",
  "pk": 1193,
  "fields": {
    "name": "создание_исключений"
  }
},
{
  "model": "cards.tag",
  "pk": 1194,
  "fields": {
    "name": "функция"
  }
},
{
  "model": "cards.tag",
  "pk": 1195,
  "fields": {
    "name": "изменяемые_типы_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 1196,
  "fields": {
    "name": "отправка_почты"
  }
},
{
  "model": "cards.tag",
  "pk": 1197,
  "fields": {
    "name": "dcl"
  }
},
{
  "model": "cards.tag",
  "pk": 1198,
  "fields": {
    "name": "auto_increment"
  }
},
{
  "model": "cards.tag",
  "pk": 1199,
  "fields": {
    "name": "name_mangling"
  }
},
{
  "model": "cards.tag",
  "pk": 1200,
  "fields": {
    "name": "лямбда_выражения"
  }
},
{
  "model": "cards.tag",
  "pk": 1201,
  "fields": {
    "name": "цикл_while"
  }
},
{
  "model": "cards.tag",
  "pk": 1202,
  "fields": {
    "name": "веб-разработка"
  }
},
{
  "model": "cards.tag",
  "pk": 1203,
  "fields": {
    "name": "line_count"
  }
},
{
  "model": "cards.tag",
  "pk": 1204,
  "fields": {
    "name": "неблокирующий_ввод-вывод"
  }
},
{
  "model": "cards.tag",
  "pk": 1205,
  "fields": {
    "name": "фигурные_скобки"
  }
},
{
  "model": "cards.tag",
  "pk": 1206,
  "fields": {
    "name": "venv"
  }
},
{
  "model": "cards.tag",
  "pk": 1207,
  "fields": {
    "name": "счетчик_ссылок"
  }
},
{
  "model": "cards.tag",
  "pk": 1208,
  "fields": {
    "name": "оператор_for"
  }
},
{
  "model": "cards.tag",
  "pk": 1209,
  "fields": {
    "name": "валидация_форм"
  }
},
{
  "model": "cards.tag",
  "pk": 1210,
  "fields": {
    "name": "генераторы_списков"
  }
},
{
  "model": "cards.tag",
  "pk": 1211,
  "fields": {
    "name": "pickle"
  }
},
{
  "model": "cards.tag",
  "pk": 1212,
  "fields": {
    "name": "алгоритм"
  }
},
{
  "model": "cards.tag",
  "pk": 1213,
  "fields": {
    "name": "автоматическое_закрытие_ресурсов"
  }
},
{
  "model": "cards.tag",
  "pk": 1214,
  "fields": {
    "name": "reverse"
  }
},
{
  "model": "cards.tag",
  "pk": 1215,
  "fields": {
    "name": "число_в_строку"
  }
},
{
  "model": "cards.tag",
  "pk": 1216,
  "fields": {
    "name": "контекстный_менеджер"
  }
},
{
  "model": "cards.tag",
  "pk": 1217,
  "fields": {
    "name": "иерархия_исключений"
  }
},
{
  "model": "cards.tag",
  "pk": 1218,
  "fields": {
    "name": "list"
  }
},
{
  "model": "cards.tag",
  "pk": 1219,
  "fields": {
    "name": "аргументы"
  }
},
{
  "model": "cards.tag",
  "pk": 1220,
  "fields": {
    "name": "возвращаемое_значение"
  }
},
{
  "model": "cards.tag",
  "pk": 1221,
  "fields": {
    "name": "slicing"
  }
},
{
  "model": "cards.tag",
  "pk": 1222,
  "fields": {
    "name": "cross_join"
  }
},
{
  "model": "cards.tag",
  "pk": 1223,
  "fields": {
    "name": "ps"
  }
},
{
  "model": "cards.tag",
  "pk": 1224,
  "fields": {
    "name": "веб-приложения"
  }
},
{
  "model": "cards.tag",
  "pk": 1225,
  "fields": {
    "name": "использование_в_словарях"
  }
},
{
  "model": "cards.tag",
  "pk": 1226,
  "fields": {
    "name": "ironpython"
  }
},
{
  "model": "cards.tag",
  "pk": 1227,
  "fields": {
    "name": "доступность_сети"
  }
},
{
  "model": "cards.tag",
  "pk": 1228,
  "fields": {
    "name": "привязка_значений"
  }
},
{
  "model": "cards.tag",
  "pk": 1229,
  "fields": {
    "name": "unpivot"
  }
},
{
  "model": "cards.tag",
  "pk": 1230,
  "fields": {
    "name": "having"
  }
},
{
  "model": "cards.tag",
  "pk": 1231,
  "fields": {
    "name": "wheel"
  }
},
{
  "model": "cards.tag",
  "pk": 1232,
  "fields": {
    "name": "object-oriented_programming"
  }
},
{
  "model": "cards.tag",
  "pk": 1233,
  "fields": {
    "name": "key-value"
  }
},
{
  "model": "cards.tag",
  "pk": 1234,
  "fields": {
    "name": "jit_компиляция"
  }
},
{
  "model": "cards.tag",
  "pk": 1235,
  "fields": {
    "name": "обучение"
  }
},
{
  "model": "cards.tag",
  "pk": 1236,
  "fields": {
    "name": "dense_rank"
  }
},
{
  "model": "cards.tag",
  "pk": 1237,
  "fields": {
    "name": "порядок_столбцов"
  }
},
{
  "model": "cards.tag",
  "pk": 1238,
  "fields": {
    "name": "сборщик_мусора"
  }
},
{
  "model": "cards.tag",
  "pk": 1239,
  "fields": {
    "name": "ctypes"
  }
},
{
  "model": "cards.tag",
  "pk": 1240,
  "fields": {
    "name": "pythonoptimize"
  }
},
{
  "model": "cards.tag",
  "pk": 1241,
  "fields": {
    "name": "передача_аргументов"
  }
},
{
  "model": "cards.tag",
  "pk": 1242,
  "fields": {
    "name": "основы_программирования"
  }
},
{
  "model": "cards.tag",
  "pk": 1243,
  "fields": {
    "name": "динамическая_замена"
  }
},
{
  "model": "cards.tag",
  "pk": 1244,
  "fields": {
    "name": "компилятор"
  }
},
{
  "model": "cards.tag",
  "pk": 1245,
  "fields": {
    "name": "работа_с_коллекциями"
  }
},
{
  "model": "cards.tag",
  "pk": 1246,
  "fields": {
    "name": "deallocate"
  }
},
{
  "model": "cards.tag",
  "pk": 1247,
  "fields": {
    "name": "thread_lifecycle"
  }
},
{
  "model": "cards.tag",
  "pk": 1248,
  "fields": {
    "name": "math"
  }
},
{
  "model": "cards.tag",
  "pk": 1249,
  "fields": {
    "name": "def"
  }
},
{
  "model": "cards.tag",
  "pk": 1250,
  "fields": {
    "name": "префикс_u"
  }
},
{
  "model": "cards.tag",
  "pk": 1251,
  "fields": {
    "name": "c"
  }
},
{
  "model": "cards.tag",
  "pk": 1252,
  "fields": {
    "name": "intersect"
  }
},
{
  "model": "cards.tag",
  "pk": 1253,
  "fields": {
    "name": "словарь"
  }
},
{
  "model": "cards.tag",
  "pk": 1254,
  "fields": {
    "name": "сопоставление_с_образцом"
  }
},
{
  "model": "cards.tag",
  "pk": 1255,
  "fields": {
    "name": "методы_экземпляра"
  }
},
{
  "model": "cards.tag",
  "pk": 1256,
  "fields": {
    "name": "python"
  }
},
{
  "model": "cards.tag",
  "pk": 1257,
  "fields": {
    "name": "циклический_сборщик"
  }
},
{
  "model": "cards.tag",
  "pk": 1258,
  "fields": {
    "name": "optimization"
  }
},
{
  "model": "cards.tag",
  "pk": 1259,
  "fields": {
    "name": "flask"
  }
},
{
  "model": "cards.tag",
  "pk": 1260,
  "fields": {
    "name": "счетчик"
  }
},
{
  "model": "cards.tag",
  "pk": 1261,
  "fields": {
    "name": "низкий_уровень_программирования"
  }
},
{
  "model": "cards.tag",
  "pk": 1262,
  "fields": {
    "name": "конструктор_класса"
  }
},
{
  "model": "cards.tag",
  "pk": 1263,
  "fields": {
    "name": "локальное_пространство"
  }
},
{
  "model": "cards.tag",
  "pk": 1264,
  "fields": {
    "name": "перевернуть_генератор"
  }
},
{
  "model": "cards.tag",
  "pk": 1265,
  "fields": {
    "name": "стандарты_кодирования"
  }
},
{
  "model": "cards.tag",
  "pk": 1266,
  "fields": {
    "name": "исключения"
  }
},
{
  "model": "cards.tag",
  "pk": 1267,
  "fields": {
    "name": "тестирование"
  }
},
{
  "model": "cards.tag",
  "pk": 1268,
  "fields": {
    "name": "запросы"
  }
},
{
  "model": "cards.tag",
  "pk": 1269,
  "fields": {
    "name": "встроенный_модуль"
  }
},
{
  "model": "cards.tag",
  "pk": 1270,
  "fields": {
    "name": "зависимости_модулей"
  }
},
{
  "model": "cards.tag",
  "pk": 1271,
  "fields": {
    "name": "jpype"
  }
},
{
  "model": "cards.tag",
  "pk": 1272,
  "fields": {
    "name": "ооп"
  }
},
{
  "model": "cards.tag",
  "pk": 1273,
  "fields": {
    "name": "интерпретируемый"
  }
},
{
  "model": "cards.tag",
  "pk": 1274,
  "fields": {
    "name": "команды_отладки"
  }
},
{
  "model": "cards.tag",
  "pk": 1275,
  "fields": {
    "name": "репликация_кода"
  }
},
{
  "model": "cards.tag",
  "pk": 1276,
  "fields": {
    "name": "атрибуты_класса"
  }
},
{
  "model": "cards.tag",
  "pk": 1277,
  "fields": {
    "name": "алгоритмы"
  }
},
{
  "model": "cards.tag",
  "pk": 1278,
  "fields": {
    "name": "типы_последовательностей"
  }
},
{
  "model": "cards.tag",
  "pk": 1279,
  "fields": {
    "name": "простой_синтаксис"
  }
},
{
  "model": "cards.tag",
  "pk": 1280,
  "fields": {
    "name": "упорядоченная_последовательность"
  }
},
{
  "model": "cards.tag",
  "pk": 1281,
  "fields": {
    "name": "with_оператор"
  }
},
{
  "model": "cards.tag",
  "pk": 1282,
  "fields": {
    "name": "альтернативные_реализации"
  }
},
{
  "model": "cards.tag",
  "pk": 1283,
  "fields": {
    "name": "cython"
  }
},
{
  "model": "cards.tag",
  "pk": 1284,
  "fields": {
    "name": "pycache"
  }
},
{
  "model": "cards.tag",
  "pk": 1285,
  "fields": {
    "name": "различия"
  }
},
{
  "model": "cards.tag",
  "pk": 1286,
  "fields": {
    "name": "функции_высшего_порядка"
  }
},
{
  "model": "cards.tag",
  "pk": 1287,
  "fields": {
    "name": "создание_класса"
  }
},
{
  "model": "cards.tag",
  "pk": 1288,
  "fields": {
    "name": "функции_и_модули"
  }
},
{
  "model": "cards.tag",
  "pk": 1289,
  "fields": {
    "name": "args"
  }
},
{
  "model": "cards.tag",
  "pk": 1290,
  "fields": {
    "name": "сравнение_объектов"
  }
},
{
  "model": "cards.tag",
  "pk": 1291,
  "fields": {
    "name": "сжатие_списков"
  }
},
{
  "model": "cards.tag",
  "pk": 1292,
  "fields": {
    "name": "ранжирование"
  }
},
{
  "model": "cards.tag",
  "pk": 1293,
  "fields": {
    "name": "типы_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 1294,
  "fields": {
    "name": "необязательные_аргументы"
  }
},
{
  "model": "cards.tag",
  "pk": 1295,
  "fields": {
    "name": "sys.exit"
  }
},
{
  "model": "cards.tag",
  "pk": 1296,
  "fields": {
    "name": "область_видимости"
  }
},
{
  "model": "cards.tag",
  "pk": 1297,
  "fields": {
    "name": "поиск_в_строке"
  }
},
{
  "model": "cards.tag",
  "pk": 1298,
  "fields": {
    "name": "управление_сессиями"
  }
},
{
  "model": "cards.tag",
  "pk": 1299,
  "fields": {
    "name": "copy"
  }
},
{
  "model": "cards.tag",
  "pk": 1300,
  "fields": {
    "name": "randint"
  }
},
{
  "model": "cards.tag",
  "pk": 1301,
  "fields": {
    "name": "wheels"
  }
},
{
  "model": "cards.tag",
  "pk": 1302,
  "fields": {
    "name": "структуры_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 1303,
  "fields": {
    "name": "параметры"
  }
},
{
  "model": "cards.tag",
  "pk": 1304,
  "fields": {
    "name": "свойства"
  }
},
{
  "model": "cards.tag",
  "pk": 1305,
  "fields": {
    "name": "list_pop_method"
  }
},
{
  "model": "cards.tag",
  "pk": 1306,
  "fields": {
    "name": "исследование_кода"
  }
},
{
  "model": "cards.tag",
  "pk": 1307,
  "fields": {
    "name": "tkinter"
  }
},
{
  "model": "cards.tag",
  "pk": 1308,
  "fields": {
    "name": "декоратор"
  }
},
{
  "model": "cards.tag",
  "pk": 1309,
  "fields": {
    "name": "инициализация_класса"
  }
},
{
  "model": "cards.tag",
  "pk": 1310,
  "fields": {
    "name": "отрицательные_индексы"
  }
},
{
  "model": "cards.tag",
  "pk": 1311,
  "fields": {
    "name": "ускорение_загрузки"
  }
},
{
  "model": "cards.tag",
  "pk": 1312,
  "fields": {
    "name": "компактный_код"
  }
},
{
  "model": "cards.tag",
  "pk": 1313,
  "fields": {
    "name": "and_or_not"
  }
},
{
  "model": "cards.tag",
  "pk": 1314,
  "fields": {
    "name": "smtplib"
  }
},
{
  "model": "cards.tag",
  "pk": 1315,
  "fields": {
    "name": "гвидо_ван_россум"
  }
},
{
  "model": "cards.tag",
  "pk": 1316,
  "fields": {
    "name": "check"
  }
},
{
  "model": "cards.tag",
  "pk": 1317,
  "fields": {
    "name": "py_compile"
  }
},
{
  "model": "cards.tag",
  "pk": 1318,
  "fields": {
    "name": "metaclass"
  }
},
{
  "model": "cards.tag",
  "pk": 1319,
  "fields": {
    "name": "минимизация_отключений"
  }
},
{
  "model": "cards.tag",
  "pk": 1320,
  "fields": {
    "name": "подводные_камни"
  }
},
{
  "model": "cards.tag",
  "pk": 1321,
  "fields": {
    "name": "слайс"
  }
},
{
  "model": "cards.tag",
  "pk": 1322,
  "fields": {
    "name": "type"
  }
},
{
  "model": "cards.tag",
  "pk": 1323,
  "fields": {
    "name": "экземпляр_класса"
  }
},
{
  "model": "cards.tag",
  "pk": 1324,
  "fields": {
    "name": "py2exe"
  }
},
{
  "model": "cards.tag",
  "pk": 1325,
  "fields": {
    "name": "искусственный_интеллект"
  }
},
{
  "model": "cards.tag",
  "pk": 1326,
  "fields": {
    "name": "мониторинг"
  }
},
{
  "model": "cards.tag",
  "pk": 1327,
  "fields": {
    "name": "семантическое_версионирование"
  }
},
{
  "model": "cards.tag",
  "pk": 1328,
  "fields": {
    "name": "string"
  }
},
{
  "model": "cards.tag",
  "pk": 1329,
  "fields": {
    "name": "управление_серверами"
  }
},
{
  "model": "cards.tag",
  "pk": 1330,
  "fields": {
    "name": "работа_со_списками"
  }
},
{
  "model": "cards.tag",
  "pk": 1331,
  "fields": {
    "name": "выражения_генераторы"
  }
},
{
  "model": "cards.tag",
  "pk": 1332,
  "fields": {
    "name": "настольные_приложения"
  }
},
{
  "model": "cards.tag",
  "pk": 1333,
  "fields": {
    "name": "лексический_анализ"
  }
},
{
  "model": "cards.tag",
  "pk": 1334,
  "fields": {
    "name": "lambda_функции"
  }
},
{
  "model": "cards.tag",
  "pk": 1335,
  "fields": {
    "name": "init.py"
  }
},
{
  "model": "cards.tag",
  "pk": 1336,
  "fields": {
    "name": "python_форматы_сериализации"
  }
},
{
  "model": "cards.tag",
  "pk": 1337,
  "fields": {
    "name": "генератор"
  }
},
{
  "model": "cards.tag",
  "pk": 1338,
  "fields": {
    "name": "tensorflow"
  }
},
{
  "model": "cards.tag",
  "pk": 1339,
  "fields": {
    "name": "встроенное_пространство_имён"
  }
},
{
  "model": "cards.tag",
  "pk": 1340,
  "fields": {
    "name": "dir"
  }
},
{
  "model": "cards.tag",
  "pk": 1341,
  "fields": {
    "name": "slice"
  }
},
{
  "model": "cards.tag",
  "pk": 1342,
  "fields": {
    "name": "append"
  }
},
{
  "model": "cards.tag",
  "pk": 1343,
  "fields": {
    "name": "git"
  }
},
{
  "model": "cards.tag",
  "pk": 1344,
  "fields": {
    "name": "возврат_значений"
  }
},
{
  "model": "cards.tag",
  "pk": 1345,
  "fields": {
    "name": "изменяемые_типы"
  }
},
{
  "model": "cards.tag",
  "pk": 1346,
  "fields": {
    "name": "ключевые_аргументы"
  }
},
{
  "model": "cards.tag",
  "pk": 1347,
  "fields": {
    "name": "структура_кода"
  }
},
{
  "model": "cards.tag",
  "pk": 1348,
  "fields": {
    "name": "пустой_массив"
  }
},
{
  "model": "cards.tag",
  "pk": 1349,
  "fields": {
    "name": "ошибки_времени_выполнения"
  }
},
{
  "model": "cards.tag",
  "pk": 1350,
  "fields": {
    "name": "avro"
  }
},
{
  "model": "cards.tag",
  "pk": 1351,
  "fields": {
    "name": "найменованные_пространства_имён"
  }
},
{
  "model": "cards.tag",
  "pk": 1352,
  "fields": {
    "name": "finally"
  }
},
{
  "model": "cards.tag",
  "pk": 1353,
  "fields": {
    "name": "debug_mode"
  }
},
{
  "model": "cards.tag",
  "pk": 1354,
  "fields": {
    "name": "агрегатные_значения"
  }
},
{
  "model": "cards.tag",
  "pk": 1355,
  "fields": {
    "name": "высшие_функции"
  }
},
{
  "model": "cards.tag",
  "pk": 1356,
  "fields": {
    "name": "объектно_ориентированное_программирование"
  }
},
{
  "model": "cards.tag",
  "pk": 1357,
  "fields": {
    "name": "strip"
  }
},
{
  "model": "cards.tag",
  "pk": 1358,
  "fields": {
    "name": "глобальный_интерпретатор"
  }
},
{
  "model": "cards.tag",
  "pk": 1359,
  "fields": {
    "name": "for"
  }
},
{
  "model": "cards.tag",
  "pk": 1360,
  "fields": {
    "name": "major_minor_patch"
  }
},
{
  "model": "cards.tag",
  "pk": 1361,
  "fields": {
    "name": "без_class"
  }
},
{
  "model": "cards.tag",
  "pk": 1362,
  "fields": {
    "name": "перебор_последовательности"
  }
},
{
  "model": "cards.tag",
  "pk": 1363,
  "fields": {
    "name": "обработка_строк"
  }
},
{
  "model": "cards.tag",
  "pk": 1364,
  "fields": {
    "name": "уникальный_идентификатор"
  }
},
{
  "model": "cards.tag",
  "pk": 1365,
  "fields": {
    "name": "выборка_данных"
  }
},
{
  "model": "cards.tag",
  "pk": 1366,
  "fields": {
    "name": "immutable_vs_mutable"
  }
},
{
  "model": "cards.tag",
  "pk": 1367,
  "fields": {
    "name": "автоматическое_освобождение_памяти"
  }
},
{
  "model": "cards.tag",
  "pk": 1368,
  "fields": {
    "name": "pycodestyle"
  }
},
{
  "model": "cards.tag",
  "pk": 1369,
  "fields": {
    "name": "блок_try"
  }
},
{
  "model": "cards.tag",
  "pk": 1370,
  "fields": {
    "name": "python_modules"
  }
},
{
  "model": "cards.tag",
  "pk": 1371,
  "fields": {
    "name": "электронная_почта"
  }
},
{
  "model": "cards.tag",
  "pk": 1372,
  "fields": {
    "name": "in"
  }
},
{
  "model": "cards.tag",
  "pk": 1373,
  "fields": {
    "name": "deepcopy"
  }
},
{
  "model": "cards.tag",
  "pk": 1374,
  "fields": {
    "name": "сравнение_строк"
  }
},
{
  "model": "cards.tag",
  "pk": 1375,
  "fields": {
    "name": "locate"
  }
},
{
  "model": "cards.tag",
  "pk": 1376,
  "fields": {
    "name": "docstring"
  }
},
{
  "model": "cards.tag",
  "pk": 1377,
  "fields": {
    "name": "stopiteration"
  }
},
{
  "model": "cards.tag",
  "pk": 1378,
  "fields": {
    "name": "upper"
  }
},
{
  "model": "cards.tag",
  "pk": 1379,
  "fields": {
    "name": "cwi"
  }
},
{
  "model": "cards.tag",
  "pk": 1380,
  "fields": {
    "name": "дистрибуция_пакетов"
  }
},
{
  "model": "cards.tag",
  "pk": 1381,
  "fields": {
    "name": "trio"
  }
},
{
  "model": "cards.tag",
  "pk": 1382,
  "fields": {
    "name": "запуск_внешних_программ"
  }
},
{
  "model": "cards.tag",
  "pk": 1383,
  "fields": {
    "name": "интерпретатор_python"
  }
},
{
  "model": "cards.tag",
  "pk": 1384,
  "fields": {
    "name": "история_python"
  }
},
{
  "model": "cards.tag",
  "pk": 1385,
  "fields": {
    "name": "последовательность"
  }
},
{
  "model": "cards.tag",
  "pk": 1386,
  "fields": {
    "name": "python_окружение"
  }
},
{
  "model": "cards.tag",
  "pk": 1387,
  "fields": {
    "name": "frozenset"
  }
},
{
  "model": "cards.tag",
  "pk": 1388,
  "fields": {
    "name": "функциональность"
  }
},
{
  "model": "cards.tag",
  "pk": 1389,
  "fields": {
    "name": "анализ_запросов"
  }
},
{
  "model": "cards.tag",
  "pk": 1390,
  "fields": {
    "name": "pythonstartup"
  }
},
{
  "model": "cards.tag",
  "pk": 1391,
  "fields": {
    "name": "альтернативы"
  }
},
{
  "model": "cards.tag",
  "pk": 1392,
  "fields": {
    "name": "тестирование_кода"
  }
},
{
  "model": "cards.tag",
  "pk": 1393,
  "fields": {
    "name": "ленивое_вычисление"
  }
},
{
  "model": "cards.tag",
  "pk": 1394,
  "fields": {
    "name": "платформа"
  }
},
{
  "model": "cards.tag",
  "pk": 1395,
  "fields": {
    "name": "переменные"
  }
},
{
  "model": "cards.tag",
  "pk": 1396,
  "fields": {
    "name": "conda"
  }
},
{
  "model": "cards.tag",
  "pk": 1397,
  "fields": {
    "name": "шаблоны"
  }
},
{
  "model": "cards.tag",
  "pk": 1398,
  "fields": {
    "name": "beautiful_soup"
  }
},
{
  "model": "cards.tag",
  "pk": 1399,
  "fields": {
    "name": "поиск_pid"
  }
},
{
  "model": "cards.tag",
  "pk": 1400,
  "fields": {
    "name": "создание_классов"
  }
},
{
  "model": "cards.cardtag",
  "pk": 1,
  "fields": {
    "card": 1,
    "tag": 249
  }
},
{
  "model": "cards.cardtag",
  "pk": 2,
  "fields": {
    "card": 1,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 3,
  "fields": {
    "card": 1,
    "tag": 939
  }
},
{
  "model": "cards.cardtag",
  "pk": 4,
  "fields": {
    "card": 1,
    "tag": 578
  }
},
{
  "model": "cards.cardtag",
  "pk": 5,
  "fields": {
    "card": 2,
    "tag": 213
  }
},
{
  "model": "cards.cardtag",
  "pk": 6,
  "fields": {
    "card": 2,
    "tag": 1176
  }
},
{
  "model": "cards.cardtag",
  "pk": 7,
  "fields": {
    "card": 2,
    "tag": 973
  }
},
{
  "model": "cards.cardtag",
  "pk": 8,
  "fields": {
    "card": 2,
    "tag": 519
  }
},
{
  "model": "cards.cardtag",
  "pk": 9,
  "fields": {
    "card": 3,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 10,
  "fields": {
    "card": 3,
    "tag": 213
  }
},
{
  "model": "cards.cardtag",
  "pk": 11,
  "fields": {
    "card": 3,
    "tag": 612
  }
},
{
  "model": "cards.cardtag",
  "pk": 12,
  "fields": {
    "card": 3,
    "tag": 560
  }
},
{
  "model": "cards.cardtag",
  "pk": 13,
  "fields": {
    "card": 3,
    "tag": 1315
  }
},
{
  "model": "cards.cardtag",
  "pk": 14,
  "fields": {
    "card": 3,
    "tag": 1202
  }
},
{
  "model": "cards.cardtag",
  "pk": 15,
  "fields": {
    "card": 3,
    "tag": 356
  }
},
{
  "model": "cards.cardtag",
  "pk": 16,
  "fields": {
    "card": 4,
    "tag": 1384
  }
},
{
  "model": "cards.cardtag",
  "pk": 17,
  "fields": {
    "card": 4,
    "tag": 1315
  }
},
{
  "model": "cards.cardtag",
  "pk": 18,
  "fields": {
    "card": 4,
    "tag": 600
  }
},
{
  "model": "cards.cardtag",
  "pk": 19,
  "fields": {
    "card": 4,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 20,
  "fields": {
    "card": 4,
    "tag": 1091
  }
},
{
  "model": "cards.cardtag",
  "pk": 21,
  "fields": {
    "card": 5,
    "tag": 1293
  }
},
{
  "model": "cards.cardtag",
  "pk": 22,
  "fields": {
    "card": 5,
    "tag": 436
  }
},
{
  "model": "cards.cardtag",
  "pk": 23,
  "fields": {
    "card": 5,
    "tag": 1188
  }
},
{
  "model": "cards.cardtag",
  "pk": 24,
  "fields": {
    "card": 5,
    "tag": 712
  }
},
{
  "model": "cards.cardtag",
  "pk": 25,
  "fields": {
    "card": 5,
    "tag": 1062
  }
},
{
  "model": "cards.cardtag",
  "pk": 26,
  "fields": {
    "card": 5,
    "tag": 897
  }
},
{
  "model": "cards.cardtag",
  "pk": 27,
  "fields": {
    "card": 5,
    "tag": 1101
  }
},
{
  "model": "cards.cardtag",
  "pk": 28,
  "fields": {
    "card": 5,
    "tag": 331
  }
},
{
  "model": "cards.cardtag",
  "pk": 29,
  "fields": {
    "card": 5,
    "tag": 199
  }
},
{
  "model": "cards.cardtag",
  "pk": 30,
  "fields": {
    "card": 5,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 31,
  "fields": {
    "card": 6,
    "tag": 378
  }
},
{
  "model": "cards.cardtag",
  "pk": 32,
  "fields": {
    "card": 6,
    "tag": 149
  }
},
{
  "model": "cards.cardtag",
  "pk": 33,
  "fields": {
    "card": 6,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 34,
  "fields": {
    "card": 6,
    "tag": 1286
  }
},
{
  "model": "cards.cardtag",
  "pk": 35,
  "fields": {
    "card": 6,
    "tag": 1312
  }
},
{
  "model": "cards.cardtag",
  "pk": 36,
  "fields": {
    "card": 6,
    "tag": 766
  }
},
{
  "model": "cards.cardtag",
  "pk": 37,
  "fields": {
    "card": 7,
    "tag": 914
  }
},
{
  "model": "cards.cardtag",
  "pk": 38,
  "fields": {
    "card": 7,
    "tag": 146
  }
},
{
  "model": "cards.cardtag",
  "pk": 39,
  "fields": {
    "card": 7,
    "tag": 995
  }
},
{
  "model": "cards.cardtag",
  "pk": 40,
  "fields": {
    "card": 7,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 41,
  "fields": {
    "card": 7,
    "tag": 128
  }
},
{
  "model": "cards.cardtag",
  "pk": 42,
  "fields": {
    "card": 7,
    "tag": 500
  }
},
{
  "model": "cards.cardtag",
  "pk": 43,
  "fields": {
    "card": 8,
    "tag": 681
  }
},
{
  "model": "cards.cardtag",
  "pk": 44,
  "fields": {
    "card": 8,
    "tag": 1004
  }
},
{
  "model": "cards.cardtag",
  "pk": 45,
  "fields": {
    "card": 8,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 46,
  "fields": {
    "card": 8,
    "tag": 426
  }
},
{
  "model": "cards.cardtag",
  "pk": 47,
  "fields": {
    "card": 8,
    "tag": 917
  }
},
{
  "model": "cards.cardtag",
  "pk": 48,
  "fields": {
    "card": 8,
    "tag": 629
  }
},
{
  "model": "cards.cardtag",
  "pk": 49,
  "fields": {
    "card": 9,
    "tag": 1376
  }
},
{
  "model": "cards.cardtag",
  "pk": 50,
  "fields": {
    "card": 9,
    "tag": 681
  }
},
{
  "model": "cards.cardtag",
  "pk": 51,
  "fields": {
    "card": 9,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 52,
  "fields": {
    "card": 9,
    "tag": 706
  }
},
{
  "model": "cards.cardtag",
  "pk": 53,
  "fields": {
    "card": 9,
    "tag": 366
  }
},
{
  "model": "cards.cardtag",
  "pk": 54,
  "fields": {
    "card": 9,
    "tag": 799
  }
},
{
  "model": "cards.cardtag",
  "pk": 55,
  "fields": {
    "card": 10,
    "tag": 1293
  }
},
{
  "model": "cards.cardtag",
  "pk": 56,
  "fields": {
    "card": 10,
    "tag": 401
  }
},
{
  "model": "cards.cardtag",
  "pk": 57,
  "fields": {
    "card": 10,
    "tag": 157
  }
},
{
  "model": "cards.cardtag",
  "pk": 58,
  "fields": {
    "card": 10,
    "tag": 474
  }
},
{
  "model": "cards.cardtag",
  "pk": 59,
  "fields": {
    "card": 10,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 60,
  "fields": {
    "card": 10,
    "tag": 1302
  }
},
{
  "model": "cards.cardtag",
  "pk": 61,
  "fields": {
    "card": 11,
    "tag": 204
  }
},
{
  "model": "cards.cardtag",
  "pk": 62,
  "fields": {
    "card": 11,
    "tag": 1310
  }
},
{
  "model": "cards.cardtag",
  "pk": 63,
  "fields": {
    "card": 11,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 64,
  "fields": {
    "card": 11,
    "tag": 1071
  }
},
{
  "model": "cards.cardtag",
  "pk": 65,
  "fields": {
    "card": 11,
    "tag": 800
  }
},
{
  "model": "cards.cardtag",
  "pk": 66,
  "fields": {
    "card": 11,
    "tag": 561
  }
},
{
  "model": "cards.cardtag",
  "pk": 67,
  "fields": {
    "card": 12,
    "tag": 189
  }
},
{
  "model": "cards.cardtag",
  "pk": 68,
  "fields": {
    "card": 12,
    "tag": 620
  }
},
{
  "model": "cards.cardtag",
  "pk": 69,
  "fields": {
    "card": 12,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 70,
  "fields": {
    "card": 12,
    "tag": 377
  }
},
{
  "model": "cards.cardtag",
  "pk": 71,
  "fields": {
    "card": 12,
    "tag": 118
  }
},
{
  "model": "cards.cardtag",
  "pk": 72,
  "fields": {
    "card": 13,
    "tag": 213
  }
},
{
  "model": "cards.cardtag",
  "pk": 73,
  "fields": {
    "card": 13,
    "tag": 535
  }
},
{
  "model": "cards.cardtag",
  "pk": 74,
  "fields": {
    "card": 13,
    "tag": 1273
  }
},
{
  "model": "cards.cardtag",
  "pk": 75,
  "fields": {
    "card": 13,
    "tag": 612
  }
},
{
  "model": "cards.cardtag",
  "pk": 76,
  "fields": {
    "card": 13,
    "tag": 560
  }
},
{
  "model": "cards.cardtag",
  "pk": 77,
  "fields": {
    "card": 13,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 78,
  "fields": {
    "card": 14,
    "tag": 1384
  }
},
{
  "model": "cards.cardtag",
  "pk": 79,
  "fields": {
    "card": 14,
    "tag": 1315
  }
},
{
  "model": "cards.cardtag",
  "pk": 80,
  "fields": {
    "card": 14,
    "tag": 334
  }
},
{
  "model": "cards.cardtag",
  "pk": 81,
  "fields": {
    "card": 14,
    "tag": 943
  }
},
{
  "model": "cards.cardtag",
  "pk": 82,
  "fields": {
    "card": 14,
    "tag": 1189
  }
},
{
  "model": "cards.cardtag",
  "pk": 83,
  "fields": {
    "card": 14,
    "tag": 1379
  }
},
{
  "model": "cards.cardtag",
  "pk": 84,
  "fields": {
    "card": 15,
    "tag": 1293
  }
},
{
  "model": "cards.cardtag",
  "pk": 85,
  "fields": {
    "card": 15,
    "tag": 1188
  }
},
{
  "model": "cards.cardtag",
  "pk": 86,
  "fields": {
    "card": 15,
    "tag": 712
  }
},
{
  "model": "cards.cardtag",
  "pk": 87,
  "fields": {
    "card": 15,
    "tag": 1062
  }
},
{
  "model": "cards.cardtag",
  "pk": 88,
  "fields": {
    "card": 15,
    "tag": 897
  }
},
{
  "model": "cards.cardtag",
  "pk": 89,
  "fields": {
    "card": 15,
    "tag": 1101
  }
},
{
  "model": "cards.cardtag",
  "pk": 90,
  "fields": {
    "card": 15,
    "tag": 331
  }
},
{
  "model": "cards.cardtag",
  "pk": 91,
  "fields": {
    "card": 15,
    "tag": 199
  }
},
{
  "model": "cards.cardtag",
  "pk": 92,
  "fields": {
    "card": 15,
    "tag": 260
  }
},
{
  "model": "cards.cardtag",
  "pk": 93,
  "fields": {
    "card": 16,
    "tag": 378
  }
},
{
  "model": "cards.cardtag",
  "pk": 94,
  "fields": {
    "card": 16,
    "tag": 149
  }
},
{
  "model": "cards.cardtag",
  "pk": 95,
  "fields": {
    "card": 16,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 96,
  "fields": {
    "card": 16,
    "tag": 1286
  }
},
{
  "model": "cards.cardtag",
  "pk": 97,
  "fields": {
    "card": 16,
    "tag": 766
  }
},
{
  "model": "cards.cardtag",
  "pk": 98,
  "fields": {
    "card": 16,
    "tag": 1312
  }
},
{
  "model": "cards.cardtag",
  "pk": 99,
  "fields": {
    "card": 17,
    "tag": 914
  }
},
{
  "model": "cards.cardtag",
  "pk": 100,
  "fields": {
    "card": 17,
    "tag": 146
  }
},
{
  "model": "cards.cardtag",
  "pk": 101,
  "fields": {
    "card": 17,
    "tag": 128
  }
},
{
  "model": "cards.cardtag",
  "pk": 102,
  "fields": {
    "card": 17,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 103,
  "fields": {
    "card": 17,
    "tag": 1265
  }
},
{
  "model": "cards.cardtag",
  "pk": 104,
  "fields": {
    "card": 18,
    "tag": 681
  }
},
{
  "model": "cards.cardtag",
  "pk": 105,
  "fields": {
    "card": 18,
    "tag": 518
  }
},
{
  "model": "cards.cardtag",
  "pk": 106,
  "fields": {
    "card": 18,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 107,
  "fields": {
    "card": 18,
    "tag": 917
  }
},
{
  "model": "cards.cardtag",
  "pk": 108,
  "fields": {
    "card": 18,
    "tag": 629
  }
},
{
  "model": "cards.cardtag",
  "pk": 109,
  "fields": {
    "card": 18,
    "tag": 468
  }
},
{
  "model": "cards.cardtag",
  "pk": 110,
  "fields": {
    "card": 19,
    "tag": 1376
  }
},
{
  "model": "cards.cardtag",
  "pk": 111,
  "fields": {
    "card": 19,
    "tag": 681
  }
},
{
  "model": "cards.cardtag",
  "pk": 112,
  "fields": {
    "card": 19,
    "tag": 223
  }
},
{
  "model": "cards.cardtag",
  "pk": 113,
  "fields": {
    "card": 19,
    "tag": 564
  }
},
{
  "model": "cards.cardtag",
  "pk": 114,
  "fields": {
    "card": 19,
    "tag": 425
  }
},
{
  "model": "cards.cardtag",
  "pk": 115,
  "fields": {
    "card": 19,
    "tag": 433
  }
},
{
  "model": "cards.cardtag",
  "pk": 116,
  "fields": {
    "card": 20,
    "tag": 1293
  }
},
{
  "model": "cards.cardtag",
  "pk": 117,
  "fields": {
    "card": 20,
    "tag": 401
  }
},
{
  "model": "cards.cardtag",
  "pk": 118,
  "fields": {
    "card": 20,
    "tag": 686
  }
},
{
  "model": "cards.cardtag",
  "pk": 119,
  "fields": {
    "card": 20,
    "tag": 182
  }
},
{
  "model": "cards.cardtag",
  "pk": 120,
  "fields": {
    "card": 20,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 121,
  "fields": {
    "card": 20,
    "tag": 1034
  }
},
{
  "model": "cards.cardtag",
  "pk": 122,
  "fields": {
    "card": 20,
    "tag": 555
  }
},
{
  "model": "cards.cardtag",
  "pk": 123,
  "fields": {
    "card": 21,
    "tag": 204
  }
},
{
  "model": "cards.cardtag",
  "pk": 124,
  "fields": {
    "card": 21,
    "tag": 1310
  }
},
{
  "model": "cards.cardtag",
  "pk": 125,
  "fields": {
    "card": 21,
    "tag": 1071
  }
},
{
  "model": "cards.cardtag",
  "pk": 126,
  "fields": {
    "card": 21,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 127,
  "fields": {
    "card": 21,
    "tag": 1062
  }
},
{
  "model": "cards.cardtag",
  "pk": 128,
  "fields": {
    "card": 21,
    "tag": 1045
  }
},
{
  "model": "cards.cardtag",
  "pk": 129,
  "fields": {
    "card": 22,
    "tag": 189
  }
},
{
  "model": "cards.cardtag",
  "pk": 130,
  "fields": {
    "card": 22,
    "tag": 620
  }
},
{
  "model": "cards.cardtag",
  "pk": 131,
  "fields": {
    "card": 22,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 132,
  "fields": {
    "card": 22,
    "tag": 377
  }
},
{
  "model": "cards.cardtag",
  "pk": 133,
  "fields": {
    "card": 22,
    "tag": 219
  }
},
{
  "model": "cards.cardtag",
  "pk": 134,
  "fields": {
    "card": 22,
    "tag": 332
  }
},
{
  "model": "cards.cardtag",
  "pk": 135,
  "fields": {
    "card": 23,
    "tag": 240
  }
},
{
  "model": "cards.cardtag",
  "pk": 136,
  "fields": {
    "card": 23,
    "tag": 284
  }
},
{
  "model": "cards.cardtag",
  "pk": 137,
  "fields": {
    "card": 23,
    "tag": 646
  }
},
{
  "model": "cards.cardtag",
  "pk": 138,
  "fields": {
    "card": 23,
    "tag": 397
  }
},
{
  "model": "cards.cardtag",
  "pk": 139,
  "fields": {
    "card": 23,
    "tag": 291
  }
},
{
  "model": "cards.cardtag",
  "pk": 140,
  "fields": {
    "card": 23,
    "tag": 402
  }
},
{
  "model": "cards.cardtag",
  "pk": 141,
  "fields": {
    "card": 24,
    "tag": 816
  }
},
{
  "model": "cards.cardtag",
  "pk": 142,
  "fields": {
    "card": 24,
    "tag": 518
  }
},
{
  "model": "cards.cardtag",
  "pk": 143,
  "fields": {
    "card": 24,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 144,
  "fields": {
    "card": 24,
    "tag": 1340
  }
},
{
  "model": "cards.cardtag",
  "pk": 145,
  "fields": {
    "card": 24,
    "tag": 1089
  }
},
{
  "model": "cards.cardtag",
  "pk": 146,
  "fields": {
    "card": 24,
    "tag": 1306
  }
},
{
  "model": "cards.cardtag",
  "pk": 147,
  "fields": {
    "card": 25,
    "tag": 1289
  }
},
{
  "model": "cards.cardtag",
  "pk": 148,
  "fields": {
    "card": 25,
    "tag": 192
  }
},
{
  "model": "cards.cardtag",
  "pk": 149,
  "fields": {
    "card": 25,
    "tag": 938
  }
},
{
  "model": "cards.cardtag",
  "pk": 150,
  "fields": {
    "card": 25,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 151,
  "fields": {
    "card": 25,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 152,
  "fields": {
    "card": 25,
    "tag": 523
  }
},
{
  "model": "cards.cardtag",
  "pk": 153,
  "fields": {
    "card": 25,
    "tag": 1007
  }
},
{
  "model": "cards.cardtag",
  "pk": 154,
  "fields": {
    "card": 26,
    "tag": 1356
  }
},
{
  "model": "cards.cardtag",
  "pk": 155,
  "fields": {
    "card": 26,
    "tag": 395
  }
},
{
  "model": "cards.cardtag",
  "pk": 156,
  "fields": {
    "card": 26,
    "tag": 266
  }
},
{
  "model": "cards.cardtag",
  "pk": 157,
  "fields": {
    "card": 26,
    "tag": 904
  }
},
{
  "model": "cards.cardtag",
  "pk": 158,
  "fields": {
    "card": 26,
    "tag": 663
  }
},
{
  "model": "cards.cardtag",
  "pk": 159,
  "fields": {
    "card": 26,
    "tag": 1023
  }
},
{
  "model": "cards.cardtag",
  "pk": 160,
  "fields": {
    "card": 26,
    "tag": 706
  }
},
{
  "model": "cards.cardtag",
  "pk": 161,
  "fields": {
    "card": 27,
    "tag": 468
  }
},
{
  "model": "cards.cardtag",
  "pk": 162,
  "fields": {
    "card": 27,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 163,
  "fields": {
    "card": 27,
    "tag": 144
  }
},
{
  "model": "cards.cardtag",
  "pk": 164,
  "fields": {
    "card": 27,
    "tag": 183
  }
},
{
  "model": "cards.cardtag",
  "pk": 165,
  "fields": {
    "card": 27,
    "tag": 978
  }
},
{
  "model": "cards.cardtag",
  "pk": 166,
  "fields": {
    "card": 27,
    "tag": 551
  }
},
{
  "model": "cards.cardtag",
  "pk": 167,
  "fields": {
    "card": 28,
    "tag": 518
  }
},
{
  "model": "cards.cardtag",
  "pk": 168,
  "fields": {
    "card": 28,
    "tag": 1253
  }
},
{
  "model": "cards.cardtag",
  "pk": 169,
  "fields": {
    "card": 28,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 170,
  "fields": {
    "card": 28,
    "tag": 706
  }
},
{
  "model": "cards.cardtag",
  "pk": 171,
  "fields": {
    "card": 28,
    "tag": 323
  }
},
{
  "model": "cards.cardtag",
  "pk": 172,
  "fields": {
    "card": 28,
    "tag": 1172
  }
},
{
  "model": "cards.cardtag",
  "pk": 173,
  "fields": {
    "card": 29,
    "tag": 667
  }
},
{
  "model": "cards.cardtag",
  "pk": 174,
  "fields": {
    "card": 29,
    "tag": 1317
  }
},
{
  "model": "cards.cardtag",
  "pk": 175,
  "fields": {
    "card": 29,
    "tag": 405
  }
},
{
  "model": "cards.cardtag",
  "pk": 176,
  "fields": {
    "card": 29,
    "tag": 70
  }
},
{
  "model": "cards.cardtag",
  "pk": 177,
  "fields": {
    "card": 29,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 178,
  "fields": {
    "card": 29,
    "tag": 825
  }
},
{
  "model": "cards.cardtag",
  "pk": 179,
  "fields": {
    "card": 30,
    "tag": 992
  }
},
{
  "model": "cards.cardtag",
  "pk": 180,
  "fields": {
    "card": 30,
    "tag": 706
  }
},
{
  "model": "cards.cardtag",
  "pk": 181,
  "fields": {
    "card": 30,
    "tag": 756
  }
},
{
  "model": "cards.cardtag",
  "pk": 182,
  "fields": {
    "card": 30,
    "tag": 1356
  }
},
{
  "model": "cards.cardtag",
  "pk": 183,
  "fields": {
    "card": 30,
    "tag": 1004
  }
},
{
  "model": "cards.cardtag",
  "pk": 184,
  "fields": {
    "card": 30,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 185,
  "fields": {
    "card": 31,
    "tag": 807
  }
},
{
  "model": "cards.cardtag",
  "pk": 186,
  "fields": {
    "card": 31,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 187,
  "fields": {
    "card": 31,
    "tag": 363
  }
},
{
  "model": "cards.cardtag",
  "pk": 188,
  "fields": {
    "card": 31,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 189,
  "fields": {
    "card": 31,
    "tag": 884
  }
},
{
  "model": "cards.cardtag",
  "pk": 190,
  "fields": {
    "card": 31,
    "tag": 219
  }
},
{
  "model": "cards.cardtag",
  "pk": 191,
  "fields": {
    "card": 32,
    "tag": 609
  }
},
{
  "model": "cards.cardtag",
  "pk": 192,
  "fields": {
    "card": 32,
    "tag": 82
  }
},
{
  "model": "cards.cardtag",
  "pk": 193,
  "fields": {
    "card": 32,
    "tag": 1293
  }
},
{
  "model": "cards.cardtag",
  "pk": 194,
  "fields": {
    "card": 32,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 195,
  "fields": {
    "card": 32,
    "tag": 1153
  }
},
{
  "model": "cards.cardtag",
  "pk": 196,
  "fields": {
    "card": 32,
    "tag": 579
  }
},
{
  "model": "cards.cardtag",
  "pk": 197,
  "fields": {
    "card": 33,
    "tag": 53
  }
},
{
  "model": "cards.cardtag",
  "pk": 198,
  "fields": {
    "card": 33,
    "tag": 954
  }
},
{
  "model": "cards.cardtag",
  "pk": 199,
  "fields": {
    "card": 33,
    "tag": 364
  }
},
{
  "model": "cards.cardtag",
  "pk": 200,
  "fields": {
    "card": 33,
    "tag": 827
  }
},
{
  "model": "cards.cardtag",
  "pk": 201,
  "fields": {
    "card": 33,
    "tag": 779
  }
},
{
  "model": "cards.cardtag",
  "pk": 202,
  "fields": {
    "card": 33,
    "tag": 49
  }
},
{
  "model": "cards.cardtag",
  "pk": 203,
  "fields": {
    "card": 34,
    "tag": 422
  }
},
{
  "model": "cards.cardtag",
  "pk": 204,
  "fields": {
    "card": 34,
    "tag": 875
  }
},
{
  "model": "cards.cardtag",
  "pk": 205,
  "fields": {
    "card": 34,
    "tag": 1084
  }
},
{
  "model": "cards.cardtag",
  "pk": 206,
  "fields": {
    "card": 34,
    "tag": 747
  }
},
{
  "model": "cards.cardtag",
  "pk": 207,
  "fields": {
    "card": 34,
    "tag": 1110
  }
},
{
  "model": "cards.cardtag",
  "pk": 208,
  "fields": {
    "card": 34,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 209,
  "fields": {
    "card": 35,
    "tag": 1262
  }
},
{
  "model": "cards.cardtag",
  "pk": 210,
  "fields": {
    "card": 35,
    "tag": 824
  }
},
{
  "model": "cards.cardtag",
  "pk": 211,
  "fields": {
    "card": 35,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 212,
  "fields": {
    "card": 35,
    "tag": 395
  }
},
{
  "model": "cards.cardtag",
  "pk": 213,
  "fields": {
    "card": 35,
    "tag": 1276
  }
},
{
  "model": "cards.cardtag",
  "pk": 214,
  "fields": {
    "card": 35,
    "tag": 992
  }
},
{
  "model": "cards.cardtag",
  "pk": 215,
  "fields": {
    "card": 36,
    "tag": 1321
  }
},
{
  "model": "cards.cardtag",
  "pk": 216,
  "fields": {
    "card": 36,
    "tag": 763
  }
},
{
  "model": "cards.cardtag",
  "pk": 217,
  "fields": {
    "card": 36,
    "tag": 538
  }
},
{
  "model": "cards.cardtag",
  "pk": 218,
  "fields": {
    "card": 36,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 219,
  "fields": {
    "card": 36,
    "tag": 728
  }
},
{
  "model": "cards.cardtag",
  "pk": 220,
  "fields": {
    "card": 36,
    "tag": 1218
  }
},
{
  "model": "cards.cardtag",
  "pk": 221,
  "fields": {
    "card": 37,
    "tag": 427
  }
},
{
  "model": "cards.cardtag",
  "pk": 222,
  "fields": {
    "card": 37,
    "tag": 897
  }
},
{
  "model": "cards.cardtag",
  "pk": 223,
  "fields": {
    "card": 37,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 224,
  "fields": {
    "card": 37,
    "tag": 468
  }
},
{
  "model": "cards.cardtag",
  "pk": 225,
  "fields": {
    "card": 37,
    "tag": 84
  }
},
{
  "model": "cards.cardtag",
  "pk": 226,
  "fields": {
    "card": 37,
    "tag": 412
  }
},
{
  "model": "cards.cardtag",
  "pk": 227,
  "fields": {
    "card": 38,
    "tag": 7
  }
},
{
  "model": "cards.cardtag",
  "pk": 228,
  "fields": {
    "card": 38,
    "tag": 1345
  }
},
{
  "model": "cards.cardtag",
  "pk": 229,
  "fields": {
    "card": 38,
    "tag": 300
  }
},
{
  "model": "cards.cardtag",
  "pk": 230,
  "fields": {
    "card": 38,
    "tag": 513
  }
},
{
  "model": "cards.cardtag",
  "pk": 231,
  "fields": {
    "card": 38,
    "tag": 958
  }
},
{
  "model": "cards.cardtag",
  "pk": 232,
  "fields": {
    "card": 38,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 233,
  "fields": {
    "card": 39,
    "tag": 807
  }
},
{
  "model": "cards.cardtag",
  "pk": 234,
  "fields": {
    "card": 39,
    "tag": 819
  }
},
{
  "model": "cards.cardtag",
  "pk": 235,
  "fields": {
    "card": 39,
    "tag": 469
  }
},
{
  "model": "cards.cardtag",
  "pk": 236,
  "fields": {
    "card": 39,
    "tag": 661
  }
},
{
  "model": "cards.cardtag",
  "pk": 237,
  "fields": {
    "card": 39,
    "tag": 424
  }
},
{
  "model": "cards.cardtag",
  "pk": 238,
  "fields": {
    "card": 39,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 239,
  "fields": {
    "card": 40,
    "tag": 657
  }
},
{
  "model": "cards.cardtag",
  "pk": 240,
  "fields": {
    "card": 40,
    "tag": 771
  }
},
{
  "model": "cards.cardtag",
  "pk": 241,
  "fields": {
    "card": 40,
    "tag": 1068
  }
},
{
  "model": "cards.cardtag",
  "pk": 242,
  "fields": {
    "card": 40,
    "tag": 772
  }
},
{
  "model": "cards.cardtag",
  "pk": 243,
  "fields": {
    "card": 40,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 244,
  "fields": {
    "card": 40,
    "tag": 927
  }
},
{
  "model": "cards.cardtag",
  "pk": 245,
  "fields": {
    "card": 40,
    "tag": 764
  }
},
{
  "model": "cards.cardtag",
  "pk": 246,
  "fields": {
    "card": 41,
    "tag": 115
  }
},
{
  "model": "cards.cardtag",
  "pk": 247,
  "fields": {
    "card": 41,
    "tag": 764
  }
},
{
  "model": "cards.cardtag",
  "pk": 248,
  "fields": {
    "card": 41,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 249,
  "fields": {
    "card": 41,
    "tag": 884
  }
},
{
  "model": "cards.cardtag",
  "pk": 250,
  "fields": {
    "card": 41,
    "tag": 1088
  }
},
{
  "model": "cards.cardtag",
  "pk": 251,
  "fields": {
    "card": 41,
    "tag": 1052
  }
},
{
  "model": "cards.cardtag",
  "pk": 252,
  "fields": {
    "card": 42,
    "tag": 682
  }
},
{
  "model": "cards.cardtag",
  "pk": 253,
  "fields": {
    "card": 42,
    "tag": 50
  }
},
{
  "model": "cards.cardtag",
  "pk": 254,
  "fields": {
    "card": 42,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 255,
  "fields": {
    "card": 42,
    "tag": 1147
  }
},
{
  "model": "cards.cardtag",
  "pk": 256,
  "fields": {
    "card": 42,
    "tag": 64
  }
},
{
  "model": "cards.cardtag",
  "pk": 257,
  "fields": {
    "card": 43,
    "tag": 753
  }
},
{
  "model": "cards.cardtag",
  "pk": 258,
  "fields": {
    "card": 43,
    "tag": 1364
  }
},
{
  "model": "cards.cardtag",
  "pk": 259,
  "fields": {
    "card": 43,
    "tag": 126
  }
},
{
  "model": "cards.cardtag",
  "pk": 260,
  "fields": {
    "card": 43,
    "tag": 1290
  }
},
{
  "model": "cards.cardtag",
  "pk": 261,
  "fields": {
    "card": 43,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 262,
  "fields": {
    "card": 44,
    "tag": 718
  }
},
{
  "model": "cards.cardtag",
  "pk": 263,
  "fields": {
    "card": 44,
    "tag": 1337
  }
},
{
  "model": "cards.cardtag",
  "pk": 264,
  "fields": {
    "card": 44,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 265,
  "fields": {
    "card": 44,
    "tag": 486
  }
},
{
  "model": "cards.cardtag",
  "pk": 266,
  "fields": {
    "card": 44,
    "tag": 1377
  }
},
{
  "model": "cards.cardtag",
  "pk": 267,
  "fields": {
    "card": 44,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 268,
  "fields": {
    "card": 45,
    "tag": 1337
  }
},
{
  "model": "cards.cardtag",
  "pk": 269,
  "fields": {
    "card": 45,
    "tag": 718
  }
},
{
  "model": "cards.cardtag",
  "pk": 270,
  "fields": {
    "card": 45,
    "tag": 1183
  }
},
{
  "model": "cards.cardtag",
  "pk": 271,
  "fields": {
    "card": 45,
    "tag": 437
  }
},
{
  "model": "cards.cardtag",
  "pk": 272,
  "fields": {
    "card": 45,
    "tag": 279
  }
},
{
  "model": "cards.cardtag",
  "pk": 273,
  "fields": {
    "card": 45,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 274,
  "fields": {
    "card": 46,
    "tag": 1183
  }
},
{
  "model": "cards.cardtag",
  "pk": 275,
  "fields": {
    "card": 46,
    "tag": 677
  }
},
{
  "model": "cards.cardtag",
  "pk": 276,
  "fields": {
    "card": 46,
    "tag": 437
  }
},
{
  "model": "cards.cardtag",
  "pk": 277,
  "fields": {
    "card": 46,
    "tag": 1079
  }
},
{
  "model": "cards.cardtag",
  "pk": 278,
  "fields": {
    "card": 46,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 279,
  "fields": {
    "card": 46,
    "tag": 1034
  }
},
{
  "model": "cards.cardtag",
  "pk": 280,
  "fields": {
    "card": 46,
    "tag": 376
  }
},
{
  "model": "cards.cardtag",
  "pk": 281,
  "fields": {
    "card": 47,
    "tag": 400
  }
},
{
  "model": "cards.cardtag",
  "pk": 282,
  "fields": {
    "card": 47,
    "tag": 756
  }
},
{
  "model": "cards.cardtag",
  "pk": 283,
  "fields": {
    "card": 47,
    "tag": 743
  }
},
{
  "model": "cards.cardtag",
  "pk": 284,
  "fields": {
    "card": 47,
    "tag": 486
  }
},
{
  "model": "cards.cardtag",
  "pk": 285,
  "fields": {
    "card": 47,
    "tag": 75
  }
},
{
  "model": "cards.cardtag",
  "pk": 286,
  "fields": {
    "card": 47,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 287,
  "fields": {
    "card": 48,
    "tag": 1216
  }
},
{
  "model": "cards.cardtag",
  "pk": 288,
  "fields": {
    "card": 48,
    "tag": 383
  }
},
{
  "model": "cards.cardtag",
  "pk": 289,
  "fields": {
    "card": 48,
    "tag": 1133
  }
},
{
  "model": "cards.cardtag",
  "pk": 290,
  "fields": {
    "card": 48,
    "tag": 761
  }
},
{
  "model": "cards.cardtag",
  "pk": 291,
  "fields": {
    "card": 48,
    "tag": 25
  }
},
{
  "model": "cards.cardtag",
  "pk": 292,
  "fields": {
    "card": 48,
    "tag": 632
  }
},
{
  "model": "cards.cardtag",
  "pk": 293,
  "fields": {
    "card": 48,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 294,
  "fields": {
    "card": 49,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 295,
  "fields": {
    "card": 49,
    "tag": 528
  }
},
{
  "model": "cards.cardtag",
  "pk": 296,
  "fields": {
    "card": 49,
    "tag": 922
  }
},
{
  "model": "cards.cardtag",
  "pk": 297,
  "fields": {
    "card": 49,
    "tag": 749
  }
},
{
  "model": "cards.cardtag",
  "pk": 298,
  "fields": {
    "card": 49,
    "tag": 163
  }
},
{
  "model": "cards.cardtag",
  "pk": 299,
  "fields": {
    "card": 49,
    "tag": 405
  }
},
{
  "model": "cards.cardtag",
  "pk": 300,
  "fields": {
    "card": 50,
    "tag": 161
  }
},
{
  "model": "cards.cardtag",
  "pk": 301,
  "fields": {
    "card": 50,
    "tag": 211
  }
},
{
  "model": "cards.cardtag",
  "pk": 302,
  "fields": {
    "card": 50,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 303,
  "fields": {
    "card": 50,
    "tag": 1299
  }
},
{
  "model": "cards.cardtag",
  "pk": 304,
  "fields": {
    "card": 50,
    "tag": 1373
  }
},
{
  "model": "cards.cardtag",
  "pk": 305,
  "fields": {
    "card": 50,
    "tag": 455
  }
},
{
  "model": "cards.cardtag",
  "pk": 306,
  "fields": {
    "card": 51,
    "tag": 1238
  }
},
{
  "model": "cards.cardtag",
  "pk": 307,
  "fields": {
    "card": 51,
    "tag": 1055
  }
},
{
  "model": "cards.cardtag",
  "pk": 308,
  "fields": {
    "card": 51,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 309,
  "fields": {
    "card": 51,
    "tag": 560
  }
},
{
  "model": "cards.cardtag",
  "pk": 310,
  "fields": {
    "card": 51,
    "tag": 754
  }
},
{
  "model": "cards.cardtag",
  "pk": 311,
  "fields": {
    "card": 51,
    "tag": 319
  }
},
{
  "model": "cards.cardtag",
  "pk": 312,
  "fields": {
    "card": 52,
    "tag": 144
  }
},
{
  "model": "cards.cardtag",
  "pk": 313,
  "fields": {
    "card": 52,
    "tag": 814
  }
},
{
  "model": "cards.cardtag",
  "pk": 314,
  "fields": {
    "card": 52,
    "tag": 801
  }
},
{
  "model": "cards.cardtag",
  "pk": 315,
  "fields": {
    "card": 52,
    "tag": 1395
  }
},
{
  "model": "cards.cardtag",
  "pk": 316,
  "fields": {
    "card": 52,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 317,
  "fields": {
    "card": 52,
    "tag": 183
  }
},
{
  "model": "cards.cardtag",
  "pk": 318,
  "fields": {
    "card": 53,
    "tag": 1057
  }
},
{
  "model": "cards.cardtag",
  "pk": 319,
  "fields": {
    "card": 53,
    "tag": 967
  }
},
{
  "model": "cards.cardtag",
  "pk": 320,
  "fields": {
    "card": 53,
    "tag": 1276
  }
},
{
  "model": "cards.cardtag",
  "pk": 321,
  "fields": {
    "card": 53,
    "tag": 475
  }
},
{
  "model": "cards.cardtag",
  "pk": 322,
  "fields": {
    "card": 53,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 323,
  "fields": {
    "card": 54,
    "tag": 147
  }
},
{
  "model": "cards.cardtag",
  "pk": 324,
  "fields": {
    "card": 54,
    "tag": 831
  }
},
{
  "model": "cards.cardtag",
  "pk": 325,
  "fields": {
    "card": 54,
    "tag": 31
  }
},
{
  "model": "cards.cardtag",
  "pk": 326,
  "fields": {
    "card": 54,
    "tag": 547
  }
},
{
  "model": "cards.cardtag",
  "pk": 327,
  "fields": {
    "card": 54,
    "tag": 544
  }
},
{
  "model": "cards.cardtag",
  "pk": 328,
  "fields": {
    "card": 54,
    "tag": 385
  }
},
{
  "model": "cards.cardtag",
  "pk": 329,
  "fields": {
    "card": 54,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 330,
  "fields": {
    "card": 55,
    "tag": 1055
  }
},
{
  "model": "cards.cardtag",
  "pk": 331,
  "fields": {
    "card": 55,
    "tag": 179
  }
},
{
  "model": "cards.cardtag",
  "pk": 332,
  "fields": {
    "card": 55,
    "tag": 608
  }
},
{
  "model": "cards.cardtag",
  "pk": 333,
  "fields": {
    "card": 55,
    "tag": 236
  }
},
{
  "model": "cards.cardtag",
  "pk": 334,
  "fields": {
    "card": 55,
    "tag": 1257
  }
},
{
  "model": "cards.cardtag",
  "pk": 335,
  "fields": {
    "card": 55,
    "tag": 953
  }
},
{
  "model": "cards.cardtag",
  "pk": 336,
  "fields": {
    "card": 56,
    "tag": 288
  }
},
{
  "model": "cards.cardtag",
  "pk": 337,
  "fields": {
    "card": 56,
    "tag": 103
  }
},
{
  "model": "cards.cardtag",
  "pk": 338,
  "fields": {
    "card": 56,
    "tag": 1400
  }
},
{
  "model": "cards.cardtag",
  "pk": 339,
  "fields": {
    "card": 56,
    "tag": 852
  }
},
{
  "model": "cards.cardtag",
  "pk": 340,
  "fields": {
    "card": 56,
    "tag": 205
  }
},
{
  "model": "cards.cardtag",
  "pk": 341,
  "fields": {
    "card": 56,
    "tag": 837
  }
},
{
  "model": "cards.cardtag",
  "pk": 342,
  "fields": {
    "card": 57,
    "tag": 119
  }
},
{
  "model": "cards.cardtag",
  "pk": 343,
  "fields": {
    "card": 57,
    "tag": 320
  }
},
{
  "model": "cards.cardtag",
  "pk": 344,
  "fields": {
    "card": 57,
    "tag": 348
  }
},
{
  "model": "cards.cardtag",
  "pk": 345,
  "fields": {
    "card": 57,
    "tag": 1070
  }
},
{
  "model": "cards.cardtag",
  "pk": 346,
  "fields": {
    "card": 57,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 347,
  "fields": {
    "card": 57,
    "tag": 601
  }
},
{
  "model": "cards.cardtag",
  "pk": 348,
  "fields": {
    "card": 58,
    "tag": 246
  }
},
{
  "model": "cards.cardtag",
  "pk": 349,
  "fields": {
    "card": 58,
    "tag": 300
  }
},
{
  "model": "cards.cardtag",
  "pk": 350,
  "fields": {
    "card": 58,
    "tag": 538
  }
},
{
  "model": "cards.cardtag",
  "pk": 351,
  "fields": {
    "card": 58,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 352,
  "fields": {
    "card": 58,
    "tag": 1062
  }
},
{
  "model": "cards.cardtag",
  "pk": 353,
  "fields": {
    "card": 58,
    "tag": 1171
  }
},
{
  "model": "cards.cardtag",
  "pk": 354,
  "fields": {
    "card": 59,
    "tag": 1287
  }
},
{
  "model": "cards.cardtag",
  "pk": 355,
  "fields": {
    "card": 59,
    "tag": 1361
  }
},
{
  "model": "cards.cardtag",
  "pk": 356,
  "fields": {
    "card": 59,
    "tag": 1322
  }
},
{
  "model": "cards.cardtag",
  "pk": 357,
  "fields": {
    "card": 59,
    "tag": 1318
  }
},
{
  "model": "cards.cardtag",
  "pk": 358,
  "fields": {
    "card": 59,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 359,
  "fields": {
    "card": 59,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 360,
  "fields": {
    "card": 60,
    "tag": 833
  }
},
{
  "model": "cards.cardtag",
  "pk": 361,
  "fields": {
    "card": 60,
    "tag": 148
  }
},
{
  "model": "cards.cardtag",
  "pk": 362,
  "fields": {
    "card": 60,
    "tag": 1159
  }
},
{
  "model": "cards.cardtag",
  "pk": 363,
  "fields": {
    "card": 60,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 364,
  "fields": {
    "card": 60,
    "tag": 185
  }
},
{
  "model": "cards.cardtag",
  "pk": 365,
  "fields": {
    "card": 60,
    "tag": 1267
  }
},
{
  "model": "cards.cardtag",
  "pk": 366,
  "fields": {
    "card": 61,
    "tag": 807
  }
},
{
  "model": "cards.cardtag",
  "pk": 367,
  "fields": {
    "card": 61,
    "tag": 936
  }
},
{
  "model": "cards.cardtag",
  "pk": 368,
  "fields": {
    "card": 61,
    "tag": 419
  }
},
{
  "model": "cards.cardtag",
  "pk": 369,
  "fields": {
    "card": 61,
    "tag": 1266
  }
},
{
  "model": "cards.cardtag",
  "pk": 370,
  "fields": {
    "card": 61,
    "tag": 817
  }
},
{
  "model": "cards.cardtag",
  "pk": 371,
  "fields": {
    "card": 61,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 372,
  "fields": {
    "card": 62,
    "tag": 412
  }
},
{
  "model": "cards.cardtag",
  "pk": 373,
  "fields": {
    "card": 62,
    "tag": 712
  }
},
{
  "model": "cards.cardtag",
  "pk": 374,
  "fields": {
    "card": 62,
    "tag": 1062
  }
},
{
  "model": "cards.cardtag",
  "pk": 375,
  "fields": {
    "card": 62,
    "tag": 766
  }
},
{
  "model": "cards.cardtag",
  "pk": 376,
  "fields": {
    "card": 62,
    "tag": 52
  }
},
{
  "model": "cards.cardtag",
  "pk": 377,
  "fields": {
    "card": 62,
    "tag": 894
  }
},
{
  "model": "cards.cardtag",
  "pk": 378,
  "fields": {
    "card": 62,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 379,
  "fields": {
    "card": 63,
    "tag": 752
  }
},
{
  "model": "cards.cardtag",
  "pk": 380,
  "fields": {
    "card": 63,
    "tag": 219
  }
},
{
  "model": "cards.cardtag",
  "pk": 381,
  "fields": {
    "card": 63,
    "tag": 495
  }
},
{
  "model": "cards.cardtag",
  "pk": 382,
  "fields": {
    "card": 63,
    "tag": 1102
  }
},
{
  "model": "cards.cardtag",
  "pk": 383,
  "fields": {
    "card": 63,
    "tag": 325
  }
},
{
  "model": "cards.cardtag",
  "pk": 384,
  "fields": {
    "card": 63,
    "tag": 1325
  }
},
{
  "model": "cards.cardtag",
  "pk": 385,
  "fields": {
    "card": 63,
    "tag": 306
  }
},
{
  "model": "cards.cardtag",
  "pk": 386,
  "fields": {
    "card": 63,
    "tag": 380
  }
},
{
  "model": "cards.cardtag",
  "pk": 387,
  "fields": {
    "card": 64,
    "tag": 16
  }
},
{
  "model": "cards.cardtag",
  "pk": 388,
  "fields": {
    "card": 64,
    "tag": 603
  }
},
{
  "model": "cards.cardtag",
  "pk": 389,
  "fields": {
    "card": 64,
    "tag": 999
  }
},
{
  "model": "cards.cardtag",
  "pk": 390,
  "fields": {
    "card": 64,
    "tag": 135
  }
},
{
  "model": "cards.cardtag",
  "pk": 391,
  "fields": {
    "card": 64,
    "tag": 772
  }
},
{
  "model": "cards.cardtag",
  "pk": 392,
  "fields": {
    "card": 64,
    "tag": 612
  }
},
{
  "model": "cards.cardtag",
  "pk": 393,
  "fields": {
    "card": 64,
    "tag": 1055
  }
},
{
  "model": "cards.cardtag",
  "pk": 394,
  "fields": {
    "card": 65,
    "tag": 1266
  }
},
{
  "model": "cards.cardtag",
  "pk": 395,
  "fields": {
    "card": 65,
    "tag": 466
  }
},
{
  "model": "cards.cardtag",
  "pk": 396,
  "fields": {
    "card": 65,
    "tag": 1190
  }
},
{
  "model": "cards.cardtag",
  "pk": 397,
  "fields": {
    "card": 65,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 398,
  "fields": {
    "card": 65,
    "tag": 283
  }
},
{
  "model": "cards.cardtag",
  "pk": 399,
  "fields": {
    "card": 65,
    "tag": 28
  }
},
{
  "model": "cards.cardtag",
  "pk": 400,
  "fields": {
    "card": 66,
    "tag": 1023
  }
},
{
  "model": "cards.cardtag",
  "pk": 401,
  "fields": {
    "card": 66,
    "tag": 706
  }
},
{
  "model": "cards.cardtag",
  "pk": 402,
  "fields": {
    "card": 66,
    "tag": 266
  }
},
{
  "model": "cards.cardtag",
  "pk": 403,
  "fields": {
    "card": 66,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 404,
  "fields": {
    "card": 66,
    "tag": 1356
  }
},
{
  "model": "cards.cardtag",
  "pk": 405,
  "fields": {
    "card": 66,
    "tag": 395
  }
},
{
  "model": "cards.cardtag",
  "pk": 406,
  "fields": {
    "card": 67,
    "tag": 1170
  }
},
{
  "model": "cards.cardtag",
  "pk": 407,
  "fields": {
    "card": 67,
    "tag": 491
  }
},
{
  "model": "cards.cardtag",
  "pk": 408,
  "fields": {
    "card": 67,
    "tag": 267
  }
},
{
  "model": "cards.cardtag",
  "pk": 409,
  "fields": {
    "card": 67,
    "tag": 736
  }
},
{
  "model": "cards.cardtag",
  "pk": 410,
  "fields": {
    "card": 67,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 411,
  "fields": {
    "card": 67,
    "tag": 613
  }
},
{
  "model": "cards.cardtag",
  "pk": 412,
  "fields": {
    "card": 68,
    "tag": 693
  }
},
{
  "model": "cards.cardtag",
  "pk": 413,
  "fields": {
    "card": 68,
    "tag": 266
  }
},
{
  "model": "cards.cardtag",
  "pk": 414,
  "fields": {
    "card": 68,
    "tag": 628
  }
},
{
  "model": "cards.cardtag",
  "pk": 415,
  "fields": {
    "card": 68,
    "tag": 706
  }
},
{
  "model": "cards.cardtag",
  "pk": 416,
  "fields": {
    "card": 68,
    "tag": 1129
  }
},
{
  "model": "cards.cardtag",
  "pk": 417,
  "fields": {
    "card": 68,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 418,
  "fields": {
    "card": 69,
    "tag": 1241
  }
},
{
  "model": "cards.cardtag",
  "pk": 419,
  "fields": {
    "card": 69,
    "tag": 919
  }
},
{
  "model": "cards.cardtag",
  "pk": 420,
  "fields": {
    "card": 69,
    "tag": 1345
  }
},
{
  "model": "cards.cardtag",
  "pk": 421,
  "fields": {
    "card": 69,
    "tag": 202
  }
},
{
  "model": "cards.cardtag",
  "pk": 422,
  "fields": {
    "card": 69,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 423,
  "fields": {
    "card": 69,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 424,
  "fields": {
    "card": 70,
    "tag": 254
  }
},
{
  "model": "cards.cardtag",
  "pk": 425,
  "fields": {
    "card": 70,
    "tag": 17
  }
},
{
  "model": "cards.cardtag",
  "pk": 426,
  "fields": {
    "card": 70,
    "tag": 812
  }
},
{
  "model": "cards.cardtag",
  "pk": 427,
  "fields": {
    "card": 70,
    "tag": 94
  }
},
{
  "model": "cards.cardtag",
  "pk": 428,
  "fields": {
    "card": 70,
    "tag": 843
  }
},
{
  "model": "cards.cardtag",
  "pk": 429,
  "fields": {
    "card": 70,
    "tag": 299
  }
},
{
  "model": "cards.cardtag",
  "pk": 430,
  "fields": {
    "card": 70,
    "tag": 1368
  }
},
{
  "model": "cards.cardtag",
  "pk": 431,
  "fields": {
    "card": 70,
    "tag": 303
  }
},
{
  "model": "cards.cardtag",
  "pk": 432,
  "fields": {
    "card": 70,
    "tag": 585
  }
},
{
  "model": "cards.cardtag",
  "pk": 433,
  "fields": {
    "card": 70,
    "tag": 532
  }
},
{
  "model": "cards.cardtag",
  "pk": 434,
  "fields": {
    "card": 70,
    "tag": 758
  }
},
{
  "model": "cards.cardtag",
  "pk": 435,
  "fields": {
    "card": 70,
    "tag": 74
  }
},
{
  "model": "cards.cardtag",
  "pk": 436,
  "fields": {
    "card": 71,
    "tag": 861
  }
},
{
  "model": "cards.cardtag",
  "pk": 437,
  "fields": {
    "card": 71,
    "tag": 979
  }
},
{
  "model": "cards.cardtag",
  "pk": 438,
  "fields": {
    "card": 71,
    "tag": 1062
  }
},
{
  "model": "cards.cardtag",
  "pk": 439,
  "fields": {
    "card": 71,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 440,
  "fields": {
    "card": 72,
    "tag": 441
  }
},
{
  "model": "cards.cardtag",
  "pk": 441,
  "fields": {
    "card": 72,
    "tag": 98
  }
},
{
  "model": "cards.cardtag",
  "pk": 442,
  "fields": {
    "card": 72,
    "tag": 240
  }
},
{
  "model": "cards.cardtag",
  "pk": 443,
  "fields": {
    "card": 72,
    "tag": 4
  }
},
{
  "model": "cards.cardtag",
  "pk": 444,
  "fields": {
    "card": 72,
    "tag": 772
  }
},
{
  "model": "cards.cardtag",
  "pk": 445,
  "fields": {
    "card": 72,
    "tag": 115
  }
},
{
  "model": "cards.cardtag",
  "pk": 446,
  "fields": {
    "card": 73,
    "tag": 1185
  }
},
{
  "model": "cards.cardtag",
  "pk": 447,
  "fields": {
    "card": 73,
    "tag": 845
  }
},
{
  "model": "cards.cardtag",
  "pk": 448,
  "fields": {
    "card": 73,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 449,
  "fields": {
    "card": 73,
    "tag": 1174
  }
},
{
  "model": "cards.cardtag",
  "pk": 450,
  "fields": {
    "card": 73,
    "tag": 1284
  }
},
{
  "model": "cards.cardtag",
  "pk": 451,
  "fields": {
    "card": 73,
    "tag": 886
  }
},
{
  "model": "cards.cardtag",
  "pk": 452,
  "fields": {
    "card": 74,
    "tag": 1275
  }
},
{
  "model": "cards.cardtag",
  "pk": 453,
  "fields": {
    "card": 74,
    "tag": 496
  }
},
{
  "model": "cards.cardtag",
  "pk": 454,
  "fields": {
    "card": 74,
    "tag": 1343
  }
},
{
  "model": "cards.cardtag",
  "pk": 455,
  "fields": {
    "card": 74,
    "tag": 783
  }
},
{
  "model": "cards.cardtag",
  "pk": 456,
  "fields": {
    "card": 74,
    "tag": 528
  }
},
{
  "model": "cards.cardtag",
  "pk": 457,
  "fields": {
    "card": 74,
    "tag": 432
  }
},
{
  "model": "cards.cardtag",
  "pk": 458,
  "fields": {
    "card": 74,
    "tag": 1288
  }
},
{
  "model": "cards.cardtag",
  "pk": 459,
  "fields": {
    "card": 75,
    "tag": 244
  }
},
{
  "model": "cards.cardtag",
  "pk": 460,
  "fields": {
    "card": 75,
    "tag": 807
  }
},
{
  "model": "cards.cardtag",
  "pk": 461,
  "fields": {
    "card": 75,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 462,
  "fields": {
    "card": 75,
    "tag": 719
  }
},
{
  "model": "cards.cardtag",
  "pk": 463,
  "fields": {
    "card": 75,
    "tag": 1009
  }
},
{
  "model": "cards.cardtag",
  "pk": 464,
  "fields": {
    "card": 75,
    "tag": 661
  }
},
{
  "model": "cards.cardtag",
  "pk": 465,
  "fields": {
    "card": 76,
    "tag": 1055
  }
},
{
  "model": "cards.cardtag",
  "pk": 466,
  "fields": {
    "card": 76,
    "tag": 179
  }
},
{
  "model": "cards.cardtag",
  "pk": 467,
  "fields": {
    "card": 76,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 468,
  "fields": {
    "card": 76,
    "tag": 557
  }
},
{
  "model": "cards.cardtag",
  "pk": 469,
  "fields": {
    "card": 76,
    "tag": 63
  }
},
{
  "model": "cards.cardtag",
  "pk": 470,
  "fields": {
    "card": 76,
    "tag": 1057
  }
},
{
  "model": "cards.cardtag",
  "pk": 471,
  "fields": {
    "card": 77,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 472,
  "fields": {
    "card": 77,
    "tag": 706
  }
},
{
  "model": "cards.cardtag",
  "pk": 473,
  "fields": {
    "card": 77,
    "tag": 1304
  }
},
{
  "model": "cards.cardtag",
  "pk": 474,
  "fields": {
    "card": 77,
    "tag": 29
  }
},
{
  "model": "cards.cardtag",
  "pk": 475,
  "fields": {
    "card": 77,
    "tag": 807
  }
},
{
  "model": "cards.cardtag",
  "pk": 476,
  "fields": {
    "card": 77,
    "tag": 661
  }
},
{
  "model": "cards.cardtag",
  "pk": 477,
  "fields": {
    "card": 78,
    "tag": 87
  }
},
{
  "model": "cards.cardtag",
  "pk": 478,
  "fields": {
    "card": 78,
    "tag": 498
  }
},
{
  "model": "cards.cardtag",
  "pk": 479,
  "fields": {
    "card": 78,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 480,
  "fields": {
    "card": 78,
    "tag": 1374
  }
},
{
  "model": "cards.cardtag",
  "pk": 481,
  "fields": {
    "card": 78,
    "tag": 772
  }
},
{
  "model": "cards.cardtag",
  "pk": 482,
  "fields": {
    "card": 78,
    "tag": 485
  }
},
{
  "model": "cards.cardtag",
  "pk": 483,
  "fields": {
    "card": 79,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 484,
  "fields": {
    "card": 79,
    "tag": 1163
  }
},
{
  "model": "cards.cardtag",
  "pk": 485,
  "fields": {
    "card": 79,
    "tag": 725
  }
},
{
  "model": "cards.cardtag",
  "pk": 486,
  "fields": {
    "card": 79,
    "tag": 829
  }
},
{
  "model": "cards.cardtag",
  "pk": 487,
  "fields": {
    "card": 79,
    "tag": 1396
  }
},
{
  "model": "cards.cardtag",
  "pk": 488,
  "fields": {
    "card": 79,
    "tag": 224
  }
},
{
  "model": "cards.cardtag",
  "pk": 489,
  "fields": {
    "card": 79,
    "tag": 1231
  }
},
{
  "model": "cards.cardtag",
  "pk": 490,
  "fields": {
    "card": 80,
    "tag": 1132
  }
},
{
  "model": "cards.cardtag",
  "pk": 491,
  "fields": {
    "card": 80,
    "tag": 1057
  }
},
{
  "model": "cards.cardtag",
  "pk": 492,
  "fields": {
    "card": 80,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 493,
  "fields": {
    "card": 80,
    "tag": 392
  }
},
{
  "model": "cards.cardtag",
  "pk": 494,
  "fields": {
    "card": 80,
    "tag": 90
  }
},
{
  "model": "cards.cardtag",
  "pk": 495,
  "fields": {
    "card": 80,
    "tag": 588
  }
},
{
  "model": "cards.cardtag",
  "pk": 496,
  "fields": {
    "card": 81,
    "tag": 1301
  }
},
{
  "model": "cards.cardtag",
  "pk": 497,
  "fields": {
    "card": 81,
    "tag": 596
  }
},
{
  "model": "cards.cardtag",
  "pk": 498,
  "fields": {
    "card": 81,
    "tag": 379
  }
},
{
  "model": "cards.cardtag",
  "pk": 499,
  "fields": {
    "card": 81,
    "tag": 829
  }
},
{
  "model": "cards.cardtag",
  "pk": 500,
  "fields": {
    "card": 81,
    "tag": 1380
  }
},
{
  "model": "cards.cardtag",
  "pk": 501,
  "fields": {
    "card": 81,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 502,
  "fields": {
    "card": 82,
    "tag": 1117
  }
},
{
  "model": "cards.cardtag",
  "pk": 503,
  "fields": {
    "card": 82,
    "tag": 76
  }
},
{
  "model": "cards.cardtag",
  "pk": 504,
  "fields": {
    "card": 82,
    "tag": 1239
  }
},
{
  "model": "cards.cardtag",
  "pk": 505,
  "fields": {
    "card": 82,
    "tag": 1011
  }
},
{
  "model": "cards.cardtag",
  "pk": 506,
  "fields": {
    "card": 82,
    "tag": 127
  }
},
{
  "model": "cards.cardtag",
  "pk": 507,
  "fields": {
    "card": 82,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 508,
  "fields": {
    "card": 83,
    "tag": 627
  }
},
{
  "model": "cards.cardtag",
  "pk": 509,
  "fields": {
    "card": 83,
    "tag": 607
  }
},
{
  "model": "cards.cardtag",
  "pk": 510,
  "fields": {
    "card": 83,
    "tag": 1302
  }
},
{
  "model": "cards.cardtag",
  "pk": 511,
  "fields": {
    "card": 83,
    "tag": 1174
  }
},
{
  "model": "cards.cardtag",
  "pk": 512,
  "fields": {
    "card": 83,
    "tag": 240
  }
},
{
  "model": "cards.cardtag",
  "pk": 513,
  "fields": {
    "card": 83,
    "tag": 559
  }
},
{
  "model": "cards.cardtag",
  "pk": 514,
  "fields": {
    "card": 83,
    "tag": 1057
  }
},
{
  "model": "cards.cardtag",
  "pk": 515,
  "fields": {
    "card": 84,
    "tag": 1284
  }
},
{
  "model": "cards.cardtag",
  "pk": 516,
  "fields": {
    "card": 84,
    "tag": 845
  }
},
{
  "model": "cards.cardtag",
  "pk": 517,
  "fields": {
    "card": 84,
    "tag": 1174
  }
},
{
  "model": "cards.cardtag",
  "pk": 518,
  "fields": {
    "card": 84,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 519,
  "fields": {
    "card": 84,
    "tag": 143
  }
},
{
  "model": "cards.cardtag",
  "pk": 520,
  "fields": {
    "card": 84,
    "tag": 5
  }
},
{
  "model": "cards.cardtag",
  "pk": 521,
  "fields": {
    "card": 84,
    "tag": 1311
  }
},
{
  "model": "cards.cardtag",
  "pk": 522,
  "fields": {
    "card": 85,
    "tag": 181
  }
},
{
  "model": "cards.cardtag",
  "pk": 523,
  "fields": {
    "card": 85,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 524,
  "fields": {
    "card": 85,
    "tag": 1206
  }
},
{
  "model": "cards.cardtag",
  "pk": 525,
  "fields": {
    "card": 85,
    "tag": 1134
  }
},
{
  "model": "cards.cardtag",
  "pk": 526,
  "fields": {
    "card": 85,
    "tag": 476
  }
},
{
  "model": "cards.cardtag",
  "pk": 527,
  "fields": {
    "card": 85,
    "tag": 39
  }
},
{
  "model": "cards.cardtag",
  "pk": 528,
  "fields": {
    "card": 86,
    "tag": 514
  }
},
{
  "model": "cards.cardtag",
  "pk": 529,
  "fields": {
    "card": 86,
    "tag": 302
  }
},
{
  "model": "cards.cardtag",
  "pk": 530,
  "fields": {
    "card": 86,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 531,
  "fields": {
    "card": 86,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 532,
  "fields": {
    "card": 86,
    "tag": 929
  }
},
{
  "model": "cards.cardtag",
  "pk": 533,
  "fields": {
    "card": 86,
    "tag": 22
  }
},
{
  "model": "cards.cardtag",
  "pk": 534,
  "fields": {
    "card": 87,
    "tag": 961
  }
},
{
  "model": "cards.cardtag",
  "pk": 535,
  "fields": {
    "card": 87,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 536,
  "fields": {
    "card": 87,
    "tag": 829
  }
},
{
  "model": "cards.cardtag",
  "pk": 537,
  "fields": {
    "card": 87,
    "tag": 1396
  }
},
{
  "model": "cards.cardtag",
  "pk": 538,
  "fields": {
    "card": 87,
    "tag": 731
  }
},
{
  "model": "cards.cardtag",
  "pk": 539,
  "fields": {
    "card": 87,
    "tag": 700
  }
},
{
  "model": "cards.cardtag",
  "pk": 540,
  "fields": {
    "card": 87,
    "tag": 805
  }
},
{
  "model": "cards.cardtag",
  "pk": 541,
  "fields": {
    "card": 88,
    "tag": 253
  }
},
{
  "model": "cards.cardtag",
  "pk": 542,
  "fields": {
    "card": 88,
    "tag": 434
  }
},
{
  "model": "cards.cardtag",
  "pk": 543,
  "fields": {
    "card": 88,
    "tag": 498
  }
},
{
  "model": "cards.cardtag",
  "pk": 544,
  "fields": {
    "card": 88,
    "tag": 921
  }
},
{
  "model": "cards.cardtag",
  "pk": 545,
  "fields": {
    "card": 88,
    "tag": 695
  }
},
{
  "model": "cards.cardtag",
  "pk": 546,
  "fields": {
    "card": 88,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 547,
  "fields": {
    "card": 89,
    "tag": 571
  }
},
{
  "model": "cards.cardtag",
  "pk": 548,
  "fields": {
    "card": 89,
    "tag": 43
  }
},
{
  "model": "cards.cardtag",
  "pk": 549,
  "fields": {
    "card": 89,
    "tag": 79
  }
},
{
  "model": "cards.cardtag",
  "pk": 550,
  "fields": {
    "card": 89,
    "tag": 610
  }
},
{
  "model": "cards.cardtag",
  "pk": 551,
  "fields": {
    "card": 89,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 552,
  "fields": {
    "card": 89,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 553,
  "fields": {
    "card": 90,
    "tag": 1337
  }
},
{
  "model": "cards.cardtag",
  "pk": 554,
  "fields": {
    "card": 90,
    "tag": 718
  }
},
{
  "model": "cards.cardtag",
  "pk": 555,
  "fields": {
    "card": 90,
    "tag": 1183
  }
},
{
  "model": "cards.cardtag",
  "pk": 556,
  "fields": {
    "card": 90,
    "tag": 720
  }
},
{
  "model": "cards.cardtag",
  "pk": 557,
  "fields": {
    "card": 90,
    "tag": 747
  }
},
{
  "model": "cards.cardtag",
  "pk": 558,
  "fields": {
    "card": 90,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 559,
  "fields": {
    "card": 91,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 560,
  "fields": {
    "card": 91,
    "tag": 267
  }
},
{
  "model": "cards.cardtag",
  "pk": 561,
  "fields": {
    "card": 91,
    "tag": 577
  }
},
{
  "model": "cards.cardtag",
  "pk": 562,
  "fields": {
    "card": 91,
    "tag": 281
  }
},
{
  "model": "cards.cardtag",
  "pk": 563,
  "fields": {
    "card": 91,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 564,
  "fields": {
    "card": 91,
    "tag": 706
  }
},
{
  "model": "cards.cardtag",
  "pk": 565,
  "fields": {
    "card": 92,
    "tag": 583
  }
},
{
  "model": "cards.cardtag",
  "pk": 566,
  "fields": {
    "card": 92,
    "tag": 915
  }
},
{
  "model": "cards.cardtag",
  "pk": 567,
  "fields": {
    "card": 92,
    "tag": 970
  }
},
{
  "model": "cards.cardtag",
  "pk": 568,
  "fields": {
    "card": 92,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 569,
  "fields": {
    "card": 92,
    "tag": 509
  }
},
{
  "model": "cards.cardtag",
  "pk": 570,
  "fields": {
    "card": 92,
    "tag": 1046
  }
},
{
  "model": "cards.cardtag",
  "pk": 571,
  "fields": {
    "card": 93,
    "tag": 907
  }
},
{
  "model": "cards.cardtag",
  "pk": 572,
  "fields": {
    "card": 93,
    "tag": 996
  }
},
{
  "model": "cards.cardtag",
  "pk": 573,
  "fields": {
    "card": 93,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 574,
  "fields": {
    "card": 93,
    "tag": 160
  }
},
{
  "model": "cards.cardtag",
  "pk": 575,
  "fields": {
    "card": 93,
    "tag": 794
  }
},
{
  "model": "cards.cardtag",
  "pk": 576,
  "fields": {
    "card": 93,
    "tag": 53
  }
},
{
  "model": "cards.cardtag",
  "pk": 577,
  "fields": {
    "card": 94,
    "tag": 1067
  }
},
{
  "model": "cards.cardtag",
  "pk": 578,
  "fields": {
    "card": 94,
    "tag": 580
  }
},
{
  "model": "cards.cardtag",
  "pk": 579,
  "fields": {
    "card": 94,
    "tag": 654
  }
},
{
  "model": "cards.cardtag",
  "pk": 580,
  "fields": {
    "card": 94,
    "tag": 1066
  }
},
{
  "model": "cards.cardtag",
  "pk": 581,
  "fields": {
    "card": 94,
    "tag": 595
  }
},
{
  "model": "cards.cardtag",
  "pk": 582,
  "fields": {
    "card": 94,
    "tag": 1073
  }
},
{
  "model": "cards.cardtag",
  "pk": 583,
  "fields": {
    "card": 94,
    "tag": 634
  }
},
{
  "model": "cards.cardtag",
  "pk": 584,
  "fields": {
    "card": 94,
    "tag": 483
  }
},
{
  "model": "cards.cardtag",
  "pk": 585,
  "fields": {
    "card": 94,
    "tag": 431
  }
},
{
  "model": "cards.cardtag",
  "pk": 586,
  "fields": {
    "card": 94,
    "tag": 223
  }
},
{
  "model": "cards.cardtag",
  "pk": 587,
  "fields": {
    "card": 94,
    "tag": 769
  }
},
{
  "model": "cards.cardtag",
  "pk": 588,
  "fields": {
    "card": 95,
    "tag": 218
  }
},
{
  "model": "cards.cardtag",
  "pk": 589,
  "fields": {
    "card": 95,
    "tag": 699
  }
},
{
  "model": "cards.cardtag",
  "pk": 590,
  "fields": {
    "card": 95,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 591,
  "fields": {
    "card": 95,
    "tag": 1240
  }
},
{
  "model": "cards.cardtag",
  "pk": 592,
  "fields": {
    "card": 95,
    "tag": 1002
  }
},
{
  "model": "cards.cardtag",
  "pk": 593,
  "fields": {
    "card": 95,
    "tag": 1027
  }
},
{
  "model": "cards.cardtag",
  "pk": 594,
  "fields": {
    "card": 95,
    "tag": 990
  }
},
{
  "model": "cards.cardtag",
  "pk": 595,
  "fields": {
    "card": 96,
    "tag": 1062
  }
},
{
  "model": "cards.cardtag",
  "pk": 596,
  "fields": {
    "card": 96,
    "tag": 599
  }
},
{
  "model": "cards.cardtag",
  "pk": 597,
  "fields": {
    "card": 96,
    "tag": 1008
  }
},
{
  "model": "cards.cardtag",
  "pk": 598,
  "fields": {
    "card": 96,
    "tag": 897
  }
},
{
  "model": "cards.cardtag",
  "pk": 599,
  "fields": {
    "card": 96,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 600,
  "fields": {
    "card": 96,
    "tag": 352
  }
},
{
  "model": "cards.cardtag",
  "pk": 601,
  "fields": {
    "card": 97,
    "tag": 72
  }
},
{
  "model": "cards.cardtag",
  "pk": 602,
  "fields": {
    "card": 97,
    "tag": 488
  }
},
{
  "model": "cards.cardtag",
  "pk": 603,
  "fields": {
    "card": 97,
    "tag": 516
  }
},
{
  "model": "cards.cardtag",
  "pk": 604,
  "fields": {
    "card": 97,
    "tag": 220
  }
},
{
  "model": "cards.cardtag",
  "pk": 605,
  "fields": {
    "card": 97,
    "tag": 1390
  }
},
{
  "model": "cards.cardtag",
  "pk": 606,
  "fields": {
    "card": 97,
    "tag": 592
  }
},
{
  "model": "cards.cardtag",
  "pk": 607,
  "fields": {
    "card": 97,
    "tag": 109
  }
},
{
  "model": "cards.cardtag",
  "pk": 608,
  "fields": {
    "card": 97,
    "tag": 876
  }
},
{
  "model": "cards.cardtag",
  "pk": 609,
  "fields": {
    "card": 97,
    "tag": 582
  }
},
{
  "model": "cards.cardtag",
  "pk": 610,
  "fields": {
    "card": 98,
    "tag": 1283
  }
},
{
  "model": "cards.cardtag",
  "pk": 611,
  "fields": {
    "card": 98,
    "tag": 1226
  }
},
{
  "model": "cards.cardtag",
  "pk": 612,
  "fields": {
    "card": 98,
    "tag": 781
  }
},
{
  "model": "cards.cardtag",
  "pk": 613,
  "fields": {
    "card": 98,
    "tag": 153
  }
},
{
  "model": "cards.cardtag",
  "pk": 614,
  "fields": {
    "card": 98,
    "tag": 1244
  }
},
{
  "model": "cards.cardtag",
  "pk": 615,
  "fields": {
    "card": 98,
    "tag": 729
  }
},
{
  "model": "cards.cardtag",
  "pk": 616,
  "fields": {
    "card": 98,
    "tag": 856
  }
},
{
  "model": "cards.cardtag",
  "pk": 617,
  "fields": {
    "card": 99,
    "tag": 1264
  }
},
{
  "model": "cards.cardtag",
  "pk": 618,
  "fields": {
    "card": 99,
    "tag": 641
  }
},
{
  "model": "cards.cardtag",
  "pk": 619,
  "fields": {
    "card": 99,
    "tag": 1337
  }
},
{
  "model": "cards.cardtag",
  "pk": 620,
  "fields": {
    "card": 99,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 621,
  "fields": {
    "card": 99,
    "tag": 951
  }
},
{
  "model": "cards.cardtag",
  "pk": 622,
  "fields": {
    "card": 99,
    "tag": 561
  }
},
{
  "model": "cards.cardtag",
  "pk": 623,
  "fields": {
    "card": 100,
    "tag": 290
  }
},
{
  "model": "cards.cardtag",
  "pk": 624,
  "fields": {
    "card": 100,
    "tag": 589
  }
},
{
  "model": "cards.cardtag",
  "pk": 625,
  "fields": {
    "card": 100,
    "tag": 376
  }
},
{
  "model": "cards.cardtag",
  "pk": 626,
  "fields": {
    "card": 100,
    "tag": 817
  }
},
{
  "model": "cards.cardtag",
  "pk": 627,
  "fields": {
    "card": 100,
    "tag": 1334
  }
},
{
  "model": "cards.cardtag",
  "pk": 628,
  "fields": {
    "card": 100,
    "tag": 590
  }
},
{
  "model": "cards.cardtag",
  "pk": 629,
  "fields": {
    "card": 101,
    "tag": 614
  }
},
{
  "model": "cards.cardtag",
  "pk": 630,
  "fields": {
    "card": 101,
    "tag": 599
  }
},
{
  "model": "cards.cardtag",
  "pk": 631,
  "fields": {
    "card": 101,
    "tag": 120
  }
},
{
  "model": "cards.cardtag",
  "pk": 632,
  "fields": {
    "card": 101,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 633,
  "fields": {
    "card": 101,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 634,
  "fields": {
    "card": 101,
    "tag": 745
  }
},
{
  "model": "cards.cardtag",
  "pk": 635,
  "fields": {
    "card": 102,
    "tag": 599
  }
},
{
  "model": "cards.cardtag",
  "pk": 636,
  "fields": {
    "card": 102,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 637,
  "fields": {
    "card": 102,
    "tag": 1083
  }
},
{
  "model": "cards.cardtag",
  "pk": 638,
  "fields": {
    "card": 102,
    "tag": 951
  }
},
{
  "model": "cards.cardtag",
  "pk": 639,
  "fields": {
    "card": 102,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 640,
  "fields": {
    "card": 102,
    "tag": 22
  }
},
{
  "model": "cards.cardtag",
  "pk": 641,
  "fields": {
    "card": 103,
    "tag": 599
  }
},
{
  "model": "cards.cardtag",
  "pk": 642,
  "fields": {
    "card": 103,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 643,
  "fields": {
    "card": 103,
    "tag": 951
  }
},
{
  "model": "cards.cardtag",
  "pk": 644,
  "fields": {
    "card": 103,
    "tag": 857
  }
},
{
  "model": "cards.cardtag",
  "pk": 645,
  "fields": {
    "card": 103,
    "tag": 1062
  }
},
{
  "model": "cards.cardtag",
  "pk": 646,
  "fields": {
    "card": 103,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 647,
  "fields": {
    "card": 104,
    "tag": 599
  }
},
{
  "model": "cards.cardtag",
  "pk": 648,
  "fields": {
    "card": 104,
    "tag": 1395
  }
},
{
  "model": "cards.cardtag",
  "pk": 649,
  "fields": {
    "card": 104,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 650,
  "fields": {
    "card": 104,
    "tag": 120
  }
},
{
  "model": "cards.cardtag",
  "pk": 651,
  "fields": {
    "card": 104,
    "tag": 1018
  }
},
{
  "model": "cards.cardtag",
  "pk": 652,
  "fields": {
    "card": 104,
    "tag": 698
  }
},
{
  "model": "cards.cardtag",
  "pk": 653,
  "fields": {
    "card": 105,
    "tag": 129
  }
},
{
  "model": "cards.cardtag",
  "pk": 654,
  "fields": {
    "card": 105,
    "tag": 564
  }
},
{
  "model": "cards.cardtag",
  "pk": 655,
  "fields": {
    "card": 105,
    "tag": 1165
  }
},
{
  "model": "cards.cardtag",
  "pk": 656,
  "fields": {
    "card": 105,
    "tag": 591
  }
},
{
  "model": "cards.cardtag",
  "pk": 657,
  "fields": {
    "card": 105,
    "tag": 1100
  }
},
{
  "model": "cards.cardtag",
  "pk": 658,
  "fields": {
    "card": 105,
    "tag": 901
  }
},
{
  "model": "cards.cardtag",
  "pk": 659,
  "fields": {
    "card": 106,
    "tag": 46
  }
},
{
  "model": "cards.cardtag",
  "pk": 660,
  "fields": {
    "card": 106,
    "tag": 507
  }
},
{
  "model": "cards.cardtag",
  "pk": 661,
  "fields": {
    "card": 106,
    "tag": 359
  }
},
{
  "model": "cards.cardtag",
  "pk": 662,
  "fields": {
    "card": 106,
    "tag": 962
  }
},
{
  "model": "cards.cardtag",
  "pk": 663,
  "fields": {
    "card": 106,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 664,
  "fields": {
    "card": 106,
    "tag": 1277
  }
},
{
  "model": "cards.cardtag",
  "pk": 665,
  "fields": {
    "card": 107,
    "tag": 119
  }
},
{
  "model": "cards.cardtag",
  "pk": 666,
  "fields": {
    "card": 107,
    "tag": 63
  }
},
{
  "model": "cards.cardtag",
  "pk": 667,
  "fields": {
    "card": 107,
    "tag": 1033
  }
},
{
  "model": "cards.cardtag",
  "pk": 668,
  "fields": {
    "card": 107,
    "tag": 1055
  }
},
{
  "model": "cards.cardtag",
  "pk": 669,
  "fields": {
    "card": 107,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 670,
  "fields": {
    "card": 107,
    "tag": 742
  }
},
{
  "model": "cards.cardtag",
  "pk": 671,
  "fields": {
    "card": 108,
    "tag": 310
  }
},
{
  "model": "cards.cardtag",
  "pk": 672,
  "fields": {
    "card": 108,
    "tag": 1266
  }
},
{
  "model": "cards.cardtag",
  "pk": 673,
  "fields": {
    "card": 108,
    "tag": 266
  }
},
{
  "model": "cards.cardtag",
  "pk": 674,
  "fields": {
    "card": 108,
    "tag": 756
  }
},
{
  "model": "cards.cardtag",
  "pk": 675,
  "fields": {
    "card": 108,
    "tag": 119
  }
},
{
  "model": "cards.cardtag",
  "pk": 676,
  "fields": {
    "card": 108,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 677,
  "fields": {
    "card": 109,
    "tag": 119
  }
},
{
  "model": "cards.cardtag",
  "pk": 678,
  "fields": {
    "card": 109,
    "tag": 1031
  }
},
{
  "model": "cards.cardtag",
  "pk": 679,
  "fields": {
    "card": 109,
    "tag": 823
  }
},
{
  "model": "cards.cardtag",
  "pk": 680,
  "fields": {
    "card": 109,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 681,
  "fields": {
    "card": 109,
    "tag": 44
  }
},
{
  "model": "cards.cardtag",
  "pk": 682,
  "fields": {
    "card": 109,
    "tag": 1353
  }
},
{
  "model": "cards.cardtag",
  "pk": 683,
  "fields": {
    "card": 110,
    "tag": 121
  }
},
{
  "model": "cards.cardtag",
  "pk": 684,
  "fields": {
    "card": 110,
    "tag": 234
  }
},
{
  "model": "cards.cardtag",
  "pk": 685,
  "fields": {
    "card": 110,
    "tag": 822
  }
},
{
  "model": "cards.cardtag",
  "pk": 686,
  "fields": {
    "card": 110,
    "tag": 226
  }
},
{
  "model": "cards.cardtag",
  "pk": 687,
  "fields": {
    "card": 110,
    "tag": 837
  }
},
{
  "model": "cards.cardtag",
  "pk": 688,
  "fields": {
    "card": 110,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 689,
  "fields": {
    "card": 111,
    "tag": 1199
  }
},
{
  "model": "cards.cardtag",
  "pk": 690,
  "fields": {
    "card": 111,
    "tag": 123
  }
},
{
  "model": "cards.cardtag",
  "pk": 691,
  "fields": {
    "card": 111,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 692,
  "fields": {
    "card": 111,
    "tag": 904
  }
},
{
  "model": "cards.cardtag",
  "pk": 693,
  "fields": {
    "card": 111,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 694,
  "fields": {
    "card": 111,
    "tag": 706
  }
},
{
  "model": "cards.cardtag",
  "pk": 695,
  "fields": {
    "card": 112,
    "tag": 552
  }
},
{
  "model": "cards.cardtag",
  "pk": 696,
  "fields": {
    "card": 112,
    "tag": 1243
  }
},
{
  "model": "cards.cardtag",
  "pk": 697,
  "fields": {
    "card": 112,
    "tag": 751
  }
},
{
  "model": "cards.cardtag",
  "pk": 698,
  "fields": {
    "card": 112,
    "tag": 735
  }
},
{
  "model": "cards.cardtag",
  "pk": 699,
  "fields": {
    "card": 112,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 700,
  "fields": {
    "card": 112,
    "tag": 884
  }
},
{
  "model": "cards.cardtag",
  "pk": 701,
  "fields": {
    "card": 113,
    "tag": 802
  }
},
{
  "model": "cards.cardtag",
  "pk": 702,
  "fields": {
    "card": 113,
    "tag": 805
  }
},
{
  "model": "cards.cardtag",
  "pk": 703,
  "fields": {
    "card": 113,
    "tag": 214
  }
},
{
  "model": "cards.cardtag",
  "pk": 704,
  "fields": {
    "card": 113,
    "tag": 700
  }
},
{
  "model": "cards.cardtag",
  "pk": 705,
  "fields": {
    "card": 113,
    "tag": 829
  }
},
{
  "model": "cards.cardtag",
  "pk": 706,
  "fields": {
    "card": 113,
    "tag": 181
  }
},
{
  "model": "cards.cardtag",
  "pk": 707,
  "fields": {
    "card": 114,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 708,
  "fields": {
    "card": 114,
    "tag": 403
  }
},
{
  "model": "cards.cardtag",
  "pk": 709,
  "fields": {
    "card": 114,
    "tag": 444
  }
},
{
  "model": "cards.cardtag",
  "pk": 710,
  "fields": {
    "card": 114,
    "tag": 367
  }
},
{
  "model": "cards.cardtag",
  "pk": 711,
  "fields": {
    "card": 114,
    "tag": 1028
  }
},
{
  "model": "cards.cardtag",
  "pk": 712,
  "fields": {
    "card": 115,
    "tag": 251
  }
},
{
  "model": "cards.cardtag",
  "pk": 713,
  "fields": {
    "card": 115,
    "tag": 616
  }
},
{
  "model": "cards.cardtag",
  "pk": 714,
  "fields": {
    "card": 115,
    "tag": 86
  }
},
{
  "model": "cards.cardtag",
  "pk": 715,
  "fields": {
    "card": 115,
    "tag": 26
  }
},
{
  "model": "cards.cardtag",
  "pk": 716,
  "fields": {
    "card": 115,
    "tag": 330
  }
},
{
  "model": "cards.cardtag",
  "pk": 717,
  "fields": {
    "card": 115,
    "tag": 99
  }
},
{
  "model": "cards.cardtag",
  "pk": 718,
  "fields": {
    "card": 115,
    "tag": 963
  }
},
{
  "model": "cards.cardtag",
  "pk": 719,
  "fields": {
    "card": 116,
    "tag": 1032
  }
},
{
  "model": "cards.cardtag",
  "pk": 720,
  "fields": {
    "card": 116,
    "tag": 772
  }
},
{
  "model": "cards.cardtag",
  "pk": 721,
  "fields": {
    "card": 116,
    "tag": 57
  }
},
{
  "model": "cards.cardtag",
  "pk": 722,
  "fields": {
    "card": 116,
    "tag": 795
  }
},
{
  "model": "cards.cardtag",
  "pk": 723,
  "fields": {
    "card": 116,
    "tag": 1270
  }
},
{
  "model": "cards.cardtag",
  "pk": 724,
  "fields": {
    "card": 116,
    "tag": 529
  }
},
{
  "model": "cards.cardtag",
  "pk": 725,
  "fields": {
    "card": 116,
    "tag": 218
  }
},
{
  "model": "cards.cardtag",
  "pk": 726,
  "fields": {
    "card": 117,
    "tag": 987
  }
},
{
  "model": "cards.cardtag",
  "pk": 727,
  "fields": {
    "card": 117,
    "tag": 128
  }
},
{
  "model": "cards.cardtag",
  "pk": 728,
  "fields": {
    "card": 117,
    "tag": 306
  }
},
{
  "model": "cards.cardtag",
  "pk": 729,
  "fields": {
    "card": 117,
    "tag": 356
  }
},
{
  "model": "cards.cardtag",
  "pk": 730,
  "fields": {
    "card": 117,
    "tag": 1202
  }
},
{
  "model": "cards.cardtag",
  "pk": 731,
  "fields": {
    "card": 117,
    "tag": 1148
  }
},
{
  "model": "cards.cardtag",
  "pk": 732,
  "fields": {
    "card": 117,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 733,
  "fields": {
    "card": 118,
    "tag": 945
  }
},
{
  "model": "cards.cardtag",
  "pk": 734,
  "fields": {
    "card": 118,
    "tag": 772
  }
},
{
  "model": "cards.cardtag",
  "pk": 735,
  "fields": {
    "card": 118,
    "tag": 1358
  }
},
{
  "model": "cards.cardtag",
  "pk": 736,
  "fields": {
    "card": 118,
    "tag": 240
  }
},
{
  "model": "cards.cardtag",
  "pk": 737,
  "fields": {
    "card": 118,
    "tag": 1055
  }
},
{
  "model": "cards.cardtag",
  "pk": 738,
  "fields": {
    "card": 118,
    "tag": 398
  }
},
{
  "model": "cards.cardtag",
  "pk": 739,
  "fields": {
    "card": 118,
    "tag": 758
  }
},
{
  "model": "cards.cardtag",
  "pk": 740,
  "fields": {
    "card": 119,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 741,
  "fields": {
    "card": 119,
    "tag": 213
  }
},
{
  "model": "cards.cardtag",
  "pk": 742,
  "fields": {
    "card": 119,
    "tag": 847
  }
},
{
  "model": "cards.cardtag",
  "pk": 743,
  "fields": {
    "card": 119,
    "tag": 114
  }
},
{
  "model": "cards.cardtag",
  "pk": 744,
  "fields": {
    "card": 119,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 745,
  "fields": {
    "card": 119,
    "tag": 1320
  }
},
{
  "model": "cards.cardtag",
  "pk": 746,
  "fields": {
    "card": 120,
    "tag": 1019
  }
},
{
  "model": "cards.cardtag",
  "pk": 747,
  "fields": {
    "card": 120,
    "tag": 219
  }
},
{
  "model": "cards.cardtag",
  "pk": 748,
  "fields": {
    "card": 120,
    "tag": 274
  }
},
{
  "model": "cards.cardtag",
  "pk": 749,
  "fields": {
    "card": 120,
    "tag": 1078
  }
},
{
  "model": "cards.cardtag",
  "pk": 750,
  "fields": {
    "card": 120,
    "tag": 495
  }
},
{
  "model": "cards.cardtag",
  "pk": 751,
  "fields": {
    "card": 120,
    "tag": 671
  }
},
{
  "model": "cards.cardtag",
  "pk": 752,
  "fields": {
    "card": 120,
    "tag": 168
  }
},
{
  "model": "cards.cardtag",
  "pk": 753,
  "fields": {
    "card": 120,
    "tag": 612
  }
},
{
  "model": "cards.cardtag",
  "pk": 754,
  "fields": {
    "card": 120,
    "tag": 170
  }
},
{
  "model": "cards.cardtag",
  "pk": 755,
  "fields": {
    "card": 120,
    "tag": 573
  }
},
{
  "model": "cards.cardtag",
  "pk": 756,
  "fields": {
    "card": 120,
    "tag": 1130
  }
},
{
  "model": "cards.cardtag",
  "pk": 757,
  "fields": {
    "card": 120,
    "tag": 306
  }
},
{
  "model": "cards.cardtag",
  "pk": 758,
  "fields": {
    "card": 120,
    "tag": 372
  }
},
{
  "model": "cards.cardtag",
  "pk": 759,
  "fields": {
    "card": 120,
    "tag": 858
  }
},
{
  "model": "cards.cardtag",
  "pk": 760,
  "fields": {
    "card": 120,
    "tag": 307
  }
},
{
  "model": "cards.cardtag",
  "pk": 761,
  "fields": {
    "card": 121,
    "tag": 756
  }
},
{
  "model": "cards.cardtag",
  "pk": 762,
  "fields": {
    "card": 121,
    "tag": 706
  }
},
{
  "model": "cards.cardtag",
  "pk": 763,
  "fields": {
    "card": 121,
    "tag": 1323
  }
},
{
  "model": "cards.cardtag",
  "pk": 764,
  "fields": {
    "card": 121,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 765,
  "fields": {
    "card": 121,
    "tag": 683
  }
},
{
  "model": "cards.cardtag",
  "pk": 766,
  "fields": {
    "card": 121,
    "tag": 827
  }
},
{
  "model": "cards.cardtag",
  "pk": 767,
  "fields": {
    "card": 122,
    "tag": 266
  }
},
{
  "model": "cards.cardtag",
  "pk": 768,
  "fields": {
    "card": 122,
    "tag": 723
  }
},
{
  "model": "cards.cardtag",
  "pk": 769,
  "fields": {
    "card": 122,
    "tag": 350
  }
},
{
  "model": "cards.cardtag",
  "pk": 770,
  "fields": {
    "card": 122,
    "tag": 252
  }
},
{
  "model": "cards.cardtag",
  "pk": 771,
  "fields": {
    "card": 122,
    "tag": 706
  }
},
{
  "model": "cards.cardtag",
  "pk": 772,
  "fields": {
    "card": 122,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 773,
  "fields": {
    "card": 123,
    "tag": 266
  }
},
{
  "model": "cards.cardtag",
  "pk": 774,
  "fields": {
    "card": 123,
    "tag": 706
  }
},
{
  "model": "cards.cardtag",
  "pk": 775,
  "fields": {
    "card": 123,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 776,
  "fields": {
    "card": 123,
    "tag": 1086
  }
},
{
  "model": "cards.cardtag",
  "pk": 777,
  "fields": {
    "card": 123,
    "tag": 429
  }
},
{
  "model": "cards.cardtag",
  "pk": 778,
  "fields": {
    "card": 123,
    "tag": 556
  }
},
{
  "model": "cards.cardtag",
  "pk": 779,
  "fields": {
    "card": 124,
    "tag": 1127
  }
},
{
  "model": "cards.cardtag",
  "pk": 780,
  "fields": {
    "card": 124,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 781,
  "fields": {
    "card": 124,
    "tag": 578
  }
},
{
  "model": "cards.cardtag",
  "pk": 782,
  "fields": {
    "card": 124,
    "tag": 630
  }
},
{
  "model": "cards.cardtag",
  "pk": 783,
  "fields": {
    "card": 124,
    "tag": 367
  }
},
{
  "model": "cards.cardtag",
  "pk": 784,
  "fields": {
    "card": 124,
    "tag": 1014
  }
},
{
  "model": "cards.cardtag",
  "pk": 785,
  "fields": {
    "card": 125,
    "tag": 1117
  }
},
{
  "model": "cards.cardtag",
  "pk": 786,
  "fields": {
    "card": 125,
    "tag": 1239
  }
},
{
  "model": "cards.cardtag",
  "pk": 787,
  "fields": {
    "card": 125,
    "tag": 480
  }
},
{
  "model": "cards.cardtag",
  "pk": 788,
  "fields": {
    "card": 125,
    "tag": 346
  }
},
{
  "model": "cards.cardtag",
  "pk": 789,
  "fields": {
    "card": 125,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 790,
  "fields": {
    "card": 125,
    "tag": 1251
  }
},
{
  "model": "cards.cardtag",
  "pk": 791,
  "fields": {
    "card": 126,
    "tag": 412
  }
},
{
  "model": "cards.cardtag",
  "pk": 792,
  "fields": {
    "card": 126,
    "tag": 1215
  }
},
{
  "model": "cards.cardtag",
  "pk": 793,
  "fields": {
    "card": 126,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 794,
  "fields": {
    "card": 126,
    "tag": 977
  }
},
{
  "model": "cards.cardtag",
  "pk": 795,
  "fields": {
    "card": 126,
    "tag": 578
  }
},
{
  "model": "cards.cardtag",
  "pk": 796,
  "fields": {
    "card": 127,
    "tag": 1101
  }
},
{
  "model": "cards.cardtag",
  "pk": 797,
  "fields": {
    "card": 127,
    "tag": 171
  }
},
{
  "model": "cards.cardtag",
  "pk": 798,
  "fields": {
    "card": 127,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 799,
  "fields": {
    "card": 127,
    "tag": 1156
  }
},
{
  "model": "cards.cardtag",
  "pk": 800,
  "fields": {
    "card": 127,
    "tag": 1113
  }
},
{
  "model": "cards.cardtag",
  "pk": 801,
  "fields": {
    "card": 127,
    "tag": 1302
  }
},
{
  "model": "cards.cardtag",
  "pk": 802,
  "fields": {
    "card": 128,
    "tag": 274
  }
},
{
  "model": "cards.cardtag",
  "pk": 803,
  "fields": {
    "card": 128,
    "tag": 712
  }
},
{
  "model": "cards.cardtag",
  "pk": 804,
  "fields": {
    "card": 128,
    "tag": 1106
  }
},
{
  "model": "cards.cardtag",
  "pk": 805,
  "fields": {
    "card": 128,
    "tag": 1250
  }
},
{
  "model": "cards.cardtag",
  "pk": 806,
  "fields": {
    "card": 128,
    "tag": 1293
  }
},
{
  "model": "cards.cardtag",
  "pk": 807,
  "fields": {
    "card": 128,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 808,
  "fields": {
    "card": 129,
    "tag": 1362
  }
},
{
  "model": "cards.cardtag",
  "pk": 809,
  "fields": {
    "card": 129,
    "tag": 599
  }
},
{
  "model": "cards.cardtag",
  "pk": 810,
  "fields": {
    "card": 129,
    "tag": 1083
  }
},
{
  "model": "cards.cardtag",
  "pk": 811,
  "fields": {
    "card": 129,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 812,
  "fields": {
    "card": 129,
    "tag": 468
  }
},
{
  "model": "cards.cardtag",
  "pk": 813,
  "fields": {
    "card": 129,
    "tag": 747
  }
},
{
  "model": "cards.cardtag",
  "pk": 814,
  "fields": {
    "card": 130,
    "tag": 543
  }
},
{
  "model": "cards.cardtag",
  "pk": 815,
  "fields": {
    "card": 130,
    "tag": 1024
  }
},
{
  "model": "cards.cardtag",
  "pk": 816,
  "fields": {
    "card": 130,
    "tag": 99
  }
},
{
  "model": "cards.cardtag",
  "pk": 817,
  "fields": {
    "card": 130,
    "tag": 1302
  }
},
{
  "model": "cards.cardtag",
  "pk": 818,
  "fields": {
    "card": 130,
    "tag": 93
  }
},
{
  "model": "cards.cardtag",
  "pk": 819,
  "fields": {
    "card": 130,
    "tag": 517
  }
},
{
  "model": "cards.cardtag",
  "pk": 820,
  "fields": {
    "card": 131,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 821,
  "fields": {
    "card": 131,
    "tag": 332
  }
},
{
  "model": "cards.cardtag",
  "pk": 822,
  "fields": {
    "card": 131,
    "tag": 762
  }
},
{
  "model": "cards.cardtag",
  "pk": 823,
  "fields": {
    "card": 131,
    "tag": 1101
  }
},
{
  "model": "cards.cardtag",
  "pk": 824,
  "fields": {
    "card": 131,
    "tag": 122
  }
},
{
  "model": "cards.cardtag",
  "pk": 825,
  "fields": {
    "card": 131,
    "tag": 745
  }
},
{
  "model": "cards.cardtag",
  "pk": 826,
  "fields": {
    "card": 132,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 827,
  "fields": {
    "card": 132,
    "tag": 991
  }
},
{
  "model": "cards.cardtag",
  "pk": 828,
  "fields": {
    "card": 132,
    "tag": 219
  }
},
{
  "model": "cards.cardtag",
  "pk": 829,
  "fields": {
    "card": 132,
    "tag": 1161
  }
},
{
  "model": "cards.cardtag",
  "pk": 830,
  "fields": {
    "card": 132,
    "tag": 332
  }
},
{
  "model": "cards.cardtag",
  "pk": 831,
  "fields": {
    "card": 132,
    "tag": 902
  }
},
{
  "model": "cards.cardtag",
  "pk": 832,
  "fields": {
    "card": 133,
    "tag": 358
  }
},
{
  "model": "cards.cardtag",
  "pk": 833,
  "fields": {
    "card": 133,
    "tag": 495
  }
},
{
  "model": "cards.cardtag",
  "pk": 834,
  "fields": {
    "card": 133,
    "tag": 1038
  }
},
{
  "model": "cards.cardtag",
  "pk": 835,
  "fields": {
    "card": 133,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 836,
  "fields": {
    "card": 133,
    "tag": 269
  }
},
{
  "model": "cards.cardtag",
  "pk": 837,
  "fields": {
    "card": 133,
    "tag": 1093
  }
},
{
  "model": "cards.cardtag",
  "pk": 838,
  "fields": {
    "card": 134,
    "tag": 1254
  }
},
{
  "model": "cards.cardtag",
  "pk": 839,
  "fields": {
    "card": 134,
    "tag": 676
  }
},
{
  "model": "cards.cardtag",
  "pk": 840,
  "fields": {
    "card": 134,
    "tag": 849
  }
},
{
  "model": "cards.cardtag",
  "pk": 841,
  "fields": {
    "card": 134,
    "tag": 665
  }
},
{
  "model": "cards.cardtag",
  "pk": 842,
  "fields": {
    "card": 134,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 843,
  "fields": {
    "card": 135,
    "tag": 358
  }
},
{
  "model": "cards.cardtag",
  "pk": 844,
  "fields": {
    "card": 135,
    "tag": 1371
  }
},
{
  "model": "cards.cardtag",
  "pk": 845,
  "fields": {
    "card": 135,
    "tag": 903
  }
},
{
  "model": "cards.cardtag",
  "pk": 846,
  "fields": {
    "card": 135,
    "tag": 1038
  }
},
{
  "model": "cards.cardtag",
  "pk": 847,
  "fields": {
    "card": 135,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 848,
  "fields": {
    "card": 135,
    "tag": 33
  }
},
{
  "model": "cards.cardtag",
  "pk": 849,
  "fields": {
    "card": 136,
    "tag": 179
  }
},
{
  "model": "cards.cardtag",
  "pk": 850,
  "fields": {
    "card": 136,
    "tag": 27
  }
},
{
  "model": "cards.cardtag",
  "pk": 851,
  "fields": {
    "card": 136,
    "tag": 1055
  }
},
{
  "model": "cards.cardtag",
  "pk": 852,
  "fields": {
    "card": 136,
    "tag": 1207
  }
},
{
  "model": "cards.cardtag",
  "pk": 853,
  "fields": {
    "card": 136,
    "tag": 780
  }
},
{
  "model": "cards.cardtag",
  "pk": 854,
  "fields": {
    "card": 136,
    "tag": 989
  }
},
{
  "model": "cards.cardtag",
  "pk": 855,
  "fields": {
    "card": 136,
    "tag": 975
  }
},
{
  "model": "cards.cardtag",
  "pk": 856,
  "fields": {
    "card": 137,
    "tag": 1055
  }
},
{
  "model": "cards.cardtag",
  "pk": 857,
  "fields": {
    "card": 137,
    "tag": 179
  }
},
{
  "model": "cards.cardtag",
  "pk": 858,
  "fields": {
    "card": 137,
    "tag": 777
  }
},
{
  "model": "cards.cardtag",
  "pk": 859,
  "fields": {
    "card": 137,
    "tag": 975
  }
},
{
  "model": "cards.cardtag",
  "pk": 860,
  "fields": {
    "card": 137,
    "tag": 576
  }
},
{
  "model": "cards.cardtag",
  "pk": 861,
  "fields": {
    "card": 137,
    "tag": 1258
  }
},
{
  "model": "cards.cardtag",
  "pk": 862,
  "fields": {
    "card": 138,
    "tag": 151
  }
},
{
  "model": "cards.cardtag",
  "pk": 863,
  "fields": {
    "card": 138,
    "tag": 1238
  }
},
{
  "model": "cards.cardtag",
  "pk": 864,
  "fields": {
    "card": 138,
    "tag": 801
  }
},
{
  "model": "cards.cardtag",
  "pk": 865,
  "fields": {
    "card": 138,
    "tag": 408
  }
},
{
  "model": "cards.cardtag",
  "pk": 866,
  "fields": {
    "card": 138,
    "tag": 704
  }
},
{
  "model": "cards.cardtag",
  "pk": 867,
  "fields": {
    "card": 138,
    "tag": 63
  }
},
{
  "model": "cards.cardtag",
  "pk": 868,
  "fields": {
    "card": 138,
    "tag": 1033
  }
},
{
  "model": "cards.cardtag",
  "pk": 869,
  "fields": {
    "card": 139,
    "tag": 151
  }
},
{
  "model": "cards.cardtag",
  "pk": 870,
  "fields": {
    "card": 139,
    "tag": 1238
  }
},
{
  "model": "cards.cardtag",
  "pk": 871,
  "fields": {
    "card": 139,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 872,
  "fields": {
    "card": 139,
    "tag": 1055
  }
},
{
  "model": "cards.cardtag",
  "pk": 873,
  "fields": {
    "card": 139,
    "tag": 524
  }
},
{
  "model": "cards.cardtag",
  "pk": 874,
  "fields": {
    "card": 139,
    "tag": 1187
  }
},
{
  "model": "cards.cardtag",
  "pk": 875,
  "fields": {
    "card": 140,
    "tag": 1118
  }
},
{
  "model": "cards.cardtag",
  "pk": 876,
  "fields": {
    "card": 140,
    "tag": 1395
  }
},
{
  "model": "cards.cardtag",
  "pk": 877,
  "fields": {
    "card": 140,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 878,
  "fields": {
    "card": 140,
    "tag": 878
  }
},
{
  "model": "cards.cardtag",
  "pk": 879,
  "fields": {
    "card": 140,
    "tag": 1062
  }
},
{
  "model": "cards.cardtag",
  "pk": 880,
  "fields": {
    "card": 140,
    "tag": 1182
  }
},
{
  "model": "cards.cardtag",
  "pk": 881,
  "fields": {
    "card": 141,
    "tag": 920
  }
},
{
  "model": "cards.cardtag",
  "pk": 882,
  "fields": {
    "card": 141,
    "tag": 7
  }
},
{
  "model": "cards.cardtag",
  "pk": 883,
  "fields": {
    "card": 141,
    "tag": 409
  }
},
{
  "model": "cards.cardtag",
  "pk": 884,
  "fields": {
    "card": 141,
    "tag": 1294
  }
},
{
  "model": "cards.cardtag",
  "pk": 885,
  "fields": {
    "card": 141,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 886,
  "fields": {
    "card": 141,
    "tag": 499
  }
},
{
  "model": "cards.cardtag",
  "pk": 887,
  "fields": {
    "card": 142,
    "tag": 1289
  }
},
{
  "model": "cards.cardtag",
  "pk": 888,
  "fields": {
    "card": 142,
    "tag": 192
  }
},
{
  "model": "cards.cardtag",
  "pk": 889,
  "fields": {
    "card": 142,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 890,
  "fields": {
    "card": 142,
    "tag": 938
  }
},
{
  "model": "cards.cardtag",
  "pk": 891,
  "fields": {
    "card": 142,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 892,
  "fields": {
    "card": 142,
    "tag": 1303
  }
},
{
  "model": "cards.cardtag",
  "pk": 893,
  "fields": {
    "card": 143,
    "tag": 920
  }
},
{
  "model": "cards.cardtag",
  "pk": 894,
  "fields": {
    "card": 143,
    "tag": 362
  }
},
{
  "model": "cards.cardtag",
  "pk": 895,
  "fields": {
    "card": 143,
    "tag": 969
  }
},
{
  "model": "cards.cardtag",
  "pk": 896,
  "fields": {
    "card": 143,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 897,
  "fields": {
    "card": 143,
    "tag": 1289
  }
},
{
  "model": "cards.cardtag",
  "pk": 898,
  "fields": {
    "card": 143,
    "tag": 192
  }
},
{
  "model": "cards.cardtag",
  "pk": 899,
  "fields": {
    "card": 143,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 900,
  "fields": {
    "card": 144,
    "tag": 817
  }
},
{
  "model": "cards.cardtag",
  "pk": 901,
  "fields": {
    "card": 144,
    "tag": 450
  }
},
{
  "model": "cards.cardtag",
  "pk": 902,
  "fields": {
    "card": 144,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 903,
  "fields": {
    "card": 144,
    "tag": 1095
  }
},
{
  "model": "cards.cardtag",
  "pk": 904,
  "fields": {
    "card": 144,
    "tag": 34
  }
},
{
  "model": "cards.cardtag",
  "pk": 905,
  "fields": {
    "card": 144,
    "tag": 926
  }
},
{
  "model": "cards.cardtag",
  "pk": 906,
  "fields": {
    "card": 145,
    "tag": 1036
  }
},
{
  "model": "cards.cardtag",
  "pk": 907,
  "fields": {
    "card": 145,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 908,
  "fields": {
    "card": 145,
    "tag": 1335
  }
},
{
  "model": "cards.cardtag",
  "pk": 909,
  "fields": {
    "card": 145,
    "tag": 1116
  }
},
{
  "model": "cards.cardtag",
  "pk": 910,
  "fields": {
    "card": 145,
    "tag": 829
  }
},
{
  "model": "cards.cardtag",
  "pk": 911,
  "fields": {
    "card": 145,
    "tag": 461
  }
},
{
  "model": "cards.cardtag",
  "pk": 912,
  "fields": {
    "card": 146,
    "tag": 460
  }
},
{
  "model": "cards.cardtag",
  "pk": 913,
  "fields": {
    "card": 146,
    "tag": 1216
  }
},
{
  "model": "cards.cardtag",
  "pk": 914,
  "fields": {
    "card": 146,
    "tag": 111
  }
},
{
  "model": "cards.cardtag",
  "pk": 915,
  "fields": {
    "card": 146,
    "tag": 642
  }
},
{
  "model": "cards.cardtag",
  "pk": 916,
  "fields": {
    "card": 146,
    "tag": 1213
  }
},
{
  "model": "cards.cardtag",
  "pk": 917,
  "fields": {
    "card": 146,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 918,
  "fields": {
    "card": 147,
    "tag": 552
  }
},
{
  "model": "cards.cardtag",
  "pk": 919,
  "fields": {
    "card": 147,
    "tag": 314
  }
},
{
  "model": "cards.cardtag",
  "pk": 920,
  "fields": {
    "card": 147,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 921,
  "fields": {
    "card": 147,
    "tag": 884
  }
},
{
  "model": "cards.cardtag",
  "pk": 922,
  "fields": {
    "card": 147,
    "tag": 638
  }
},
{
  "model": "cards.cardtag",
  "pk": 923,
  "fields": {
    "card": 147,
    "tag": 1040
  }
},
{
  "model": "cards.cardtag",
  "pk": 924,
  "fields": {
    "card": 148,
    "tag": 837
  }
},
{
  "model": "cards.cardtag",
  "pk": 925,
  "fields": {
    "card": 148,
    "tag": 782
  }
},
{
  "model": "cards.cardtag",
  "pk": 926,
  "fields": {
    "card": 148,
    "tag": 651
  }
},
{
  "model": "cards.cardtag",
  "pk": 927,
  "fields": {
    "card": 148,
    "tag": 271
  }
},
{
  "model": "cards.cardtag",
  "pk": 928,
  "fields": {
    "card": 148,
    "tag": 794
  }
},
{
  "model": "cards.cardtag",
  "pk": 929,
  "fields": {
    "card": 148,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 930,
  "fields": {
    "card": 149,
    "tag": 1286
  }
},
{
  "model": "cards.cardtag",
  "pk": 931,
  "fields": {
    "card": 149,
    "tag": 817
  }
},
{
  "model": "cards.cardtag",
  "pk": 932,
  "fields": {
    "card": 149,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 933,
  "fields": {
    "card": 149,
    "tag": 766
  }
},
{
  "model": "cards.cardtag",
  "pk": 934,
  "fields": {
    "card": 149,
    "tag": 290
  }
},
{
  "model": "cards.cardtag",
  "pk": 935,
  "fields": {
    "card": 149,
    "tag": 589
  }
},
{
  "model": "cards.cardtag",
  "pk": 936,
  "fields": {
    "card": 149,
    "tag": 292
  }
},
{
  "model": "cards.cardtag",
  "pk": 937,
  "fields": {
    "card": 150,
    "tag": 188
  }
},
{
  "model": "cards.cardtag",
  "pk": 938,
  "fields": {
    "card": 150,
    "tag": 161
  }
},
{
  "model": "cards.cardtag",
  "pk": 939,
  "fields": {
    "card": 150,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 940,
  "fields": {
    "card": 150,
    "tag": 537
  }
},
{
  "model": "cards.cardtag",
  "pk": 941,
  "fields": {
    "card": 150,
    "tag": 1299
  }
},
{
  "model": "cards.cardtag",
  "pk": 942,
  "fields": {
    "card": 150,
    "tag": 370
  }
},
{
  "model": "cards.cardtag",
  "pk": 943,
  "fields": {
    "card": 150,
    "tag": 293
  }
},
{
  "model": "cards.cardtag",
  "pk": 944,
  "fields": {
    "card": 151,
    "tag": 266
  }
},
{
  "model": "cards.cardtag",
  "pk": 945,
  "fields": {
    "card": 151,
    "tag": 706
  }
},
{
  "model": "cards.cardtag",
  "pk": 946,
  "fields": {
    "card": 151,
    "tag": 959
  }
},
{
  "model": "cards.cardtag",
  "pk": 947,
  "fields": {
    "card": 151,
    "tag": 387
  }
},
{
  "model": "cards.cardtag",
  "pk": 948,
  "fields": {
    "card": 151,
    "tag": 1086
  }
},
{
  "model": "cards.cardtag",
  "pk": 949,
  "fields": {
    "card": 151,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 950,
  "fields": {
    "card": 152,
    "tag": 266
  }
},
{
  "model": "cards.cardtag",
  "pk": 951,
  "fields": {
    "card": 152,
    "tag": 683
  }
},
{
  "model": "cards.cardtag",
  "pk": 952,
  "fields": {
    "card": 152,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 953,
  "fields": {
    "card": 152,
    "tag": 706
  }
},
{
  "model": "cards.cardtag",
  "pk": 954,
  "fields": {
    "card": 152,
    "tag": 756
  }
},
{
  "model": "cards.cardtag",
  "pk": 955,
  "fields": {
    "card": 152,
    "tag": 925
  }
},
{
  "model": "cards.cardtag",
  "pk": 956,
  "fields": {
    "card": 153,
    "tag": 1293
  }
},
{
  "model": "cards.cardtag",
  "pk": 957,
  "fields": {
    "card": 153,
    "tag": 266
  }
},
{
  "model": "cards.cardtag",
  "pk": 958,
  "fields": {
    "card": 153,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 959,
  "fields": {
    "card": 153,
    "tag": 1322
  }
},
{
  "model": "cards.cardtag",
  "pk": 960,
  "fields": {
    "card": 153,
    "tag": 676
  }
},
{
  "model": "cards.cardtag",
  "pk": 961,
  "fields": {
    "card": 153,
    "tag": 790
  }
},
{
  "model": "cards.cardtag",
  "pk": 962,
  "fields": {
    "card": 153,
    "tag": 787
  }
},
{
  "model": "cards.cardtag",
  "pk": 963,
  "fields": {
    "card": 153,
    "tag": 237
  }
},
{
  "model": "cards.cardtag",
  "pk": 964,
  "fields": {
    "card": 154,
    "tag": 1277
  }
},
{
  "model": "cards.cardtag",
  "pk": 965,
  "fields": {
    "card": 154,
    "tag": 507
  }
},
{
  "model": "cards.cardtag",
  "pk": 966,
  "fields": {
    "card": 154,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 967,
  "fields": {
    "card": 154,
    "tag": 871
  }
},
{
  "model": "cards.cardtag",
  "pk": 968,
  "fields": {
    "card": 154,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 969,
  "fields": {
    "card": 154,
    "tag": 340
  }
},
{
  "model": "cards.cardtag",
  "pk": 970,
  "fields": {
    "card": 155,
    "tag": 1029
  }
},
{
  "model": "cards.cardtag",
  "pk": 971,
  "fields": {
    "card": 155,
    "tag": 1062
  }
},
{
  "model": "cards.cardtag",
  "pk": 972,
  "fields": {
    "card": 155,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 973,
  "fields": {
    "card": 155,
    "tag": 1305
  }
},
{
  "model": "cards.cardtag",
  "pk": 974,
  "fields": {
    "card": 155,
    "tag": 1330
  }
},
{
  "model": "cards.cardtag",
  "pk": 975,
  "fields": {
    "card": 156,
    "tag": 1310
  }
},
{
  "model": "cards.cardtag",
  "pk": 976,
  "fields": {
    "card": 156,
    "tag": 463
  }
},
{
  "model": "cards.cardtag",
  "pk": 977,
  "fields": {
    "card": 156,
    "tag": 242
  }
},
{
  "model": "cards.cardtag",
  "pk": 978,
  "fields": {
    "card": 156,
    "tag": 538
  }
},
{
  "model": "cards.cardtag",
  "pk": 979,
  "fields": {
    "card": 156,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 980,
  "fields": {
    "card": 156,
    "tag": 292
  }
},
{
  "model": "cards.cardtag",
  "pk": 981,
  "fields": {
    "card": 157,
    "tag": 1038
  }
},
{
  "model": "cards.cardtag",
  "pk": 982,
  "fields": {
    "card": 157,
    "tag": 358
  }
},
{
  "model": "cards.cardtag",
  "pk": 983,
  "fields": {
    "card": 157,
    "tag": 1015
  }
},
{
  "model": "cards.cardtag",
  "pk": 984,
  "fields": {
    "card": 157,
    "tag": 572
  }
},
{
  "model": "cards.cardtag",
  "pk": 985,
  "fields": {
    "card": 157,
    "tag": 318
  }
},
{
  "model": "cards.cardtag",
  "pk": 986,
  "fields": {
    "card": 157,
    "tag": 756
  }
},
{
  "model": "cards.cardtag",
  "pk": 987,
  "fields": {
    "card": 158,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 988,
  "fields": {
    "card": 158,
    "tag": 468
  }
},
{
  "model": "cards.cardtag",
  "pk": 989,
  "fields": {
    "card": 158,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 990,
  "fields": {
    "card": 158,
    "tag": 766
  }
},
{
  "model": "cards.cardtag",
  "pk": 991,
  "fields": {
    "card": 158,
    "tag": 549
  }
},
{
  "model": "cards.cardtag",
  "pk": 992,
  "fields": {
    "card": 158,
    "tag": 1146
  }
},
{
  "model": "cards.cardtag",
  "pk": 993,
  "fields": {
    "card": 159,
    "tag": 253
  }
},
{
  "model": "cards.cardtag",
  "pk": 994,
  "fields": {
    "card": 159,
    "tag": 37
  }
},
{
  "model": "cards.cardtag",
  "pk": 995,
  "fields": {
    "card": 159,
    "tag": 184
  }
},
{
  "model": "cards.cardtag",
  "pk": 996,
  "fields": {
    "card": 159,
    "tag": 8
  }
},
{
  "model": "cards.cardtag",
  "pk": 997,
  "fields": {
    "card": 159,
    "tag": 746
  }
},
{
  "model": "cards.cardtag",
  "pk": 998,
  "fields": {
    "card": 159,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 999,
  "fields": {
    "card": 160,
    "tag": 9
  }
},
{
  "model": "cards.cardtag",
  "pk": 1000,
  "fields": {
    "card": 160,
    "tag": 364
  }
},
{
  "model": "cards.cardtag",
  "pk": 1001,
  "fields": {
    "card": 160,
    "tag": 1388
  }
},
{
  "model": "cards.cardtag",
  "pk": 1002,
  "fields": {
    "card": 160,
    "tag": 1395
  }
},
{
  "model": "cards.cardtag",
  "pk": 1003,
  "fields": {
    "card": 160,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 1004,
  "fields": {
    "card": 160,
    "tag": 706
  }
},
{
  "model": "cards.cardtag",
  "pk": 1005,
  "fields": {
    "card": 161,
    "tag": 896
  }
},
{
  "model": "cards.cardtag",
  "pk": 1006,
  "fields": {
    "card": 161,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1007,
  "fields": {
    "card": 161,
    "tag": 92
  }
},
{
  "model": "cards.cardtag",
  "pk": 1008,
  "fields": {
    "card": 161,
    "tag": 368
  }
},
{
  "model": "cards.cardtag",
  "pk": 1009,
  "fields": {
    "card": 161,
    "tag": 30
  }
},
{
  "model": "cards.cardtag",
  "pk": 1010,
  "fields": {
    "card": 161,
    "tag": 206
  }
},
{
  "model": "cards.cardtag",
  "pk": 1011,
  "fields": {
    "card": 161,
    "tag": 537
  }
},
{
  "model": "cards.cardtag",
  "pk": 1012,
  "fields": {
    "card": 161,
    "tag": 166
  }
},
{
  "model": "cards.cardtag",
  "pk": 1013,
  "fields": {
    "card": 162,
    "tag": 1278
  }
},
{
  "model": "cards.cardtag",
  "pk": 1014,
  "fields": {
    "card": 162,
    "tag": 712
  }
},
{
  "model": "cards.cardtag",
  "pk": 1015,
  "fields": {
    "card": 162,
    "tag": 1062
  }
},
{
  "model": "cards.cardtag",
  "pk": 1016,
  "fields": {
    "card": 162,
    "tag": 897
  }
},
{
  "model": "cards.cardtag",
  "pk": 1017,
  "fields": {
    "card": 162,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1018,
  "fields": {
    "card": 162,
    "tag": 264
  }
},
{
  "model": "cards.cardtag",
  "pk": 1019,
  "fields": {
    "card": 163,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1020,
  "fields": {
    "card": 163,
    "tag": 111
  }
},
{
  "model": "cards.cardtag",
  "pk": 1021,
  "fields": {
    "card": 163,
    "tag": 1062
  }
},
{
  "model": "cards.cardtag",
  "pk": 1022,
  "fields": {
    "card": 163,
    "tag": 561
  }
},
{
  "model": "cards.cardtag",
  "pk": 1023,
  "fields": {
    "card": 163,
    "tag": 539
  }
},
{
  "model": "cards.cardtag",
  "pk": 1024,
  "fields": {
    "card": 163,
    "tag": 1214
  }
},
{
  "model": "cards.cardtag",
  "pk": 1025,
  "fields": {
    "card": 164,
    "tag": 1130
  }
},
{
  "model": "cards.cardtag",
  "pk": 1026,
  "fields": {
    "card": 164,
    "tag": 447
  }
},
{
  "model": "cards.cardtag",
  "pk": 1027,
  "fields": {
    "card": 164,
    "tag": 871
  }
},
{
  "model": "cards.cardtag",
  "pk": 1028,
  "fields": {
    "card": 164,
    "tag": 253
  }
},
{
  "model": "cards.cardtag",
  "pk": 1029,
  "fields": {
    "card": 164,
    "tag": 1005
  }
},
{
  "model": "cards.cardtag",
  "pk": 1030,
  "fields": {
    "card": 164,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1031,
  "fields": {
    "card": 165,
    "tag": 1062
  }
},
{
  "model": "cards.cardtag",
  "pk": 1032,
  "fields": {
    "card": 165,
    "tag": 538
  }
},
{
  "model": "cards.cardtag",
  "pk": 1033,
  "fields": {
    "card": 165,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1034,
  "fields": {
    "card": 165,
    "tag": 800
  }
},
{
  "model": "cards.cardtag",
  "pk": 1035,
  "fields": {
    "card": 165,
    "tag": 1310
  }
},
{
  "model": "cards.cardtag",
  "pk": 1036,
  "fields": {
    "card": 166,
    "tag": 868
  }
},
{
  "model": "cards.cardtag",
  "pk": 1037,
  "fields": {
    "card": 166,
    "tag": 1064
  }
},
{
  "model": "cards.cardtag",
  "pk": 1038,
  "fields": {
    "card": 166,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1039,
  "fields": {
    "card": 166,
    "tag": 111
  }
},
{
  "model": "cards.cardtag",
  "pk": 1040,
  "fields": {
    "card": 166,
    "tag": 937
  }
},
{
  "model": "cards.cardtag",
  "pk": 1041,
  "fields": {
    "card": 166,
    "tag": 522
  }
},
{
  "model": "cards.cardtag",
  "pk": 1042,
  "fields": {
    "card": 167,
    "tag": 255
  }
},
{
  "model": "cards.cardtag",
  "pk": 1043,
  "fields": {
    "card": 167,
    "tag": 554
  }
},
{
  "model": "cards.cardtag",
  "pk": 1044,
  "fields": {
    "card": 167,
    "tag": 415
  }
},
{
  "model": "cards.cardtag",
  "pk": 1045,
  "fields": {
    "card": 167,
    "tag": 1130
  }
},
{
  "model": "cards.cardtag",
  "pk": 1046,
  "fields": {
    "card": 167,
    "tag": 253
  }
},
{
  "model": "cards.cardtag",
  "pk": 1047,
  "fields": {
    "card": 167,
    "tag": 1005
  }
},
{
  "model": "cards.cardtag",
  "pk": 1048,
  "fields": {
    "card": 167,
    "tag": 906
  }
},
{
  "model": "cards.cardtag",
  "pk": 1049,
  "fields": {
    "card": 167,
    "tag": 457
  }
},
{
  "model": "cards.cardtag",
  "pk": 1050,
  "fields": {
    "card": 167,
    "tag": 459
  }
},
{
  "model": "cards.cardtag",
  "pk": 1051,
  "fields": {
    "card": 167,
    "tag": 493
  }
},
{
  "model": "cards.cardtag",
  "pk": 1052,
  "fields": {
    "card": 167,
    "tag": 154
  }
},
{
  "model": "cards.cardtag",
  "pk": 1053,
  "fields": {
    "card": 167,
    "tag": 1338
  }
},
{
  "model": "cards.cardtag",
  "pk": 1054,
  "fields": {
    "card": 167,
    "tag": 575
  }
},
{
  "model": "cards.cardtag",
  "pk": 1055,
  "fields": {
    "card": 167,
    "tag": 61
  }
},
{
  "model": "cards.cardtag",
  "pk": 1056,
  "fields": {
    "card": 168,
    "tag": 622
  }
},
{
  "model": "cards.cardtag",
  "pk": 1057,
  "fields": {
    "card": 168,
    "tag": 1332
  }
},
{
  "model": "cards.cardtag",
  "pk": 1058,
  "fields": {
    "card": 168,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1059,
  "fields": {
    "card": 168,
    "tag": 1307
  }
},
{
  "model": "cards.cardtag",
  "pk": 1060,
  "fields": {
    "card": 168,
    "tag": 81
  }
},
{
  "model": "cards.cardtag",
  "pk": 1061,
  "fields": {
    "card": 168,
    "tag": 732
  }
},
{
  "model": "cards.cardtag",
  "pk": 1062,
  "fields": {
    "card": 169,
    "tag": 683
  }
},
{
  "model": "cards.cardtag",
  "pk": 1063,
  "fields": {
    "card": 169,
    "tag": 1272
  }
},
{
  "model": "cards.cardtag",
  "pk": 1064,
  "fields": {
    "card": 169,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1065,
  "fields": {
    "card": 169,
    "tag": 706
  }
},
{
  "model": "cards.cardtag",
  "pk": 1066,
  "fields": {
    "card": 169,
    "tag": 266
  }
},
{
  "model": "cards.cardtag",
  "pk": 1067,
  "fields": {
    "card": 169,
    "tag": 904
  }
},
{
  "model": "cards.cardtag",
  "pk": 1068,
  "fields": {
    "card": 169,
    "tag": 663
  }
},
{
  "model": "cards.cardtag",
  "pk": 1069,
  "fields": {
    "card": 170,
    "tag": 1077
  }
},
{
  "model": "cards.cardtag",
  "pk": 1070,
  "fields": {
    "card": 170,
    "tag": 266
  }
},
{
  "model": "cards.cardtag",
  "pk": 1071,
  "fields": {
    "card": 170,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1072,
  "fields": {
    "card": 170,
    "tag": 13
  }
},
{
  "model": "cards.cardtag",
  "pk": 1073,
  "fields": {
    "card": 170,
    "tag": 986
  }
},
{
  "model": "cards.cardtag",
  "pk": 1074,
  "fields": {
    "card": 170,
    "tag": 506
  }
},
{
  "model": "cards.cardtag",
  "pk": 1075,
  "fields": {
    "card": 171,
    "tag": 1180
  }
},
{
  "model": "cards.cardtag",
  "pk": 1076,
  "fields": {
    "card": 171,
    "tag": 788
  }
},
{
  "model": "cards.cardtag",
  "pk": 1077,
  "fields": {
    "card": 171,
    "tag": 1143
  }
},
{
  "model": "cards.cardtag",
  "pk": 1078,
  "fields": {
    "card": 171,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1079,
  "fields": {
    "card": 171,
    "tag": 1308
  }
},
{
  "model": "cards.cardtag",
  "pk": 1080,
  "fields": {
    "card": 171,
    "tag": 215
  }
},
{
  "model": "cards.cardtag",
  "pk": 1081,
  "fields": {
    "card": 171,
    "tag": 1356
  }
},
{
  "model": "cards.cardtag",
  "pk": 1082,
  "fields": {
    "card": 172,
    "tag": 416
  }
},
{
  "model": "cards.cardtag",
  "pk": 1083,
  "fields": {
    "card": 172,
    "tag": 1062
  }
},
{
  "model": "cards.cardtag",
  "pk": 1084,
  "fields": {
    "card": 172,
    "tag": 756
  }
},
{
  "model": "cards.cardtag",
  "pk": 1085,
  "fields": {
    "card": 172,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1086,
  "fields": {
    "card": 172,
    "tag": 586
  }
},
{
  "model": "cards.cardtag",
  "pk": 1087,
  "fields": {
    "card": 172,
    "tag": 505
  }
},
{
  "model": "cards.cardtag",
  "pk": 1088,
  "fields": {
    "card": 173,
    "tag": 817
  }
},
{
  "model": "cards.cardtag",
  "pk": 1089,
  "fields": {
    "card": 173,
    "tag": 1095
  }
},
{
  "model": "cards.cardtag",
  "pk": 1090,
  "fields": {
    "card": 173,
    "tag": 1286
  }
},
{
  "model": "cards.cardtag",
  "pk": 1091,
  "fields": {
    "card": 173,
    "tag": 766
  }
},
{
  "model": "cards.cardtag",
  "pk": 1092,
  "fields": {
    "card": 173,
    "tag": 290
  }
},
{
  "model": "cards.cardtag",
  "pk": 1093,
  "fields": {
    "card": 173,
    "tag": 589
  }
},
{
  "model": "cards.cardtag",
  "pk": 1094,
  "fields": {
    "card": 173,
    "tag": 677
  }
},
{
  "model": "cards.cardtag",
  "pk": 1095,
  "fields": {
    "card": 173,
    "tag": 807
  }
},
{
  "model": "cards.cardtag",
  "pk": 1096,
  "fields": {
    "card": 173,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1097,
  "fields": {
    "card": 174,
    "tag": 910
  }
},
{
  "model": "cards.cardtag",
  "pk": 1098,
  "fields": {
    "card": 174,
    "tag": 766
  }
},
{
  "model": "cards.cardtag",
  "pk": 1099,
  "fields": {
    "card": 174,
    "tag": 1218
  }
},
{
  "model": "cards.cardtag",
  "pk": 1100,
  "fields": {
    "card": 174,
    "tag": 412
  }
},
{
  "model": "cards.cardtag",
  "pk": 1101,
  "fields": {
    "card": 174,
    "tag": 1106
  }
},
{
  "model": "cards.cardtag",
  "pk": 1102,
  "fields": {
    "card": 174,
    "tag": 774
  }
},
{
  "model": "cards.cardtag",
  "pk": 1103,
  "fields": {
    "card": 175,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1104,
  "fields": {
    "card": 175,
    "tag": 774
  }
},
{
  "model": "cards.cardtag",
  "pk": 1105,
  "fields": {
    "card": 175,
    "tag": 766
  }
},
{
  "model": "cards.cardtag",
  "pk": 1106,
  "fields": {
    "card": 175,
    "tag": 412
  }
},
{
  "model": "cards.cardtag",
  "pk": 1107,
  "fields": {
    "card": 175,
    "tag": 1062
  }
},
{
  "model": "cards.cardtag",
  "pk": 1108,
  "fields": {
    "card": 176,
    "tag": 331
  }
},
{
  "model": "cards.cardtag",
  "pk": 1109,
  "fields": {
    "card": 176,
    "tag": 219
  }
},
{
  "model": "cards.cardtag",
  "pk": 1110,
  "fields": {
    "card": 176,
    "tag": 1293
  }
},
{
  "model": "cards.cardtag",
  "pk": 1111,
  "fields": {
    "card": 176,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1112,
  "fields": {
    "card": 176,
    "tag": 44
  }
},
{
  "model": "cards.cardtag",
  "pk": 1113,
  "fields": {
    "card": 176,
    "tag": 412
  }
},
{
  "model": "cards.cardtag",
  "pk": 1114,
  "fields": {
    "card": 177,
    "tag": 1112
  }
},
{
  "model": "cards.cardtag",
  "pk": 1115,
  "fields": {
    "card": 177,
    "tag": 712
  }
},
{
  "model": "cards.cardtag",
  "pk": 1116,
  "fields": {
    "card": 177,
    "tag": 1194
  }
},
{
  "model": "cards.cardtag",
  "pk": 1117,
  "fields": {
    "card": 177,
    "tag": 246
  }
},
{
  "model": "cards.cardtag",
  "pk": 1118,
  "fields": {
    "card": 177,
    "tag": 118
  }
},
{
  "model": "cards.cardtag",
  "pk": 1119,
  "fields": {
    "card": 177,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1120,
  "fields": {
    "card": 177,
    "tag": 1212
  }
},
{
  "model": "cards.cardtag",
  "pk": 1121,
  "fields": {
    "card": 178,
    "tag": 710
  }
},
{
  "model": "cards.cardtag",
  "pk": 1122,
  "fields": {
    "card": 178,
    "tag": 515
  }
},
{
  "model": "cards.cardtag",
  "pk": 1123,
  "fields": {
    "card": 178,
    "tag": 747
  }
},
{
  "model": "cards.cardtag",
  "pk": 1124,
  "fields": {
    "card": 178,
    "tag": 521
  }
},
{
  "model": "cards.cardtag",
  "pk": 1125,
  "fields": {
    "card": 178,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1126,
  "fields": {
    "card": 178,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 1127,
  "fields": {
    "card": 179,
    "tag": 716
  }
},
{
  "model": "cards.cardtag",
  "pk": 1128,
  "fields": {
    "card": 179,
    "tag": 626
  }
},
{
  "model": "cards.cardtag",
  "pk": 1129,
  "fields": {
    "card": 179,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1130,
  "fields": {
    "card": 179,
    "tag": 1054
  }
},
{
  "model": "cards.cardtag",
  "pk": 1131,
  "fields": {
    "card": 179,
    "tag": 1167
  }
},
{
  "model": "cards.cardtag",
  "pk": 1132,
  "fields": {
    "card": 179,
    "tag": 1365
  }
},
{
  "model": "cards.cardtag",
  "pk": 1133,
  "fields": {
    "card": 180,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1134,
  "fields": {
    "card": 180,
    "tag": 971
  }
},
{
  "model": "cards.cardtag",
  "pk": 1135,
  "fields": {
    "card": 180,
    "tag": 605
  }
},
{
  "model": "cards.cardtag",
  "pk": 1136,
  "fields": {
    "card": 180,
    "tag": 111
  }
},
{
  "model": "cards.cardtag",
  "pk": 1137,
  "fields": {
    "card": 180,
    "tag": 841
  }
},
{
  "model": "cards.cardtag",
  "pk": 1138,
  "fields": {
    "card": 181,
    "tag": 111
  }
},
{
  "model": "cards.cardtag",
  "pk": 1139,
  "fields": {
    "card": 181,
    "tag": 1061
  }
},
{
  "model": "cards.cardtag",
  "pk": 1140,
  "fields": {
    "card": 181,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1141,
  "fields": {
    "card": 181,
    "tag": 971
  }
},
{
  "model": "cards.cardtag",
  "pk": 1142,
  "fields": {
    "card": 181,
    "tag": 509
  }
},
{
  "model": "cards.cardtag",
  "pk": 1143,
  "fields": {
    "card": 181,
    "tag": 1203
  }
},
{
  "model": "cards.cardtag",
  "pk": 1144,
  "fields": {
    "card": 182,
    "tag": 382
  }
},
{
  "model": "cards.cardtag",
  "pk": 1145,
  "fields": {
    "card": 182,
    "tag": 1279
  }
},
{
  "model": "cards.cardtag",
  "pk": 1146,
  "fields": {
    "card": 182,
    "tag": 1273
  }
},
{
  "model": "cards.cardtag",
  "pk": 1147,
  "fields": {
    "card": 182,
    "tag": 732
  }
},
{
  "model": "cards.cardtag",
  "pk": 1148,
  "fields": {
    "card": 182,
    "tag": 501
  }
},
{
  "model": "cards.cardtag",
  "pk": 1149,
  "fields": {
    "card": 182,
    "tag": 683
  }
},
{
  "model": "cards.cardtag",
  "pk": 1150,
  "fields": {
    "card": 182,
    "tag": 612
  }
},
{
  "model": "cards.cardtag",
  "pk": 1151,
  "fields": {
    "card": 182,
    "tag": 817
  }
},
{
  "model": "cards.cardtag",
  "pk": 1152,
  "fields": {
    "card": 183,
    "tag": 659
  }
},
{
  "model": "cards.cardtag",
  "pk": 1153,
  "fields": {
    "card": 183,
    "tag": 882
  }
},
{
  "model": "cards.cardtag",
  "pk": 1154,
  "fields": {
    "card": 183,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1155,
  "fields": {
    "card": 183,
    "tag": 219
  }
},
{
  "model": "cards.cardtag",
  "pk": 1156,
  "fields": {
    "card": 183,
    "tag": 292
  }
},
{
  "model": "cards.cardtag",
  "pk": 1157,
  "fields": {
    "card": 183,
    "tag": 128
  }
},
{
  "model": "cards.cardtag",
  "pk": 1158,
  "fields": {
    "card": 184,
    "tag": 240
  }
},
{
  "model": "cards.cardtag",
  "pk": 1159,
  "fields": {
    "card": 184,
    "tag": 646
  }
},
{
  "model": "cards.cardtag",
  "pk": 1160,
  "fields": {
    "card": 184,
    "tag": 772
  }
},
{
  "model": "cards.cardtag",
  "pk": 1161,
  "fields": {
    "card": 184,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1162,
  "fields": {
    "card": 184,
    "tag": 879
  }
},
{
  "model": "cards.cardtag",
  "pk": 1163,
  "fields": {
    "card": 184,
    "tag": 313
  }
},
{
  "model": "cards.cardtag",
  "pk": 1164,
  "fields": {
    "card": 185,
    "tag": 1177
  }
},
{
  "model": "cards.cardtag",
  "pk": 1165,
  "fields": {
    "card": 185,
    "tag": 164
  }
},
{
  "model": "cards.cardtag",
  "pk": 1166,
  "fields": {
    "card": 185,
    "tag": 468
  }
},
{
  "model": "cards.cardtag",
  "pk": 1167,
  "fields": {
    "card": 185,
    "tag": 681
  }
},
{
  "model": "cards.cardtag",
  "pk": 1168,
  "fields": {
    "card": 185,
    "tag": 846
  }
},
{
  "model": "cards.cardtag",
  "pk": 1169,
  "fields": {
    "card": 185,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1170,
  "fields": {
    "card": 186,
    "tag": 1302
  }
},
{
  "model": "cards.cardtag",
  "pk": 1171,
  "fields": {
    "card": 186,
    "tag": 1253
  }
},
{
  "model": "cards.cardtag",
  "pk": 1172,
  "fields": {
    "card": 186,
    "tag": 1051
  }
},
{
  "model": "cards.cardtag",
  "pk": 1173,
  "fields": {
    "card": 186,
    "tag": 210
  }
},
{
  "model": "cards.cardtag",
  "pk": 1174,
  "fields": {
    "card": 186,
    "tag": 60
  }
},
{
  "model": "cards.cardtag",
  "pk": 1175,
  "fields": {
    "card": 186,
    "tag": 755
  }
},
{
  "model": "cards.cardtag",
  "pk": 1176,
  "fields": {
    "card": 187,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1177,
  "fields": {
    "card": 187,
    "tag": 609
  }
},
{
  "model": "cards.cardtag",
  "pk": 1178,
  "fields": {
    "card": 187,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 1179,
  "fields": {
    "card": 187,
    "tag": 941
  }
},
{
  "model": "cards.cardtag",
  "pk": 1180,
  "fields": {
    "card": 187,
    "tag": 312
  }
},
{
  "model": "cards.cardtag",
  "pk": 1181,
  "fields": {
    "card": 187,
    "tag": 308
  }
},
{
  "model": "cards.cardtag",
  "pk": 1182,
  "fields": {
    "card": 188,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1183,
  "fields": {
    "card": 188,
    "tag": 172
  }
},
{
  "model": "cards.cardtag",
  "pk": 1184,
  "fields": {
    "card": 188,
    "tag": 527
  }
},
{
  "model": "cards.cardtag",
  "pk": 1185,
  "fields": {
    "card": 188,
    "tag": 1065
  }
},
{
  "model": "cards.cardtag",
  "pk": 1186,
  "fields": {
    "card": 188,
    "tag": 423
  }
},
{
  "model": "cards.cardtag",
  "pk": 1187,
  "fields": {
    "card": 188,
    "tag": 111
  }
},
{
  "model": "cards.cardtag",
  "pk": 1188,
  "fields": {
    "card": 189,
    "tag": 928
  }
},
{
  "model": "cards.cardtag",
  "pk": 1189,
  "fields": {
    "card": 189,
    "tag": 361
  }
},
{
  "model": "cards.cardtag",
  "pk": 1190,
  "fields": {
    "card": 189,
    "tag": 581
  }
},
{
  "model": "cards.cardtag",
  "pk": 1191,
  "fields": {
    "card": 189,
    "tag": 722
  }
},
{
  "model": "cards.cardtag",
  "pk": 1192,
  "fields": {
    "card": 189,
    "tag": 250
  }
},
{
  "model": "cards.cardtag",
  "pk": 1193,
  "fields": {
    "card": 189,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1194,
  "fields": {
    "card": 190,
    "tag": 1062
  }
},
{
  "model": "cards.cardtag",
  "pk": 1195,
  "fields": {
    "card": 190,
    "tag": 712
  }
},
{
  "model": "cards.cardtag",
  "pk": 1196,
  "fields": {
    "card": 190,
    "tag": 756
  }
},
{
  "model": "cards.cardtag",
  "pk": 1197,
  "fields": {
    "card": 190,
    "tag": 894
  }
},
{
  "model": "cards.cardtag",
  "pk": 1198,
  "fields": {
    "card": 190,
    "tag": 1015
  }
},
{
  "model": "cards.cardtag",
  "pk": 1199,
  "fields": {
    "card": 190,
    "tag": 527
  }
},
{
  "model": "cards.cardtag",
  "pk": 1200,
  "fields": {
    "card": 191,
    "tag": 1003
  }
},
{
  "model": "cards.cardtag",
  "pk": 1201,
  "fields": {
    "card": 191,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1202,
  "fields": {
    "card": 191,
    "tag": 1395
  }
},
{
  "model": "cards.cardtag",
  "pk": 1203,
  "fields": {
    "card": 191,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 1204,
  "fields": {
    "card": 191,
    "tag": 297
  }
},
{
  "model": "cards.cardtag",
  "pk": 1205,
  "fields": {
    "card": 191,
    "tag": 884
  }
},
{
  "model": "cards.cardtag",
  "pk": 1206,
  "fields": {
    "card": 192,
    "tag": 1363
  }
},
{
  "model": "cards.cardtag",
  "pk": 1207,
  "fields": {
    "card": 192,
    "tag": 404
  }
},
{
  "model": "cards.cardtag",
  "pk": 1208,
  "fields": {
    "card": 192,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1209,
  "fields": {
    "card": 192,
    "tag": 569
  }
},
{
  "model": "cards.cardtag",
  "pk": 1210,
  "fields": {
    "card": 192,
    "tag": 1357
  }
},
{
  "model": "cards.cardtag",
  "pk": 1211,
  "fields": {
    "card": 192,
    "tag": 712
  }
},
{
  "model": "cards.cardtag",
  "pk": 1212,
  "fields": {
    "card": 193,
    "tag": 991
  }
},
{
  "model": "cards.cardtag",
  "pk": 1213,
  "fields": {
    "card": 193,
    "tag": 839
  }
},
{
  "model": "cards.cardtag",
  "pk": 1214,
  "fields": {
    "card": 193,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1215,
  "fields": {
    "card": 193,
    "tag": 620
  }
},
{
  "model": "cards.cardtag",
  "pk": 1216,
  "fields": {
    "card": 193,
    "tag": 1347
  }
},
{
  "model": "cards.cardtag",
  "pk": 1217,
  "fields": {
    "card": 193,
    "tag": 185
  }
},
{
  "model": "cards.cardtag",
  "pk": 1218,
  "fields": {
    "card": 194,
    "tag": 571
  }
},
{
  "model": "cards.cardtag",
  "pk": 1219,
  "fields": {
    "card": 194,
    "tag": 286
  }
},
{
  "model": "cards.cardtag",
  "pk": 1220,
  "fields": {
    "card": 194,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 1221,
  "fields": {
    "card": 194,
    "tag": 724
  }
},
{
  "model": "cards.cardtag",
  "pk": 1222,
  "fields": {
    "card": 194,
    "tag": 1296
  }
},
{
  "model": "cards.cardtag",
  "pk": 1223,
  "fields": {
    "card": 194,
    "tag": 67
  }
},
{
  "model": "cards.cardtag",
  "pk": 1224,
  "fields": {
    "card": 194,
    "tag": 675
  }
},
{
  "model": "cards.cardtag",
  "pk": 1225,
  "fields": {
    "card": 194,
    "tag": 935
  }
},
{
  "model": "cards.cardtag",
  "pk": 1226,
  "fields": {
    "card": 195,
    "tag": 226
  }
},
{
  "model": "cards.cardtag",
  "pk": 1227,
  "fields": {
    "card": 195,
    "tag": 942
  }
},
{
  "model": "cards.cardtag",
  "pk": 1228,
  "fields": {
    "card": 195,
    "tag": 1147
  }
},
{
  "model": "cards.cardtag",
  "pk": 1229,
  "fields": {
    "card": 195,
    "tag": 803
  }
},
{
  "model": "cards.cardtag",
  "pk": 1230,
  "fields": {
    "card": 195,
    "tag": 1103
  }
},
{
  "model": "cards.cardtag",
  "pk": 1231,
  "fields": {
    "card": 195,
    "tag": 180
  }
},
{
  "model": "cards.cardtag",
  "pk": 1232,
  "fields": {
    "card": 195,
    "tag": 448
  }
},
{
  "model": "cards.cardtag",
  "pk": 1233,
  "fields": {
    "card": 195,
    "tag": 955
  }
},
{
  "model": "cards.cardtag",
  "pk": 1234,
  "fields": {
    "card": 196,
    "tag": 355
  }
},
{
  "model": "cards.cardtag",
  "pk": 1235,
  "fields": {
    "card": 196,
    "tag": 226
  }
},
{
  "model": "cards.cardtag",
  "pk": 1236,
  "fields": {
    "card": 196,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1237,
  "fields": {
    "card": 196,
    "tag": 243
  }
},
{
  "model": "cards.cardtag",
  "pk": 1238,
  "fields": {
    "card": 196,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 1239,
  "fields": {
    "card": 196,
    "tag": 578
  }
},
{
  "model": "cards.cardtag",
  "pk": 1240,
  "fields": {
    "card": 197,
    "tag": 849
  }
},
{
  "model": "cards.cardtag",
  "pk": 1241,
  "fields": {
    "card": 197,
    "tag": 1081
  }
},
{
  "model": "cards.cardtag",
  "pk": 1242,
  "fields": {
    "card": 197,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1243,
  "fields": {
    "card": 197,
    "tag": 562
  }
},
{
  "model": "cards.cardtag",
  "pk": 1244,
  "fields": {
    "card": 197,
    "tag": 55
  }
},
{
  "model": "cards.cardtag",
  "pk": 1245,
  "fields": {
    "card": 198,
    "tag": 836
  }
},
{
  "model": "cards.cardtag",
  "pk": 1246,
  "fields": {
    "card": 198,
    "tag": 1395
  }
},
{
  "model": "cards.cardtag",
  "pk": 1247,
  "fields": {
    "card": 198,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1248,
  "fields": {
    "card": 198,
    "tag": 411
  }
},
{
  "model": "cards.cardtag",
  "pk": 1249,
  "fields": {
    "card": 198,
    "tag": 38
  }
},
{
  "model": "cards.cardtag",
  "pk": 1250,
  "fields": {
    "card": 199,
    "tag": 386
  }
},
{
  "model": "cards.cardtag",
  "pk": 1251,
  "fields": {
    "card": 199,
    "tag": 1313
  }
},
{
  "model": "cards.cardtag",
  "pk": 1252,
  "fields": {
    "card": 199,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 1253,
  "fields": {
    "card": 199,
    "tag": 22
  }
},
{
  "model": "cards.cardtag",
  "pk": 1254,
  "fields": {
    "card": 199,
    "tag": 1393
  }
},
{
  "model": "cards.cardtag",
  "pk": 1255,
  "fields": {
    "card": 199,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1256,
  "fields": {
    "card": 200,
    "tag": 770
  }
},
{
  "model": "cards.cardtag",
  "pk": 1257,
  "fields": {
    "card": 200,
    "tag": 1069
  }
},
{
  "model": "cards.cardtag",
  "pk": 1258,
  "fields": {
    "card": 200,
    "tag": 2
  }
},
{
  "model": "cards.cardtag",
  "pk": 1259,
  "fields": {
    "card": 200,
    "tag": 1146
  }
},
{
  "model": "cards.cardtag",
  "pk": 1260,
  "fields": {
    "card": 200,
    "tag": 830
  }
},
{
  "model": "cards.cardtag",
  "pk": 1261,
  "fields": {
    "card": 200,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1262,
  "fields": {
    "card": 201,
    "tag": 1121
  }
},
{
  "model": "cards.cardtag",
  "pk": 1263,
  "fields": {
    "card": 201,
    "tag": 520
  }
},
{
  "model": "cards.cardtag",
  "pk": 1264,
  "fields": {
    "card": 201,
    "tag": 32
  }
},
{
  "model": "cards.cardtag",
  "pk": 1265,
  "fields": {
    "card": 201,
    "tag": 1290
  }
},
{
  "model": "cards.cardtag",
  "pk": 1266,
  "fields": {
    "card": 201,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1267,
  "fields": {
    "card": 201,
    "tag": 613
  }
},
{
  "model": "cards.cardtag",
  "pk": 1268,
  "fields": {
    "card": 202,
    "tag": 1053
  }
},
{
  "model": "cards.cardtag",
  "pk": 1269,
  "fields": {
    "card": 202,
    "tag": 1164
  }
},
{
  "model": "cards.cardtag",
  "pk": 1270,
  "fields": {
    "card": 202,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1271,
  "fields": {
    "card": 202,
    "tag": 226
  }
},
{
  "model": "cards.cardtag",
  "pk": 1272,
  "fields": {
    "card": 202,
    "tag": 1186
  }
},
{
  "model": "cards.cardtag",
  "pk": 1273,
  "fields": {
    "card": 202,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 1274,
  "fields": {
    "card": 203,
    "tag": 410
  }
},
{
  "model": "cards.cardtag",
  "pk": 1275,
  "fields": {
    "card": 203,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1276,
  "fields": {
    "card": 203,
    "tag": 412
  }
},
{
  "model": "cards.cardtag",
  "pk": 1277,
  "fields": {
    "card": 203,
    "tag": 468
  }
},
{
  "model": "cards.cardtag",
  "pk": 1278,
  "fields": {
    "card": 203,
    "tag": 1042
  }
},
{
  "model": "cards.cardtag",
  "pk": 1279,
  "fields": {
    "card": 203,
    "tag": 526
  }
},
{
  "model": "cards.cardtag",
  "pk": 1280,
  "fields": {
    "card": 204,
    "tag": 1049
  }
},
{
  "model": "cards.cardtag",
  "pk": 1281,
  "fields": {
    "card": 204,
    "tag": 462
  }
},
{
  "model": "cards.cardtag",
  "pk": 1282,
  "fields": {
    "card": 204,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1283,
  "fields": {
    "card": 204,
    "tag": 904
  }
},
{
  "model": "cards.cardtag",
  "pk": 1284,
  "fields": {
    "card": 204,
    "tag": 1022
  }
},
{
  "model": "cards.cardtag",
  "pk": 1285,
  "fields": {
    "card": 205,
    "tag": 48
  }
},
{
  "model": "cards.cardtag",
  "pk": 1286,
  "fields": {
    "card": 205,
    "tag": 1395
  }
},
{
  "model": "cards.cardtag",
  "pk": 1287,
  "fields": {
    "card": 205,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1288,
  "fields": {
    "card": 205,
    "tag": 226
  }
},
{
  "model": "cards.cardtag",
  "pk": 1289,
  "fields": {
    "card": 205,
    "tag": 375
  }
},
{
  "model": "cards.cardtag",
  "pk": 1290,
  "fields": {
    "card": 205,
    "tag": 827
  }
},
{
  "model": "cards.cardtag",
  "pk": 1291,
  "fields": {
    "card": 206,
    "tag": 270
  }
},
{
  "model": "cards.cardtag",
  "pk": 1292,
  "fields": {
    "card": 206,
    "tag": 796
  }
},
{
  "model": "cards.cardtag",
  "pk": 1293,
  "fields": {
    "card": 206,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1294,
  "fields": {
    "card": 206,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 1295,
  "fields": {
    "card": 206,
    "tag": 897
  }
},
{
  "model": "cards.cardtag",
  "pk": 1296,
  "fields": {
    "card": 206,
    "tag": 1128
  }
},
{
  "model": "cards.cardtag",
  "pk": 1297,
  "fields": {
    "card": 206,
    "tag": 1395
  }
},
{
  "model": "cards.cardtag",
  "pk": 1298,
  "fields": {
    "card": 206,
    "tag": 1050
  }
},
{
  "model": "cards.cardtag",
  "pk": 1299,
  "fields": {
    "card": 207,
    "tag": 1341
  }
},
{
  "model": "cards.cardtag",
  "pk": 1300,
  "fields": {
    "card": 207,
    "tag": 394
  }
},
{
  "model": "cards.cardtag",
  "pk": 1301,
  "fields": {
    "card": 207,
    "tag": 1062
  }
},
{
  "model": "cards.cardtag",
  "pk": 1302,
  "fields": {
    "card": 207,
    "tag": 897
  }
},
{
  "model": "cards.cardtag",
  "pk": 1303,
  "fields": {
    "card": 207,
    "tag": 712
  }
},
{
  "model": "cards.cardtag",
  "pk": 1304,
  "fields": {
    "card": 207,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1305,
  "fields": {
    "card": 208,
    "tag": 550
  }
},
{
  "model": "cards.cardtag",
  "pk": 1306,
  "fields": {
    "card": 208,
    "tag": 1302
  }
},
{
  "model": "cards.cardtag",
  "pk": 1307,
  "fields": {
    "card": 208,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1308,
  "fields": {
    "card": 208,
    "tag": 1067
  }
},
{
  "model": "cards.cardtag",
  "pk": 1309,
  "fields": {
    "card": 208,
    "tag": 595
  }
},
{
  "model": "cards.cardtag",
  "pk": 1310,
  "fields": {
    "card": 208,
    "tag": 1356
  }
},
{
  "model": "cards.cardtag",
  "pk": 1311,
  "fields": {
    "card": 209,
    "tag": 412
  }
},
{
  "model": "cards.cardtag",
  "pk": 1312,
  "fields": {
    "card": 209,
    "tag": 568
  }
},
{
  "model": "cards.cardtag",
  "pk": 1313,
  "fields": {
    "card": 209,
    "tag": 1084
  }
},
{
  "model": "cards.cardtag",
  "pk": 1314,
  "fields": {
    "card": 209,
    "tag": 472
  }
},
{
  "model": "cards.cardtag",
  "pk": 1315,
  "fields": {
    "card": 209,
    "tag": 71
  }
},
{
  "model": "cards.cardtag",
  "pk": 1316,
  "fields": {
    "card": 209,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1317,
  "fields": {
    "card": 210,
    "tag": 262
  }
},
{
  "model": "cards.cardtag",
  "pk": 1318,
  "fields": {
    "card": 210,
    "tag": 327
  }
},
{
  "model": "cards.cardtag",
  "pk": 1319,
  "fields": {
    "card": 210,
    "tag": 808
  }
},
{
  "model": "cards.cardtag",
  "pk": 1320,
  "fields": {
    "card": 210,
    "tag": 940
  }
},
{
  "model": "cards.cardtag",
  "pk": 1321,
  "fields": {
    "card": 210,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1322,
  "fields": {
    "card": 210,
    "tag": 111
  }
},
{
  "model": "cards.cardtag",
  "pk": 1323,
  "fields": {
    "card": 211,
    "tag": 933
  }
},
{
  "model": "cards.cardtag",
  "pk": 1324,
  "fields": {
    "card": 211,
    "tag": 1387
  }
},
{
  "model": "cards.cardtag",
  "pk": 1325,
  "fields": {
    "card": 211,
    "tag": 106
  }
},
{
  "model": "cards.cardtag",
  "pk": 1326,
  "fields": {
    "card": 211,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1327,
  "fields": {
    "card": 211,
    "tag": 396
  }
},
{
  "model": "cards.cardtag",
  "pk": 1328,
  "fields": {
    "card": 211,
    "tag": 1225
  }
},
{
  "model": "cards.cardtag",
  "pk": 1329,
  "fields": {
    "card": 212,
    "tag": 687
  }
},
{
  "model": "cards.cardtag",
  "pk": 1330,
  "fields": {
    "card": 212,
    "tag": 1269
  }
},
{
  "model": "cards.cardtag",
  "pk": 1331,
  "fields": {
    "card": 212,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1332,
  "fields": {
    "card": 212,
    "tag": 722
  }
},
{
  "model": "cards.cardtag",
  "pk": 1333,
  "fields": {
    "card": 212,
    "tag": 1300
  }
},
{
  "model": "cards.cardtag",
  "pk": 1334,
  "fields": {
    "card": 212,
    "tag": 477
  }
},
{
  "model": "cards.cardtag",
  "pk": 1335,
  "fields": {
    "card": 213,
    "tag": 712
  }
},
{
  "model": "cards.cardtag",
  "pk": 1336,
  "fields": {
    "card": 213,
    "tag": 297
  }
},
{
  "model": "cards.cardtag",
  "pk": 1337,
  "fields": {
    "card": 213,
    "tag": 420
  }
},
{
  "model": "cards.cardtag",
  "pk": 1338,
  "fields": {
    "card": 213,
    "tag": 594
  }
},
{
  "model": "cards.cardtag",
  "pk": 1339,
  "fields": {
    "card": 213,
    "tag": 1378
  }
},
{
  "model": "cards.cardtag",
  "pk": 1340,
  "fields": {
    "card": 213,
    "tag": 1363
  }
},
{
  "model": "cards.cardtag",
  "pk": 1341,
  "fields": {
    "card": 213,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1342,
  "fields": {
    "card": 214,
    "tag": 131
  }
},
{
  "model": "cards.cardtag",
  "pk": 1343,
  "fields": {
    "card": 214,
    "tag": 285
  }
},
{
  "model": "cards.cardtag",
  "pk": 1344,
  "fields": {
    "card": 214,
    "tag": 484
  }
},
{
  "model": "cards.cardtag",
  "pk": 1345,
  "fields": {
    "card": 214,
    "tag": 238
  }
},
{
  "model": "cards.cardtag",
  "pk": 1346,
  "fields": {
    "card": 214,
    "tag": 968
  }
},
{
  "model": "cards.cardtag",
  "pk": 1347,
  "fields": {
    "card": 214,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1348,
  "fields": {
    "card": 215,
    "tag": 966
  }
},
{
  "model": "cards.cardtag",
  "pk": 1349,
  "fields": {
    "card": 215,
    "tag": 712
  }
},
{
  "model": "cards.cardtag",
  "pk": 1350,
  "fields": {
    "card": 215,
    "tag": 97
  }
},
{
  "model": "cards.cardtag",
  "pk": 1351,
  "fields": {
    "card": 215,
    "tag": 804
  }
},
{
  "model": "cards.cardtag",
  "pk": 1352,
  "fields": {
    "card": 215,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1353,
  "fields": {
    "card": 215,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 1354,
  "fields": {
    "card": 216,
    "tag": 1194
  }
},
{
  "model": "cards.cardtag",
  "pk": 1355,
  "fields": {
    "card": 216,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1356,
  "fields": {
    "card": 216,
    "tag": 1249
  }
},
{
  "model": "cards.cardtag",
  "pk": 1357,
  "fields": {
    "card": 216,
    "tag": 6
  }
},
{
  "model": "cards.cardtag",
  "pk": 1358,
  "fields": {
    "card": 216,
    "tag": 1219
  }
},
{
  "model": "cards.cardtag",
  "pk": 1359,
  "fields": {
    "card": 216,
    "tag": 64
  }
},
{
  "model": "cards.cardtag",
  "pk": 1360,
  "fields": {
    "card": 217,
    "tag": 467
  }
},
{
  "model": "cards.cardtag",
  "pk": 1361,
  "fields": {
    "card": 217,
    "tag": 1194
  }
},
{
  "model": "cards.cardtag",
  "pk": 1362,
  "fields": {
    "card": 217,
    "tag": 853
  }
},
{
  "model": "cards.cardtag",
  "pk": 1363,
  "fields": {
    "card": 217,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1364,
  "fields": {
    "card": 217,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 1365,
  "fields": {
    "card": 217,
    "tag": 64
  }
},
{
  "model": "cards.cardtag",
  "pk": 1366,
  "fields": {
    "card": 218,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1367,
  "fields": {
    "card": 218,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 1368,
  "fields": {
    "card": 218,
    "tag": 1062
  }
},
{
  "model": "cards.cardtag",
  "pk": 1369,
  "fields": {
    "card": 218,
    "tag": 400
  }
},
{
  "model": "cards.cardtag",
  "pk": 1370,
  "fields": {
    "card": 218,
    "tag": 897
  }
},
{
  "model": "cards.cardtag",
  "pk": 1371,
  "fields": {
    "card": 218,
    "tag": 769
  }
},
{
  "model": "cards.cardtag",
  "pk": 1372,
  "fields": {
    "card": 219,
    "tag": 473
  }
},
{
  "model": "cards.cardtag",
  "pk": 1373,
  "fields": {
    "card": 219,
    "tag": 225
  }
},
{
  "model": "cards.cardtag",
  "pk": 1374,
  "fields": {
    "card": 219,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1375,
  "fields": {
    "card": 219,
    "tag": 134
  }
},
{
  "model": "cards.cardtag",
  "pk": 1376,
  "fields": {
    "card": 219,
    "tag": 1094
  }
},
{
  "model": "cards.cardtag",
  "pk": 1377,
  "fields": {
    "card": 219,
    "tag": 141
  }
},
{
  "model": "cards.cardtag",
  "pk": 1378,
  "fields": {
    "card": 219,
    "tag": 640
  }
},
{
  "model": "cards.cardtag",
  "pk": 1379,
  "fields": {
    "card": 219,
    "tag": 1076
  }
},
{
  "model": "cards.cardtag",
  "pk": 1380,
  "fields": {
    "card": 220,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1381,
  "fields": {
    "card": 220,
    "tag": 111
  }
},
{
  "model": "cards.cardtag",
  "pk": 1382,
  "fields": {
    "card": 220,
    "tag": 92
  }
},
{
  "model": "cards.cardtag",
  "pk": 1383,
  "fields": {
    "card": 220,
    "tag": 326
  }
},
{
  "model": "cards.cardtag",
  "pk": 1384,
  "fields": {
    "card": 220,
    "tag": 679
  }
},
{
  "model": "cards.cardtag",
  "pk": 1385,
  "fields": {
    "card": 220,
    "tag": 1178
  }
},
{
  "model": "cards.cardtag",
  "pk": 1386,
  "fields": {
    "card": 221,
    "tag": 358
  }
},
{
  "model": "cards.cardtag",
  "pk": 1387,
  "fields": {
    "card": 221,
    "tag": 1297
  }
},
{
  "model": "cards.cardtag",
  "pk": 1388,
  "fields": {
    "card": 221,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1389,
  "fields": {
    "card": 221,
    "tag": 1074
  }
},
{
  "model": "cards.cardtag",
  "pk": 1390,
  "fields": {
    "card": 221,
    "tag": 570
  }
},
{
  "model": "cards.cardtag",
  "pk": 1391,
  "fields": {
    "card": 221,
    "tag": 527
  }
},
{
  "model": "cards.cardtag",
  "pk": 1392,
  "fields": {
    "card": 222,
    "tag": 20
  }
},
{
  "model": "cards.cardtag",
  "pk": 1393,
  "fields": {
    "card": 222,
    "tag": 855
  }
},
{
  "model": "cards.cardtag",
  "pk": 1394,
  "fields": {
    "card": 222,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1395,
  "fields": {
    "card": 222,
    "tag": 712
  }
},
{
  "model": "cards.cardtag",
  "pk": 1396,
  "fields": {
    "card": 222,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 1397,
  "fields": {
    "card": 222,
    "tag": 292
  }
},
{
  "model": "cards.cardtag",
  "pk": 1398,
  "fields": {
    "card": 223,
    "tag": 22
  }
},
{
  "model": "cards.cardtag",
  "pk": 1399,
  "fields": {
    "card": 223,
    "tag": 324
  }
},
{
  "model": "cards.cardtag",
  "pk": 1400,
  "fields": {
    "card": 223,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 1401,
  "fields": {
    "card": 223,
    "tag": 724
  }
},
{
  "model": "cards.cardtag",
  "pk": 1402,
  "fields": {
    "card": 223,
    "tag": 80
  }
},
{
  "model": "cards.cardtag",
  "pk": 1403,
  "fields": {
    "card": 223,
    "tag": 958
  }
},
{
  "model": "cards.cardtag",
  "pk": 1404,
  "fields": {
    "card": 223,
    "tag": 1195
  }
},
{
  "model": "cards.cardtag",
  "pk": 1405,
  "fields": {
    "card": 223,
    "tag": 707
  }
},
{
  "model": "cards.cardtag",
  "pk": 1406,
  "fields": {
    "card": 224,
    "tag": 807
  }
},
{
  "model": "cards.cardtag",
  "pk": 1407,
  "fields": {
    "card": 224,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 1408,
  "fields": {
    "card": 224,
    "tag": 1080
  }
},
{
  "model": "cards.cardtag",
  "pk": 1409,
  "fields": {
    "card": 224,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1410,
  "fields": {
    "card": 224,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 1411,
  "fields": {
    "card": 224,
    "tag": 668
  }
},
{
  "model": "cards.cardtag",
  "pk": 1412,
  "fields": {
    "card": 225,
    "tag": 807
  }
},
{
  "model": "cards.cardtag",
  "pk": 1413,
  "fields": {
    "card": 225,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 1414,
  "fields": {
    "card": 225,
    "tag": 791
  }
},
{
  "model": "cards.cardtag",
  "pk": 1415,
  "fields": {
    "card": 225,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1416,
  "fields": {
    "card": 225,
    "tag": 884
  }
},
{
  "model": "cards.cardtag",
  "pk": 1417,
  "fields": {
    "card": 225,
    "tag": 23
  }
},
{
  "model": "cards.cardtag",
  "pk": 1418,
  "fields": {
    "card": 226,
    "tag": 1082
  }
},
{
  "model": "cards.cardtag",
  "pk": 1419,
  "fields": {
    "card": 226,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1420,
  "fields": {
    "card": 226,
    "tag": 309
  }
},
{
  "model": "cards.cardtag",
  "pk": 1421,
  "fields": {
    "card": 226,
    "tag": 7
  }
},
{
  "model": "cards.cardtag",
  "pk": 1422,
  "fields": {
    "card": 226,
    "tag": 747
  }
},
{
  "model": "cards.cardtag",
  "pk": 1423,
  "fields": {
    "card": 226,
    "tag": 22
  }
},
{
  "model": "cards.cardtag",
  "pk": 1424,
  "fields": {
    "card": 227,
    "tag": 119
  }
},
{
  "model": "cards.cardtag",
  "pk": 1425,
  "fields": {
    "card": 227,
    "tag": 320
  }
},
{
  "model": "cards.cardtag",
  "pk": 1426,
  "fields": {
    "card": 227,
    "tag": 443
  }
},
{
  "model": "cards.cardtag",
  "pk": 1427,
  "fields": {
    "card": 227,
    "tag": 348
  }
},
{
  "model": "cards.cardtag",
  "pk": 1428,
  "fields": {
    "card": 227,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1429,
  "fields": {
    "card": 227,
    "tag": 768
  }
},
{
  "model": "cards.cardtag",
  "pk": 1430,
  "fields": {
    "card": 227,
    "tag": 929
  }
},
{
  "model": "cards.cardtag",
  "pk": 1431,
  "fields": {
    "card": 228,
    "tag": 119
  }
},
{
  "model": "cards.cardtag",
  "pk": 1432,
  "fields": {
    "card": 228,
    "tag": 348
  }
},
{
  "model": "cards.cardtag",
  "pk": 1433,
  "fields": {
    "card": 228,
    "tag": 125
  }
},
{
  "model": "cards.cardtag",
  "pk": 1434,
  "fields": {
    "card": 228,
    "tag": 320
  }
},
{
  "model": "cards.cardtag",
  "pk": 1435,
  "fields": {
    "card": 228,
    "tag": 1150
  }
},
{
  "model": "cards.cardtag",
  "pk": 1436,
  "fields": {
    "card": 228,
    "tag": 11
  }
},
{
  "model": "cards.cardtag",
  "pk": 1437,
  "fields": {
    "card": 229,
    "tag": 119
  }
},
{
  "model": "cards.cardtag",
  "pk": 1438,
  "fields": {
    "card": 229,
    "tag": 320
  }
},
{
  "model": "cards.cardtag",
  "pk": 1439,
  "fields": {
    "card": 229,
    "tag": 348
  }
},
{
  "model": "cards.cardtag",
  "pk": 1440,
  "fields": {
    "card": 229,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1441,
  "fields": {
    "card": 229,
    "tag": 1274
  }
},
{
  "model": "cards.cardtag",
  "pk": 1442,
  "fields": {
    "card": 229,
    "tag": 428
  }
},
{
  "model": "cards.cardtag",
  "pk": 1443,
  "fields": {
    "card": 230,
    "tag": 1260
  }
},
{
  "model": "cards.cardtag",
  "pk": 1444,
  "fields": {
    "card": 230,
    "tag": 655
  }
},
{
  "model": "cards.cardtag",
  "pk": 1445,
  "fields": {
    "card": 230,
    "tag": 1067
  }
},
{
  "model": "cards.cardtag",
  "pk": 1446,
  "fields": {
    "card": 230,
    "tag": 1302
  }
},
{
  "model": "cards.cardtag",
  "pk": 1447,
  "fields": {
    "card": 230,
    "tag": 1245
  }
},
{
  "model": "cards.cardtag",
  "pk": 1448,
  "fields": {
    "card": 230,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1449,
  "fields": {
    "card": 231,
    "tag": 253
  }
},
{
  "model": "cards.cardtag",
  "pk": 1450,
  "fields": {
    "card": 231,
    "tag": 889
  }
},
{
  "model": "cards.cardtag",
  "pk": 1451,
  "fields": {
    "card": 231,
    "tag": 850
  }
},
{
  "model": "cards.cardtag",
  "pk": 1452,
  "fields": {
    "card": 231,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1453,
  "fields": {
    "card": 231,
    "tag": 1348
  }
},
{
  "model": "cards.cardtag",
  "pk": 1454,
  "fields": {
    "card": 231,
    "tag": 347
  }
},
{
  "model": "cards.cardtag",
  "pk": 1455,
  "fields": {
    "card": 232,
    "tag": 610
  }
},
{
  "model": "cards.cardtag",
  "pk": 1456,
  "fields": {
    "card": 232,
    "tag": 174
  }
},
{
  "model": "cards.cardtag",
  "pk": 1457,
  "fields": {
    "card": 232,
    "tag": 440
  }
},
{
  "model": "cards.cardtag",
  "pk": 1458,
  "fields": {
    "card": 232,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1459,
  "fields": {
    "card": 233,
    "tag": 198
  }
},
{
  "model": "cards.cardtag",
  "pk": 1460,
  "fields": {
    "card": 233,
    "tag": 1296
  }
},
{
  "model": "cards.cardtag",
  "pk": 1461,
  "fields": {
    "card": 233,
    "tag": 357
  }
},
{
  "model": "cards.cardtag",
  "pk": 1462,
  "fields": {
    "card": 233,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1463,
  "fields": {
    "card": 233,
    "tag": 175
  }
},
{
  "model": "cards.cardtag",
  "pk": 1464,
  "fields": {
    "card": 233,
    "tag": 1395
  }
},
{
  "model": "cards.cardtag",
  "pk": 1465,
  "fields": {
    "card": 234,
    "tag": 349
  }
},
{
  "model": "cards.cardtag",
  "pk": 1466,
  "fields": {
    "card": 234,
    "tag": 1124
  }
},
{
  "model": "cards.cardtag",
  "pk": 1467,
  "fields": {
    "card": 234,
    "tag": 748
  }
},
{
  "model": "cards.cardtag",
  "pk": 1468,
  "fields": {
    "card": 234,
    "tag": 294
  }
},
{
  "model": "cards.cardtag",
  "pk": 1469,
  "fields": {
    "card": 234,
    "tag": 70
  }
},
{
  "model": "cards.cardtag",
  "pk": 1470,
  "fields": {
    "card": 234,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1471,
  "fields": {
    "card": 235,
    "tag": 842
  }
},
{
  "model": "cards.cardtag",
  "pk": 1472,
  "fields": {
    "card": 235,
    "tag": 111
  }
},
{
  "model": "cards.cardtag",
  "pk": 1473,
  "fields": {
    "card": 235,
    "tag": 92
  }
},
{
  "model": "cards.cardtag",
  "pk": 1474,
  "fields": {
    "card": 235,
    "tag": 537
  }
},
{
  "model": "cards.cardtag",
  "pk": 1475,
  "fields": {
    "card": 235,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1476,
  "fields": {
    "card": 235,
    "tag": 632
  }
},
{
  "model": "cards.cardtag",
  "pk": 1477,
  "fields": {
    "card": 236,
    "tag": 1180
  }
},
{
  "model": "cards.cardtag",
  "pk": 1478,
  "fields": {
    "card": 236,
    "tag": 788
  }
},
{
  "model": "cards.cardtag",
  "pk": 1479,
  "fields": {
    "card": 236,
    "tag": 807
  }
},
{
  "model": "cards.cardtag",
  "pk": 1480,
  "fields": {
    "card": 236,
    "tag": 661
  }
},
{
  "model": "cards.cardtag",
  "pk": 1481,
  "fields": {
    "card": 236,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1482,
  "fields": {
    "card": 236,
    "tag": 1272
  }
},
{
  "model": "cards.cardtag",
  "pk": 1483,
  "fields": {
    "card": 236,
    "tag": 29
  }
},
{
  "model": "cards.cardtag",
  "pk": 1484,
  "fields": {
    "card": 237,
    "tag": 1062
  }
},
{
  "model": "cards.cardtag",
  "pk": 1485,
  "fields": {
    "card": 237,
    "tag": 756
  }
},
{
  "model": "cards.cardtag",
  "pk": 1486,
  "fields": {
    "card": 237,
    "tag": 1342
  }
},
{
  "model": "cards.cardtag",
  "pk": 1487,
  "fields": {
    "card": 237,
    "tag": 195
  }
},
{
  "model": "cards.cardtag",
  "pk": 1488,
  "fields": {
    "card": 237,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1489,
  "fields": {
    "card": 237,
    "tag": 586
  }
},
{
  "model": "cards.cardtag",
  "pk": 1490,
  "fields": {
    "card": 238,
    "tag": 1086
  }
},
{
  "model": "cards.cardtag",
  "pk": 1491,
  "fields": {
    "card": 238,
    "tag": 266
  }
},
{
  "model": "cards.cardtag",
  "pk": 1492,
  "fields": {
    "card": 238,
    "tag": 706
  }
},
{
  "model": "cards.cardtag",
  "pk": 1493,
  "fields": {
    "card": 238,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1494,
  "fields": {
    "card": 238,
    "tag": 1232
  }
},
{
  "model": "cards.cardtag",
  "pk": 1495,
  "fields": {
    "card": 238,
    "tag": 395
  }
},
{
  "model": "cards.cardtag",
  "pk": 1496,
  "fields": {
    "card": 239,
    "tag": 209
  }
},
{
  "model": "cards.cardtag",
  "pk": 1497,
  "fields": {
    "card": 239,
    "tag": 1123
  }
},
{
  "model": "cards.cardtag",
  "pk": 1498,
  "fields": {
    "card": 239,
    "tag": 111
  }
},
{
  "model": "cards.cardtag",
  "pk": 1499,
  "fields": {
    "card": 239,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1500,
  "fields": {
    "card": 239,
    "tag": 683
  }
},
{
  "model": "cards.cardtag",
  "pk": 1501,
  "fields": {
    "card": 239,
    "tag": 837
  }
},
{
  "model": "cards.cardtag",
  "pk": 1502,
  "fields": {
    "card": 240,
    "tag": 446
  }
},
{
  "model": "cards.cardtag",
  "pk": 1503,
  "fields": {
    "card": 240,
    "tag": 405
  }
},
{
  "model": "cards.cardtag",
  "pk": 1504,
  "fields": {
    "card": 240,
    "tag": 834
  }
},
{
  "model": "cards.cardtag",
  "pk": 1505,
  "fields": {
    "card": 240,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1506,
  "fields": {
    "card": 240,
    "tag": 829
  }
},
{
  "model": "cards.cardtag",
  "pk": 1507,
  "fields": {
    "card": 240,
    "tag": 1184
  }
},
{
  "model": "cards.cardtag",
  "pk": 1508,
  "fields": {
    "card": 241,
    "tag": 105
  }
},
{
  "model": "cards.cardtag",
  "pk": 1509,
  "fields": {
    "card": 241,
    "tag": 221
  }
},
{
  "model": "cards.cardtag",
  "pk": 1510,
  "fields": {
    "card": 241,
    "tag": 793
  }
},
{
  "model": "cards.cardtag",
  "pk": 1511,
  "fields": {
    "card": 241,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1512,
  "fields": {
    "card": 241,
    "tag": 425
  }
},
{
  "model": "cards.cardtag",
  "pk": 1513,
  "fields": {
    "card": 241,
    "tag": 1266
  }
},
{
  "model": "cards.cardtag",
  "pk": 1514,
  "fields": {
    "card": 242,
    "tag": 28
  }
},
{
  "model": "cards.cardtag",
  "pk": 1515,
  "fields": {
    "card": 242,
    "tag": 1266
  }
},
{
  "model": "cards.cardtag",
  "pk": 1516,
  "fields": {
    "card": 242,
    "tag": 1076
  }
},
{
  "model": "cards.cardtag",
  "pk": 1517,
  "fields": {
    "card": 242,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1518,
  "fields": {
    "card": 242,
    "tag": 1125
  }
},
{
  "model": "cards.cardtag",
  "pk": 1519,
  "fields": {
    "card": 242,
    "tag": 669
  }
},
{
  "model": "cards.cardtag",
  "pk": 1520,
  "fields": {
    "card": 243,
    "tag": 865
  }
},
{
  "model": "cards.cardtag",
  "pk": 1521,
  "fields": {
    "card": 243,
    "tag": 113
  }
},
{
  "model": "cards.cardtag",
  "pk": 1522,
  "fields": {
    "card": 243,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1523,
  "fields": {
    "card": 243,
    "tag": 1141
  }
},
{
  "model": "cards.cardtag",
  "pk": 1524,
  "fields": {
    "card": 243,
    "tag": 1263
  }
},
{
  "model": "cards.cardtag",
  "pk": 1525,
  "fields": {
    "card": 243,
    "tag": 468
  }
},
{
  "model": "cards.cardtag",
  "pk": 1526,
  "fields": {
    "card": 244,
    "tag": 566
  }
},
{
  "model": "cards.cardtag",
  "pk": 1527,
  "fields": {
    "card": 244,
    "tag": 144
  }
},
{
  "model": "cards.cardtag",
  "pk": 1528,
  "fields": {
    "card": 244,
    "tag": 183
  }
},
{
  "model": "cards.cardtag",
  "pk": 1529,
  "fields": {
    "card": 244,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1530,
  "fields": {
    "card": 244,
    "tag": 1296
  }
},
{
  "model": "cards.cardtag",
  "pk": 1531,
  "fields": {
    "card": 244,
    "tag": 1339
  }
},
{
  "model": "cards.cardtag",
  "pk": 1532,
  "fields": {
    "card": 244,
    "tag": 1351
  }
},
{
  "model": "cards.cardtag",
  "pk": 1533,
  "fields": {
    "card": 245,
    "tag": 1135
  }
},
{
  "model": "cards.cardtag",
  "pk": 1534,
  "fields": {
    "card": 245,
    "tag": 388
  }
},
{
  "model": "cards.cardtag",
  "pk": 1535,
  "fields": {
    "card": 245,
    "tag": 863
  }
},
{
  "model": "cards.cardtag",
  "pk": 1536,
  "fields": {
    "card": 245,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1537,
  "fields": {
    "card": 245,
    "tag": 1328
  }
},
{
  "model": "cards.cardtag",
  "pk": 1538,
  "fields": {
    "card": 245,
    "tag": 456
  }
},
{
  "model": "cards.cardtag",
  "pk": 1539,
  "fields": {
    "card": 246,
    "tag": 1327
  }
},
{
  "model": "cards.cardtag",
  "pk": 1540,
  "fields": {
    "card": 246,
    "tag": 985
  }
},
{
  "model": "cards.cardtag",
  "pk": 1541,
  "fields": {
    "card": 246,
    "tag": 1360
  }
},
{
  "model": "cards.cardtag",
  "pk": 1542,
  "fields": {
    "card": 246,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1543,
  "fields": {
    "card": 246,
    "tag": 750
  }
},
{
  "model": "cards.cardtag",
  "pk": 1544,
  "fields": {
    "card": 246,
    "tag": 705
  }
},
{
  "model": "cards.cardtag",
  "pk": 1545,
  "fields": {
    "card": 247,
    "tag": 10
  }
},
{
  "model": "cards.cardtag",
  "pk": 1546,
  "fields": {
    "card": 247,
    "tag": 757
  }
},
{
  "model": "cards.cardtag",
  "pk": 1547,
  "fields": {
    "card": 247,
    "tag": 405
  }
},
{
  "model": "cards.cardtag",
  "pk": 1548,
  "fields": {
    "card": 247,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1549,
  "fields": {
    "card": 247,
    "tag": 1375
  }
},
{
  "model": "cards.cardtag",
  "pk": 1550,
  "fields": {
    "card": 247,
    "tag": 1340
  }
},
{
  "model": "cards.cardtag",
  "pk": 1551,
  "fields": {
    "card": 247,
    "tag": 844
  }
},
{
  "model": "cards.cardtag",
  "pk": 1552,
  "fields": {
    "card": 248,
    "tag": 225
  }
},
{
  "model": "cards.cardtag",
  "pk": 1553,
  "fields": {
    "card": 248,
    "tag": 18
  }
},
{
  "model": "cards.cardtag",
  "pk": 1554,
  "fields": {
    "card": 248,
    "tag": 240
  }
},
{
  "model": "cards.cardtag",
  "pk": 1555,
  "fields": {
    "card": 248,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1556,
  "fields": {
    "card": 248,
    "tag": 1155
  }
},
{
  "model": "cards.cardtag",
  "pk": 1557,
  "fields": {
    "card": 248,
    "tag": 1295
  }
},
{
  "model": "cards.cardtag",
  "pk": 1558,
  "fields": {
    "card": 249,
    "tag": 1196
  }
},
{
  "model": "cards.cardtag",
  "pk": 1559,
  "fields": {
    "card": 249,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1560,
  "fields": {
    "card": 249,
    "tag": 1314
  }
},
{
  "model": "cards.cardtag",
  "pk": 1561,
  "fields": {
    "card": 249,
    "tag": 1371
  }
},
{
  "model": "cards.cardtag",
  "pk": 1562,
  "fields": {
    "card": 249,
    "tag": 1006
  }
},
{
  "model": "cards.cardtag",
  "pk": 1563,
  "fields": {
    "card": 249,
    "tag": 884
  }
},
{
  "model": "cards.cardtag",
  "pk": 1564,
  "fields": {
    "card": 250,
    "tag": 727
  }
},
{
  "model": "cards.cardtag",
  "pk": 1565,
  "fields": {
    "card": 250,
    "tag": 351
  }
},
{
  "model": "cards.cardtag",
  "pk": 1566,
  "fields": {
    "card": 250,
    "tag": 972
  }
},
{
  "model": "cards.cardtag",
  "pk": 1567,
  "fields": {
    "card": 250,
    "tag": 558
  }
},
{
  "model": "cards.cardtag",
  "pk": 1568,
  "fields": {
    "card": 250,
    "tag": 692
  }
},
{
  "model": "cards.cardtag",
  "pk": 1569,
  "fields": {
    "card": 250,
    "tag": 4
  }
},
{
  "model": "cards.cardtag",
  "pk": 1570,
  "fields": {
    "card": 250,
    "tag": 612
  }
},
{
  "model": "cards.cardtag",
  "pk": 1571,
  "fields": {
    "card": 251,
    "tag": 381
  }
},
{
  "model": "cards.cardtag",
  "pk": 1572,
  "fields": {
    "card": 251,
    "tag": 95
  }
},
{
  "model": "cards.cardtag",
  "pk": 1573,
  "fields": {
    "card": 251,
    "tag": 747
  }
},
{
  "model": "cards.cardtag",
  "pk": 1574,
  "fields": {
    "card": 251,
    "tag": 1201
  }
},
{
  "model": "cards.cardtag",
  "pk": 1575,
  "fields": {
    "card": 251,
    "tag": 840
  }
},
{
  "model": "cards.cardtag",
  "pk": 1576,
  "fields": {
    "card": 251,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1577,
  "fields": {
    "card": 252,
    "tag": 599
  }
},
{
  "model": "cards.cardtag",
  "pk": 1578,
  "fields": {
    "card": 252,
    "tag": 1359
  }
},
{
  "model": "cards.cardtag",
  "pk": 1579,
  "fields": {
    "card": 252,
    "tag": 276
  }
},
{
  "model": "cards.cardtag",
  "pk": 1580,
  "fields": {
    "card": 252,
    "tag": 951
  }
},
{
  "model": "cards.cardtag",
  "pk": 1581,
  "fields": {
    "card": 252,
    "tag": 703
  }
},
{
  "model": "cards.cardtag",
  "pk": 1582,
  "fields": {
    "card": 252,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1583,
  "fields": {
    "card": 253,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1584,
  "fields": {
    "card": 253,
    "tag": 599
  }
},
{
  "model": "cards.cardtag",
  "pk": 1585,
  "fields": {
    "card": 253,
    "tag": 567
  }
},
{
  "model": "cards.cardtag",
  "pk": 1586,
  "fields": {
    "card": 253,
    "tag": 1208
  }
},
{
  "model": "cards.cardtag",
  "pk": 1587,
  "fields": {
    "card": 253,
    "tag": 840
  }
},
{
  "model": "cards.cardtag",
  "pk": 1588,
  "fields": {
    "card": 253,
    "tag": 574
  }
},
{
  "model": "cards.cardtag",
  "pk": 1589,
  "fields": {
    "card": 254,
    "tag": 840
  }
},
{
  "model": "cards.cardtag",
  "pk": 1590,
  "fields": {
    "card": 254,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1591,
  "fields": {
    "card": 254,
    "tag": 257
  }
},
{
  "model": "cards.cardtag",
  "pk": 1592,
  "fields": {
    "card": 254,
    "tag": 155
  }
},
{
  "model": "cards.cardtag",
  "pk": 1593,
  "fields": {
    "card": 254,
    "tag": 885
  }
},
{
  "model": "cards.cardtag",
  "pk": 1594,
  "fields": {
    "card": 254,
    "tag": 745
  }
},
{
  "model": "cards.cardtag",
  "pk": 1595,
  "fields": {
    "card": 255,
    "tag": 543
  }
},
{
  "model": "cards.cardtag",
  "pk": 1596,
  "fields": {
    "card": 255,
    "tag": 599
  }
},
{
  "model": "cards.cardtag",
  "pk": 1597,
  "fields": {
    "card": 255,
    "tag": 141
  }
},
{
  "model": "cards.cardtag",
  "pk": 1598,
  "fields": {
    "card": 255,
    "tag": 891
  }
},
{
  "model": "cards.cardtag",
  "pk": 1599,
  "fields": {
    "card": 255,
    "tag": 292
  }
},
{
  "model": "cards.cardtag",
  "pk": 1600,
  "fields": {
    "card": 255,
    "tag": 332
  }
},
{
  "model": "cards.cardtag",
  "pk": 1601,
  "fields": {
    "card": 256,
    "tag": 832
  }
},
{
  "model": "cards.cardtag",
  "pk": 1602,
  "fields": {
    "card": 256,
    "tag": 747
  }
},
{
  "model": "cards.cardtag",
  "pk": 1603,
  "fields": {
    "card": 256,
    "tag": 1018
  }
},
{
  "model": "cards.cardtag",
  "pk": 1604,
  "fields": {
    "card": 256,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1605,
  "fields": {
    "card": 256,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 1606,
  "fields": {
    "card": 256,
    "tag": 951
  }
},
{
  "model": "cards.cardtag",
  "pk": 1607,
  "fields": {
    "card": 257,
    "tag": 815
  }
},
{
  "model": "cards.cardtag",
  "pk": 1608,
  "fields": {
    "card": 257,
    "tag": 747
  }
},
{
  "model": "cards.cardtag",
  "pk": 1609,
  "fields": {
    "card": 257,
    "tag": 733
  }
},
{
  "model": "cards.cardtag",
  "pk": 1610,
  "fields": {
    "card": 257,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1611,
  "fields": {
    "card": 257,
    "tag": 565
  }
},
{
  "model": "cards.cardtag",
  "pk": 1612,
  "fields": {
    "card": 257,
    "tag": 232
  }
},
{
  "model": "cards.cardtag",
  "pk": 1613,
  "fields": {
    "card": 258,
    "tag": 747
  }
},
{
  "model": "cards.cardtag",
  "pk": 1614,
  "fields": {
    "card": 258,
    "tag": 951
  }
},
{
  "model": "cards.cardtag",
  "pk": 1615,
  "fields": {
    "card": 258,
    "tag": 1385
  }
},
{
  "model": "cards.cardtag",
  "pk": 1616,
  "fields": {
    "card": 258,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1617,
  "fields": {
    "card": 258,
    "tag": 1131
  }
},
{
  "model": "cards.cardtag",
  "pk": 1618,
  "fields": {
    "card": 258,
    "tag": 354
  }
},
{
  "model": "cards.cardtag",
  "pk": 1619,
  "fields": {
    "card": 259,
    "tag": 1201
  }
},
{
  "model": "cards.cardtag",
  "pk": 1620,
  "fields": {
    "card": 259,
    "tag": 964
  }
},
{
  "model": "cards.cardtag",
  "pk": 1621,
  "fields": {
    "card": 259,
    "tag": 22
  }
},
{
  "model": "cards.cardtag",
  "pk": 1622,
  "fields": {
    "card": 259,
    "tag": 599
  }
},
{
  "model": "cards.cardtag",
  "pk": 1623,
  "fields": {
    "card": 259,
    "tag": 840
  }
},
{
  "model": "cards.cardtag",
  "pk": 1624,
  "fields": {
    "card": 259,
    "tag": 473
  }
},
{
  "model": "cards.cardtag",
  "pk": 1625,
  "fields": {
    "card": 260,
    "tag": 747
  }
},
{
  "model": "cards.cardtag",
  "pk": 1626,
  "fields": {
    "card": 260,
    "tag": 280
  }
},
{
  "model": "cards.cardtag",
  "pk": 1627,
  "fields": {
    "card": 260,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1628,
  "fields": {
    "card": 260,
    "tag": 712
  }
},
{
  "model": "cards.cardtag",
  "pk": 1629,
  "fields": {
    "card": 260,
    "tag": 138
  }
},
{
  "model": "cards.cardtag",
  "pk": 1630,
  "fields": {
    "card": 260,
    "tag": 951
  }
},
{
  "model": "cards.cardtag",
  "pk": 1631,
  "fields": {
    "card": 261,
    "tag": 747
  }
},
{
  "model": "cards.cardtag",
  "pk": 1632,
  "fields": {
    "card": 261,
    "tag": 840
  }
},
{
  "model": "cards.cardtag",
  "pk": 1633,
  "fields": {
    "card": 261,
    "tag": 712
  }
},
{
  "model": "cards.cardtag",
  "pk": 1634,
  "fields": {
    "card": 261,
    "tag": 862
  }
},
{
  "model": "cards.cardtag",
  "pk": 1635,
  "fields": {
    "card": 261,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1636,
  "fields": {
    "card": 261,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 1637,
  "fields": {
    "card": 262,
    "tag": 747
  }
},
{
  "model": "cards.cardtag",
  "pk": 1638,
  "fields": {
    "card": 262,
    "tag": 712
  }
},
{
  "model": "cards.cardtag",
  "pk": 1639,
  "fields": {
    "card": 262,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1640,
  "fields": {
    "card": 262,
    "tag": 231
  }
},
{
  "model": "cards.cardtag",
  "pk": 1641,
  "fields": {
    "card": 262,
    "tag": 116
  }
},
{
  "model": "cards.cardtag",
  "pk": 1642,
  "fields": {
    "card": 263,
    "tag": 606
  }
},
{
  "model": "cards.cardtag",
  "pk": 1643,
  "fields": {
    "card": 263,
    "tag": 150
  }
},
{
  "model": "cards.cardtag",
  "pk": 1644,
  "fields": {
    "card": 263,
    "tag": 998
  }
},
{
  "model": "cards.cardtag",
  "pk": 1645,
  "fields": {
    "card": 263,
    "tag": 1280
  }
},
{
  "model": "cards.cardtag",
  "pk": 1646,
  "fields": {
    "card": 263,
    "tag": 618
  }
},
{
  "model": "cards.cardtag",
  "pk": 1647,
  "fields": {
    "card": 263,
    "tag": 51
  }
},
{
  "model": "cards.cardtag",
  "pk": 1648,
  "fields": {
    "card": 264,
    "tag": 1253
  }
},
{
  "model": "cards.cardtag",
  "pk": 1649,
  "fields": {
    "card": 264,
    "tag": 577
  }
},
{
  "model": "cards.cardtag",
  "pk": 1650,
  "fields": {
    "card": 264,
    "tag": 1051
  }
},
{
  "model": "cards.cardtag",
  "pk": 1651,
  "fields": {
    "card": 264,
    "tag": 1153
  }
},
{
  "model": "cards.cardtag",
  "pk": 1652,
  "fields": {
    "card": 264,
    "tag": 1233
  }
},
{
  "model": "cards.cardtag",
  "pk": 1653,
  "fields": {
    "card": 264,
    "tag": 145
  }
},
{
  "model": "cards.cardtag",
  "pk": 1654,
  "fields": {
    "card": 265,
    "tag": 702
  }
},
{
  "model": "cards.cardtag",
  "pk": 1655,
  "fields": {
    "card": 265,
    "tag": 160
  }
},
{
  "model": "cards.cardtag",
  "pk": 1656,
  "fields": {
    "card": 265,
    "tag": 996
  }
},
{
  "model": "cards.cardtag",
  "pk": 1657,
  "fields": {
    "card": 265,
    "tag": 545
  }
},
{
  "model": "cards.cardtag",
  "pk": 1658,
  "fields": {
    "card": 265,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1659,
  "fields": {
    "card": 265,
    "tag": 757
  }
},
{
  "model": "cards.cardtag",
  "pk": 1660,
  "fields": {
    "card": 266,
    "tag": 954
  }
},
{
  "model": "cards.cardtag",
  "pk": 1661,
  "fields": {
    "card": 266,
    "tag": 53
  }
},
{
  "model": "cards.cardtag",
  "pk": 1662,
  "fields": {
    "card": 266,
    "tag": 49
  }
},
{
  "model": "cards.cardtag",
  "pk": 1663,
  "fields": {
    "card": 266,
    "tag": 827
  }
},
{
  "model": "cards.cardtag",
  "pk": 1664,
  "fields": {
    "card": 266,
    "tag": 364
  }
},
{
  "model": "cards.cardtag",
  "pk": 1665,
  "fields": {
    "card": 266,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1666,
  "fields": {
    "card": 266,
    "tag": 258
  }
},
{
  "model": "cards.cardtag",
  "pk": 1667,
  "fields": {
    "card": 266,
    "tag": 465
  }
},
{
  "model": "cards.cardtag",
  "pk": 1668,
  "fields": {
    "card": 267,
    "tag": 915
  }
},
{
  "model": "cards.cardtag",
  "pk": 1669,
  "fields": {
    "card": 267,
    "tag": 971
  }
},
{
  "model": "cards.cardtag",
  "pk": 1670,
  "fields": {
    "card": 267,
    "tag": 1140
  }
},
{
  "model": "cards.cardtag",
  "pk": 1671,
  "fields": {
    "card": 267,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1672,
  "fields": {
    "card": 267,
    "tag": 598
  }
},
{
  "model": "cards.cardtag",
  "pk": 1673,
  "fields": {
    "card": 267,
    "tag": 209
  }
},
{
  "model": "cards.cardtag",
  "pk": 1674,
  "fields": {
    "card": 267,
    "tag": 1105
  }
},
{
  "model": "cards.cardtag",
  "pk": 1675,
  "fields": {
    "card": 268,
    "tag": 1349
  }
},
{
  "model": "cards.cardtag",
  "pk": 1676,
  "fields": {
    "card": 268,
    "tag": 913
  }
},
{
  "model": "cards.cardtag",
  "pk": 1677,
  "fields": {
    "card": 268,
    "tag": 1266
  }
},
{
  "model": "cards.cardtag",
  "pk": 1678,
  "fields": {
    "card": 268,
    "tag": 1041
  }
},
{
  "model": "cards.cardtag",
  "pk": 1679,
  "fields": {
    "card": 268,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1680,
  "fields": {
    "card": 268,
    "tag": 28
  }
},
{
  "model": "cards.cardtag",
  "pk": 1681,
  "fields": {
    "card": 268,
    "tag": 14
  }
},
{
  "model": "cards.cardtag",
  "pk": 1682,
  "fields": {
    "card": 269,
    "tag": 156
  }
},
{
  "model": "cards.cardtag",
  "pk": 1683,
  "fields": {
    "card": 269,
    "tag": 28
  }
},
{
  "model": "cards.cardtag",
  "pk": 1684,
  "fields": {
    "card": 269,
    "tag": 1266
  }
},
{
  "model": "cards.cardtag",
  "pk": 1685,
  "fields": {
    "card": 269,
    "tag": 203
  }
},
{
  "model": "cards.cardtag",
  "pk": 1686,
  "fields": {
    "card": 269,
    "tag": 257
  }
},
{
  "model": "cards.cardtag",
  "pk": 1687,
  "fields": {
    "card": 269,
    "tag": 1076
  }
},
{
  "model": "cards.cardtag",
  "pk": 1688,
  "fields": {
    "card": 270,
    "tag": 105
  }
},
{
  "model": "cards.cardtag",
  "pk": 1689,
  "fields": {
    "card": 270,
    "tag": 1076
  }
},
{
  "model": "cards.cardtag",
  "pk": 1690,
  "fields": {
    "card": 270,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1691,
  "fields": {
    "card": 270,
    "tag": 1266
  }
},
{
  "model": "cards.cardtag",
  "pk": 1692,
  "fields": {
    "card": 270,
    "tag": 1369
  }
},
{
  "model": "cards.cardtag",
  "pk": 1693,
  "fields": {
    "card": 270,
    "tag": 760
  }
},
{
  "model": "cards.cardtag",
  "pk": 1694,
  "fields": {
    "card": 270,
    "tag": 277
  }
},
{
  "model": "cards.cardtag",
  "pk": 1695,
  "fields": {
    "card": 271,
    "tag": 369
  }
},
{
  "model": "cards.cardtag",
  "pk": 1696,
  "fields": {
    "card": 271,
    "tag": 756
  }
},
{
  "model": "cards.cardtag",
  "pk": 1697,
  "fields": {
    "card": 271,
    "tag": 1099
  }
},
{
  "model": "cards.cardtag",
  "pk": 1698,
  "fields": {
    "card": 271,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1699,
  "fields": {
    "card": 271,
    "tag": 706
  }
},
{
  "model": "cards.cardtag",
  "pk": 1700,
  "fields": {
    "card": 271,
    "tag": 1142
  }
},
{
  "model": "cards.cardtag",
  "pk": 1701,
  "fields": {
    "card": 272,
    "tag": 904
  }
},
{
  "model": "cards.cardtag",
  "pk": 1702,
  "fields": {
    "card": 272,
    "tag": 683
  }
},
{
  "model": "cards.cardtag",
  "pk": 1703,
  "fields": {
    "card": 272,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1704,
  "fields": {
    "card": 272,
    "tag": 123
  }
},
{
  "model": "cards.cardtag",
  "pk": 1705,
  "fields": {
    "card": 272,
    "tag": 1138
  }
},
{
  "model": "cards.cardtag",
  "pk": 1706,
  "fields": {
    "card": 272,
    "tag": 848
  }
},
{
  "model": "cards.cardtag",
  "pk": 1707,
  "fields": {
    "card": 273,
    "tag": 1151
  }
},
{
  "model": "cards.cardtag",
  "pk": 1708,
  "fields": {
    "card": 273,
    "tag": 716
  }
},
{
  "model": "cards.cardtag",
  "pk": 1709,
  "fields": {
    "card": 273,
    "tag": 643
  }
},
{
  "model": "cards.cardtag",
  "pk": 1710,
  "fields": {
    "card": 273,
    "tag": 881
  }
},
{
  "model": "cards.cardtag",
  "pk": 1711,
  "fields": {
    "card": 273,
    "tag": 1152
  }
},
{
  "model": "cards.cardtag",
  "pk": 1712,
  "fields": {
    "card": 273,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1713,
  "fields": {
    "card": 274,
    "tag": 818
  }
},
{
  "model": "cards.cardtag",
  "pk": 1714,
  "fields": {
    "card": 274,
    "tag": 1247
  }
},
{
  "model": "cards.cardtag",
  "pk": 1715,
  "fields": {
    "card": 274,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1716,
  "fields": {
    "card": 274,
    "tag": 240
  }
},
{
  "model": "cards.cardtag",
  "pk": 1717,
  "fields": {
    "card": 274,
    "tag": 646
  }
},
{
  "model": "cards.cardtag",
  "pk": 1718,
  "fields": {
    "card": 274,
    "tag": 390
  }
},
{
  "model": "cards.cardtag",
  "pk": 1719,
  "fields": {
    "card": 274,
    "tag": 1063
  }
},
{
  "model": "cards.cardtag",
  "pk": 1720,
  "fields": {
    "card": 275,
    "tag": 140
  }
},
{
  "model": "cards.cardtag",
  "pk": 1721,
  "fields": {
    "card": 275,
    "tag": 678
  }
},
{
  "model": "cards.cardtag",
  "pk": 1722,
  "fields": {
    "card": 275,
    "tag": 56
  }
},
{
  "model": "cards.cardtag",
  "pk": 1723,
  "fields": {
    "card": 275,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1724,
  "fields": {
    "card": 275,
    "tag": 1145
  }
},
{
  "model": "cards.cardtag",
  "pk": 1725,
  "fields": {
    "card": 275,
    "tag": 960
  }
},
{
  "model": "cards.cardtag",
  "pk": 1726,
  "fields": {
    "card": 276,
    "tag": 747
  }
},
{
  "model": "cards.cardtag",
  "pk": 1727,
  "fields": {
    "card": 276,
    "tag": 312
  }
},
{
  "model": "cards.cardtag",
  "pk": 1728,
  "fields": {
    "card": 276,
    "tag": 1266
  }
},
{
  "model": "cards.cardtag",
  "pk": 1729,
  "fields": {
    "card": 276,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1730,
  "fields": {
    "card": 276,
    "tag": 100
  }
},
{
  "model": "cards.cardtag",
  "pk": 1731,
  "fields": {
    "card": 276,
    "tag": 1041
  }
},
{
  "model": "cards.cardtag",
  "pk": 1732,
  "fields": {
    "card": 277,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1733,
  "fields": {
    "card": 277,
    "tag": 813
  }
},
{
  "model": "cards.cardtag",
  "pk": 1734,
  "fields": {
    "card": 277,
    "tag": 111
  }
},
{
  "model": "cards.cardtag",
  "pk": 1735,
  "fields": {
    "card": 277,
    "tag": 623
  }
},
{
  "model": "cards.cardtag",
  "pk": 1736,
  "fields": {
    "card": 277,
    "tag": 1043
  }
},
{
  "model": "cards.cardtag",
  "pk": 1737,
  "fields": {
    "card": 277,
    "tag": 1382
  }
},
{
  "model": "cards.cardtag",
  "pk": 1738,
  "fields": {
    "card": 277,
    "tag": 632
  }
},
{
  "model": "cards.cardtag",
  "pk": 1739,
  "fields": {
    "card": 278,
    "tag": 1202
  }
},
{
  "model": "cards.cardtag",
  "pk": 1740,
  "fields": {
    "card": 278,
    "tag": 356
  }
},
{
  "model": "cards.cardtag",
  "pk": 1741,
  "fields": {
    "card": 278,
    "tag": 306
  }
},
{
  "model": "cards.cardtag",
  "pk": 1742,
  "fields": {
    "card": 278,
    "tag": 1325
  }
},
{
  "model": "cards.cardtag",
  "pk": 1743,
  "fields": {
    "card": 278,
    "tag": 1130
  }
},
{
  "model": "cards.cardtag",
  "pk": 1744,
  "fields": {
    "card": 278,
    "tag": 738
  }
},
{
  "model": "cards.cardtag",
  "pk": 1745,
  "fields": {
    "card": 278,
    "tag": 1332
  }
},
{
  "model": "cards.cardtag",
  "pk": 1746,
  "fields": {
    "card": 278,
    "tag": 265
  }
},
{
  "model": "cards.cardtag",
  "pk": 1747,
  "fields": {
    "card": 278,
    "tag": 162
  }
},
{
  "model": "cards.cardtag",
  "pk": 1748,
  "fields": {
    "card": 278,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1749,
  "fields": {
    "card": 279,
    "tag": 1185
  }
},
{
  "model": "cards.cardtag",
  "pk": 1750,
  "fields": {
    "card": 279,
    "tag": 854
  }
},
{
  "model": "cards.cardtag",
  "pk": 1751,
  "fields": {
    "card": 279,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1752,
  "fields": {
    "card": 279,
    "tag": 1013
  }
},
{
  "model": "cards.cardtag",
  "pk": 1753,
  "fields": {
    "card": 279,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 1754,
  "fields": {
    "card": 280,
    "tag": 254
  }
},
{
  "model": "cards.cardtag",
  "pk": 1755,
  "fields": {
    "card": 280,
    "tag": 789
  }
},
{
  "model": "cards.cardtag",
  "pk": 1756,
  "fields": {
    "card": 280,
    "tag": 713
  }
},
{
  "model": "cards.cardtag",
  "pk": 1757,
  "fields": {
    "card": 280,
    "tag": 17
  }
},
{
  "model": "cards.cardtag",
  "pk": 1758,
  "fields": {
    "card": 280,
    "tag": 812
  }
},
{
  "model": "cards.cardtag",
  "pk": 1759,
  "fields": {
    "card": 280,
    "tag": 443
  }
},
{
  "model": "cards.cardtag",
  "pk": 1760,
  "fields": {
    "card": 280,
    "tag": 94
  }
},
{
  "model": "cards.cardtag",
  "pk": 1761,
  "fields": {
    "card": 280,
    "tag": 843
  }
},
{
  "model": "cards.cardtag",
  "pk": 1762,
  "fields": {
    "card": 280,
    "tag": 784
  }
},
{
  "model": "cards.cardtag",
  "pk": 1763,
  "fields": {
    "card": 280,
    "tag": 587
  }
},
{
  "model": "cards.cardtag",
  "pk": 1764,
  "fields": {
    "card": 281,
    "tag": 189
  }
},
{
  "model": "cards.cardtag",
  "pk": 1765,
  "fields": {
    "card": 281,
    "tag": 950
  }
},
{
  "model": "cards.cardtag",
  "pk": 1766,
  "fields": {
    "card": 281,
    "tag": 1097
  }
},
{
  "model": "cards.cardtag",
  "pk": 1767,
  "fields": {
    "card": 281,
    "tag": 95
  }
},
{
  "model": "cards.cardtag",
  "pk": 1768,
  "fields": {
    "card": 281,
    "tag": 684
  }
},
{
  "model": "cards.cardtag",
  "pk": 1769,
  "fields": {
    "card": 281,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1770,
  "fields": {
    "card": 282,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1771,
  "fields": {
    "card": 282,
    "tag": 400
  }
},
{
  "model": "cards.cardtag",
  "pk": 1772,
  "fields": {
    "card": 282,
    "tag": 1221
  }
},
{
  "model": "cards.cardtag",
  "pk": 1773,
  "fields": {
    "card": 282,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 1774,
  "fields": {
    "card": 282,
    "tag": 1245
  }
},
{
  "model": "cards.cardtag",
  "pk": 1775,
  "fields": {
    "card": 282,
    "tag": 247
  }
},
{
  "model": "cards.cardtag",
  "pk": 1776,
  "fields": {
    "card": 282,
    "tag": 1122
  }
},
{
  "model": "cards.cardtag",
  "pk": 1777,
  "fields": {
    "card": 283,
    "tag": 677
  }
},
{
  "model": "cards.cardtag",
  "pk": 1778,
  "fields": {
    "card": 283,
    "tag": 400
  }
},
{
  "model": "cards.cardtag",
  "pk": 1779,
  "fields": {
    "card": 283,
    "tag": 1183
  }
},
{
  "model": "cards.cardtag",
  "pk": 1780,
  "fields": {
    "card": 283,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 1781,
  "fields": {
    "card": 283,
    "tag": 871
  }
},
{
  "model": "cards.cardtag",
  "pk": 1782,
  "fields": {
    "card": 283,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1783,
  "fields": {
    "card": 284,
    "tag": 718
  }
},
{
  "model": "cards.cardtag",
  "pk": 1784,
  "fields": {
    "card": 284,
    "tag": 747
  }
},
{
  "model": "cards.cardtag",
  "pk": 1785,
  "fields": {
    "card": 284,
    "tag": 75
  }
},
{
  "model": "cards.cardtag",
  "pk": 1786,
  "fields": {
    "card": 284,
    "tag": 993
  }
},
{
  "model": "cards.cardtag",
  "pk": 1787,
  "fields": {
    "card": 284,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1788,
  "fields": {
    "card": 284,
    "tag": 139
  }
},
{
  "model": "cards.cardtag",
  "pk": 1789,
  "fields": {
    "card": 285,
    "tag": 677
  }
},
{
  "model": "cards.cardtag",
  "pk": 1790,
  "fields": {
    "card": 285,
    "tag": 400
  }
},
{
  "model": "cards.cardtag",
  "pk": 1791,
  "fields": {
    "card": 285,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1792,
  "fields": {
    "card": 285,
    "tag": 1242
  }
},
{
  "model": "cards.cardtag",
  "pk": 1793,
  "fields": {
    "card": 285,
    "tag": 599
  }
},
{
  "model": "cards.cardtag",
  "pk": 1794,
  "fields": {
    "card": 285,
    "tag": 322
  }
},
{
  "model": "cards.cardtag",
  "pk": 1795,
  "fields": {
    "card": 286,
    "tag": 161
  }
},
{
  "model": "cards.cardtag",
  "pk": 1796,
  "fields": {
    "card": 286,
    "tag": 1299
  }
},
{
  "model": "cards.cardtag",
  "pk": 1797,
  "fields": {
    "card": 286,
    "tag": 1373
  }
},
{
  "model": "cards.cardtag",
  "pk": 1798,
  "fields": {
    "card": 286,
    "tag": 246
  }
},
{
  "model": "cards.cardtag",
  "pk": 1799,
  "fields": {
    "card": 286,
    "tag": 455
  }
},
{
  "model": "cards.cardtag",
  "pk": 1800,
  "fields": {
    "card": 286,
    "tag": 211
  }
},
{
  "model": "cards.cardtag",
  "pk": 1801,
  "fields": {
    "card": 287,
    "tag": 412
  }
},
{
  "model": "cards.cardtag",
  "pk": 1802,
  "fields": {
    "card": 287,
    "tag": 712
  }
},
{
  "model": "cards.cardtag",
  "pk": 1803,
  "fields": {
    "card": 287,
    "tag": 1188
  }
},
{
  "model": "cards.cardtag",
  "pk": 1804,
  "fields": {
    "card": 287,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1805,
  "fields": {
    "card": 287,
    "tag": 977
  }
},
{
  "model": "cards.cardtag",
  "pk": 1806,
  "fields": {
    "card": 287,
    "tag": 1084
  }
},
{
  "model": "cards.cardtag",
  "pk": 1807,
  "fields": {
    "card": 288,
    "tag": 9
  }
},
{
  "model": "cards.cardtag",
  "pk": 1808,
  "fields": {
    "card": 288,
    "tag": 504
  }
},
{
  "model": "cards.cardtag",
  "pk": 1809,
  "fields": {
    "card": 288,
    "tag": 364
  }
},
{
  "model": "cards.cardtag",
  "pk": 1810,
  "fields": {
    "card": 288,
    "tag": 556
  }
},
{
  "model": "cards.cardtag",
  "pk": 1811,
  "fields": {
    "card": 288,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1812,
  "fields": {
    "card": 288,
    "tag": 49
  }
},
{
  "model": "cards.cardtag",
  "pk": 1813,
  "fields": {
    "card": 289,
    "tag": 1395
  }
},
{
  "model": "cards.cardtag",
  "pk": 1814,
  "fields": {
    "card": 289,
    "tag": 144
  }
},
{
  "model": "cards.cardtag",
  "pk": 1815,
  "fields": {
    "card": 289,
    "tag": 183
  }
},
{
  "model": "cards.cardtag",
  "pk": 1816,
  "fields": {
    "card": 289,
    "tag": 1296
  }
},
{
  "model": "cards.cardtag",
  "pk": 1817,
  "fields": {
    "card": 289,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1818,
  "fields": {
    "card": 289,
    "tag": 175
  }
},
{
  "model": "cards.cardtag",
  "pk": 1819,
  "fields": {
    "card": 290,
    "tag": 842
  }
},
{
  "model": "cards.cardtag",
  "pk": 1820,
  "fields": {
    "card": 290,
    "tag": 1178
  }
},
{
  "model": "cards.cardtag",
  "pk": 1821,
  "fields": {
    "card": 290,
    "tag": 92
  }
},
{
  "model": "cards.cardtag",
  "pk": 1822,
  "fields": {
    "card": 290,
    "tag": 537
  }
},
{
  "model": "cards.cardtag",
  "pk": 1823,
  "fields": {
    "card": 290,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1824,
  "fields": {
    "card": 290,
    "tag": 632
  }
},
{
  "model": "cards.cardtag",
  "pk": 1825,
  "fields": {
    "card": 291,
    "tag": 942
  }
},
{
  "model": "cards.cardtag",
  "pk": 1826,
  "fields": {
    "card": 291,
    "tag": 741
  }
},
{
  "model": "cards.cardtag",
  "pk": 1827,
  "fields": {
    "card": 291,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1828,
  "fields": {
    "card": 291,
    "tag": 50
  }
},
{
  "model": "cards.cardtag",
  "pk": 1829,
  "fields": {
    "card": 291,
    "tag": 64
  }
},
{
  "model": "cards.cardtag",
  "pk": 1830,
  "fields": {
    "card": 292,
    "tag": 417
  }
},
{
  "model": "cards.cardtag",
  "pk": 1831,
  "fields": {
    "card": 292,
    "tag": 749
  }
},
{
  "model": "cards.cardtag",
  "pk": 1832,
  "fields": {
    "card": 292,
    "tag": 501
  }
},
{
  "model": "cards.cardtag",
  "pk": 1833,
  "fields": {
    "card": 292,
    "tag": 890
  }
},
{
  "model": "cards.cardtag",
  "pk": 1834,
  "fields": {
    "card": 292,
    "tag": 806
  }
},
{
  "model": "cards.cardtag",
  "pk": 1835,
  "fields": {
    "card": 292,
    "tag": 479
  }
},
{
  "model": "cards.cardtag",
  "pk": 1836,
  "fields": {
    "card": 292,
    "tag": 1235
  }
},
{
  "model": "cards.cardtag",
  "pk": 1837,
  "fields": {
    "card": 293,
    "tag": 726
  }
},
{
  "model": "cards.cardtag",
  "pk": 1838,
  "fields": {
    "card": 293,
    "tag": 786
  }
},
{
  "model": "cards.cardtag",
  "pk": 1839,
  "fields": {
    "card": 293,
    "tag": 888
  }
},
{
  "model": "cards.cardtag",
  "pk": 1840,
  "fields": {
    "card": 293,
    "tag": 1259
  }
},
{
  "model": "cards.cardtag",
  "pk": 1841,
  "fields": {
    "card": 293,
    "tag": 997
  }
},
{
  "model": "cards.cardtag",
  "pk": 1842,
  "fields": {
    "card": 293,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1843,
  "fields": {
    "card": 294,
    "tag": 1104
  }
},
{
  "model": "cards.cardtag",
  "pk": 1844,
  "fields": {
    "card": 294,
    "tag": 439
  }
},
{
  "model": "cards.cardtag",
  "pk": 1845,
  "fields": {
    "card": 294,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1846,
  "fields": {
    "card": 294,
    "tag": 777
  }
},
{
  "model": "cards.cardtag",
  "pk": 1847,
  "fields": {
    "card": 294,
    "tag": 1016
  }
},
{
  "model": "cards.cardtag",
  "pk": 1848,
  "fields": {
    "card": 294,
    "tag": 769
  }
},
{
  "model": "cards.cardtag",
  "pk": 1849,
  "fields": {
    "card": 295,
    "tag": 1108
  }
},
{
  "model": "cards.cardtag",
  "pk": 1850,
  "fields": {
    "card": 295,
    "tag": 777
  }
},
{
  "model": "cards.cardtag",
  "pk": 1851,
  "fields": {
    "card": 295,
    "tag": 329
  }
},
{
  "model": "cards.cardtag",
  "pk": 1852,
  "fields": {
    "card": 295,
    "tag": 909
  }
},
{
  "model": "cards.cardtag",
  "pk": 1853,
  "fields": {
    "card": 295,
    "tag": 1068
  }
},
{
  "model": "cards.cardtag",
  "pk": 1854,
  "fields": {
    "card": 295,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1855,
  "fields": {
    "card": 295,
    "tag": 772
  }
},
{
  "model": "cards.cardtag",
  "pk": 1856,
  "fields": {
    "card": 296,
    "tag": 439
  }
},
{
  "model": "cards.cardtag",
  "pk": 1857,
  "fields": {
    "card": 296,
    "tag": 1037
  }
},
{
  "model": "cards.cardtag",
  "pk": 1858,
  "fields": {
    "card": 296,
    "tag": 479
  }
},
{
  "model": "cards.cardtag",
  "pk": 1859,
  "fields": {
    "card": 296,
    "tag": 272
  }
},
{
  "model": "cards.cardtag",
  "pk": 1860,
  "fields": {
    "card": 296,
    "tag": 1391
  }
},
{
  "model": "cards.cardtag",
  "pk": 1861,
  "fields": {
    "card": 296,
    "tag": 339
  }
},
{
  "model": "cards.cardtag",
  "pk": 1862,
  "fields": {
    "card": 296,
    "tag": 1047
  }
},
{
  "model": "cards.cardtag",
  "pk": 1863,
  "fields": {
    "card": 297,
    "tag": 439
  }
},
{
  "model": "cards.cardtag",
  "pk": 1864,
  "fields": {
    "card": 297,
    "tag": 1017
  }
},
{
  "model": "cards.cardtag",
  "pk": 1865,
  "fields": {
    "card": 297,
    "tag": 930
  }
},
{
  "model": "cards.cardtag",
  "pk": 1866,
  "fields": {
    "card": 297,
    "tag": 1329
  }
},
{
  "model": "cards.cardtag",
  "pk": 1867,
  "fields": {
    "card": 297,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1868,
  "fields": {
    "card": 297,
    "tag": 28
  }
},
{
  "model": "cards.cardtag",
  "pk": 1869,
  "fields": {
    "card": 298,
    "tag": 1319
  }
},
{
  "model": "cards.cardtag",
  "pk": 1870,
  "fields": {
    "card": 298,
    "tag": 439
  }
},
{
  "model": "cards.cardtag",
  "pk": 1871,
  "fields": {
    "card": 298,
    "tag": 344
  }
},
{
  "model": "cards.cardtag",
  "pk": 1872,
  "fields": {
    "card": 298,
    "tag": 1016
  }
},
{
  "model": "cards.cardtag",
  "pk": 1873,
  "fields": {
    "card": 298,
    "tag": 866
  }
},
{
  "model": "cards.cardtag",
  "pk": 1874,
  "fields": {
    "card": 298,
    "tag": 1326
  }
},
{
  "model": "cards.cardtag",
  "pk": 1875,
  "fields": {
    "card": 299,
    "tag": 59
  }
},
{
  "model": "cards.cardtag",
  "pk": 1876,
  "fields": {
    "card": 299,
    "tag": 336
  }
},
{
  "model": "cards.cardtag",
  "pk": 1877,
  "fields": {
    "card": 299,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1878,
  "fields": {
    "card": 299,
    "tag": 562
  }
},
{
  "model": "cards.cardtag",
  "pk": 1879,
  "fields": {
    "card": 299,
    "tag": 599
  }
},
{
  "model": "cards.cardtag",
  "pk": 1880,
  "fields": {
    "card": 299,
    "tag": 871
  }
},
{
  "model": "cards.cardtag",
  "pk": 1881,
  "fields": {
    "card": 300,
    "tag": 1200
  }
},
{
  "model": "cards.cardtag",
  "pk": 1882,
  "fields": {
    "card": 300,
    "tag": 1210
  }
},
{
  "model": "cards.cardtag",
  "pk": 1883,
  "fields": {
    "card": 300,
    "tag": 1331
  }
},
{
  "model": "cards.cardtag",
  "pk": 1884,
  "fields": {
    "card": 300,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1885,
  "fields": {
    "card": 300,
    "tag": 450
  }
},
{
  "model": "cards.cardtag",
  "pk": 1886,
  "fields": {
    "card": 300,
    "tag": 400
  }
},
{
  "model": "cards.cardtag",
  "pk": 1887,
  "fields": {
    "card": 301,
    "tag": 571
  }
},
{
  "model": "cards.cardtag",
  "pk": 1888,
  "fields": {
    "card": 301,
    "tag": 599
  }
},
{
  "model": "cards.cardtag",
  "pk": 1889,
  "fields": {
    "card": 301,
    "tag": 1095
  }
},
{
  "model": "cards.cardtag",
  "pk": 1890,
  "fields": {
    "card": 301,
    "tag": 1175
  }
},
{
  "model": "cards.cardtag",
  "pk": 1891,
  "fields": {
    "card": 301,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1892,
  "fields": {
    "card": 302,
    "tag": 1185
  }
},
{
  "model": "cards.cardtag",
  "pk": 1893,
  "fields": {
    "card": 302,
    "tag": 1174
  }
},
{
  "model": "cards.cardtag",
  "pk": 1894,
  "fields": {
    "card": 302,
    "tag": 845
  }
},
{
  "model": "cards.cardtag",
  "pk": 1895,
  "fields": {
    "card": 302,
    "tag": 4
  }
},
{
  "model": "cards.cardtag",
  "pk": 1896,
  "fields": {
    "card": 302,
    "tag": 781
  }
},
{
  "model": "cards.cardtag",
  "pk": 1897,
  "fields": {
    "card": 302,
    "tag": 1234
  }
},
{
  "model": "cards.cardtag",
  "pk": 1898,
  "fields": {
    "card": 302,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1899,
  "fields": {
    "card": 303,
    "tag": 1282
  }
},
{
  "model": "cards.cardtag",
  "pk": 1900,
  "fields": {
    "card": 303,
    "tag": 656
  }
},
{
  "model": "cards.cardtag",
  "pk": 1901,
  "fields": {
    "card": 303,
    "tag": 1226
  }
},
{
  "model": "cards.cardtag",
  "pk": 1902,
  "fields": {
    "card": 303,
    "tag": 781
  }
},
{
  "model": "cards.cardtag",
  "pk": 1903,
  "fields": {
    "card": 303,
    "tag": 487
  }
},
{
  "model": "cards.cardtag",
  "pk": 1904,
  "fields": {
    "card": 303,
    "tag": 1149
  }
},
{
  "model": "cards.cardtag",
  "pk": 1905,
  "fields": {
    "card": 303,
    "tag": 124
  }
},
{
  "model": "cards.cardtag",
  "pk": 1906,
  "fields": {
    "card": 303,
    "tag": 167
  }
},
{
  "model": "cards.cardtag",
  "pk": 1907,
  "fields": {
    "card": 303,
    "tag": 1234
  }
},
{
  "model": "cards.cardtag",
  "pk": 1908,
  "fields": {
    "card": 303,
    "tag": 240
  }
},
{
  "model": "cards.cardtag",
  "pk": 1909,
  "fields": {
    "card": 303,
    "tag": 196
  }
},
{
  "model": "cards.cardtag",
  "pk": 1910,
  "fields": {
    "card": 304,
    "tag": 229
  }
},
{
  "model": "cards.cardtag",
  "pk": 1911,
  "fields": {
    "card": 304,
    "tag": 453
  }
},
{
  "model": "cards.cardtag",
  "pk": 1912,
  "fields": {
    "card": 304,
    "tag": 1267
  }
},
{
  "model": "cards.cardtag",
  "pk": 1913,
  "fields": {
    "card": 304,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1914,
  "fields": {
    "card": 304,
    "tag": 1072
  }
},
{
  "model": "cards.cardtag",
  "pk": 1915,
  "fields": {
    "card": 304,
    "tag": 384
  }
},
{
  "model": "cards.cardtag",
  "pk": 1916,
  "fields": {
    "card": 304,
    "tag": 296
  }
},
{
  "model": "cards.cardtag",
  "pk": 1917,
  "fields": {
    "card": 305,
    "tag": 453
  }
},
{
  "model": "cards.cardtag",
  "pk": 1918,
  "fields": {
    "card": 305,
    "tag": 229
  }
},
{
  "model": "cards.cardtag",
  "pk": 1919,
  "fields": {
    "card": 305,
    "tag": 811
  }
},
{
  "model": "cards.cardtag",
  "pk": 1920,
  "fields": {
    "card": 305,
    "tag": 1392
  }
},
{
  "model": "cards.cardtag",
  "pk": 1921,
  "fields": {
    "card": 305,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1922,
  "fields": {
    "card": 305,
    "tag": 884
  }
},
{
  "model": "cards.cardtag",
  "pk": 1923,
  "fields": {
    "card": 305,
    "tag": 823
  }
},
{
  "model": "cards.cardtag",
  "pk": 1924,
  "fields": {
    "card": 306,
    "tag": 1259
  }
},
{
  "model": "cards.cardtag",
  "pk": 1925,
  "fields": {
    "card": 306,
    "tag": 228
  }
},
{
  "model": "cards.cardtag",
  "pk": 1926,
  "fields": {
    "card": 306,
    "tag": 957
  }
},
{
  "model": "cards.cardtag",
  "pk": 1927,
  "fields": {
    "card": 306,
    "tag": 880
  }
},
{
  "model": "cards.cardtag",
  "pk": 1928,
  "fields": {
    "card": 306,
    "tag": 398
  }
},
{
  "model": "cards.cardtag",
  "pk": 1929,
  "fields": {
    "card": 306,
    "tag": 533
  }
},
{
  "model": "cards.cardtag",
  "pk": 1930,
  "fields": {
    "card": 307,
    "tag": 117
  }
},
{
  "model": "cards.cardtag",
  "pk": 1931,
  "fields": {
    "card": 307,
    "tag": 604
  }
},
{
  "model": "cards.cardtag",
  "pk": 1932,
  "fields": {
    "card": 307,
    "tag": 371
  }
},
{
  "model": "cards.cardtag",
  "pk": 1933,
  "fields": {
    "card": 307,
    "tag": 311
  }
},
{
  "model": "cards.cardtag",
  "pk": 1934,
  "fields": {
    "card": 307,
    "tag": 1209
  }
},
{
  "model": "cards.cardtag",
  "pk": 1935,
  "fields": {
    "card": 307,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1936,
  "fields": {
    "card": 308,
    "tag": 1259
  }
},
{
  "model": "cards.cardtag",
  "pk": 1937,
  "fields": {
    "card": 308,
    "tag": 227
  }
},
{
  "model": "cards.cardtag",
  "pk": 1938,
  "fields": {
    "card": 308,
    "tag": 278
  }
},
{
  "model": "cards.cardtag",
  "pk": 1939,
  "fields": {
    "card": 308,
    "tag": 631
  }
},
{
  "model": "cards.cardtag",
  "pk": 1940,
  "fields": {
    "card": 308,
    "tag": 859
  }
},
{
  "model": "cards.cardtag",
  "pk": 1941,
  "fields": {
    "card": 308,
    "tag": 454
  }
},
{
  "model": "cards.cardtag",
  "pk": 1942,
  "fields": {
    "card": 308,
    "tag": 1096
  }
},
{
  "model": "cards.cardtag",
  "pk": 1943,
  "fields": {
    "card": 309,
    "tag": 1259
  }
},
{
  "model": "cards.cardtag",
  "pk": 1944,
  "fields": {
    "card": 309,
    "tag": 619
  }
},
{
  "model": "cards.cardtag",
  "pk": 1945,
  "fields": {
    "card": 309,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1946,
  "fields": {
    "card": 309,
    "tag": 1298
  }
},
{
  "model": "cards.cardtag",
  "pk": 1947,
  "fields": {
    "card": 309,
    "tag": 444
  }
},
{
  "model": "cards.cardtag",
  "pk": 1948,
  "fields": {
    "card": 309,
    "tag": 794
  }
},
{
  "model": "cards.cardtag",
  "pk": 1949,
  "fields": {
    "card": 310,
    "tag": 1259
  }
},
{
  "model": "cards.cardtag",
  "pk": 1950,
  "fields": {
    "card": 310,
    "tag": 278
  }
},
{
  "model": "cards.cardtag",
  "pk": 1951,
  "fields": {
    "card": 310,
    "tag": 611
  }
},
{
  "model": "cards.cardtag",
  "pk": 1952,
  "fields": {
    "card": 310,
    "tag": 1202
  }
},
{
  "model": "cards.cardtag",
  "pk": 1953,
  "fields": {
    "card": 310,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1954,
  "fields": {
    "card": 310,
    "tag": 1160
  }
},
{
  "model": "cards.cardtag",
  "pk": 1955,
  "fields": {
    "card": 311,
    "tag": 1259
  }
},
{
  "model": "cards.cardtag",
  "pk": 1956,
  "fields": {
    "card": 311,
    "tag": 912
  }
},
{
  "model": "cards.cardtag",
  "pk": 1957,
  "fields": {
    "card": 311,
    "tag": 867
  }
},
{
  "model": "cards.cardtag",
  "pk": 1958,
  "fields": {
    "card": 311,
    "tag": 905
  }
},
{
  "model": "cards.cardtag",
  "pk": 1959,
  "fields": {
    "card": 311,
    "tag": 40
  }
},
{
  "model": "cards.cardtag",
  "pk": 1960,
  "fields": {
    "card": 311,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1961,
  "fields": {
    "card": 312,
    "tag": 1111
  }
},
{
  "model": "cards.cardtag",
  "pk": 1962,
  "fields": {
    "card": 312,
    "tag": 1277
  }
},
{
  "model": "cards.cardtag",
  "pk": 1963,
  "fields": {
    "card": 312,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1964,
  "fields": {
    "card": 312,
    "tag": 507
  }
},
{
  "model": "cards.cardtag",
  "pk": 1965,
  "fields": {
    "card": 312,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 1966,
  "fields": {
    "card": 312,
    "tag": 871
  }
},
{
  "model": "cards.cardtag",
  "pk": 1967,
  "fields": {
    "card": 313,
    "tag": 775
  }
},
{
  "model": "cards.cardtag",
  "pk": 1968,
  "fields": {
    "card": 313,
    "tag": 442
  }
},
{
  "model": "cards.cardtag",
  "pk": 1969,
  "fields": {
    "card": 313,
    "tag": 130
  }
},
{
  "model": "cards.cardtag",
  "pk": 1970,
  "fields": {
    "card": 313,
    "tag": 584
  }
},
{
  "model": "cards.cardtag",
  "pk": 1971,
  "fields": {
    "card": 313,
    "tag": 119
  }
},
{
  "model": "cards.cardtag",
  "pk": 1972,
  "fields": {
    "card": 313,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1973,
  "fields": {
    "card": 314,
    "tag": 83
  }
},
{
  "model": "cards.cardtag",
  "pk": 1974,
  "fields": {
    "card": 314,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 1975,
  "fields": {
    "card": 314,
    "tag": 897
  }
},
{
  "model": "cards.cardtag",
  "pk": 1976,
  "fields": {
    "card": 314,
    "tag": 1062
  }
},
{
  "model": "cards.cardtag",
  "pk": 1977,
  "fields": {
    "card": 314,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1978,
  "fields": {
    "card": 314,
    "tag": 884
  }
},
{
  "model": "cards.cardtag",
  "pk": 1979,
  "fields": {
    "card": 315,
    "tag": 208
  }
},
{
  "model": "cards.cardtag",
  "pk": 1980,
  "fields": {
    "card": 315,
    "tag": 48
  }
},
{
  "model": "cards.cardtag",
  "pk": 1981,
  "fields": {
    "card": 315,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1982,
  "fields": {
    "card": 315,
    "tag": 1395
  }
},
{
  "model": "cards.cardtag",
  "pk": 1983,
  "fields": {
    "card": 315,
    "tag": 365
  }
},
{
  "model": "cards.cardtag",
  "pk": 1984,
  "fields": {
    "card": 315,
    "tag": 418
  }
},
{
  "model": "cards.cardtag",
  "pk": 1985,
  "fields": {
    "card": 316,
    "tag": 1055
  }
},
{
  "model": "cards.cardtag",
  "pk": 1986,
  "fields": {
    "card": 316,
    "tag": 1238
  }
},
{
  "model": "cards.cardtag",
  "pk": 1987,
  "fields": {
    "card": 316,
    "tag": 1207
  }
},
{
  "model": "cards.cardtag",
  "pk": 1988,
  "fields": {
    "card": 316,
    "tag": 1367
  }
},
{
  "model": "cards.cardtag",
  "pk": 1989,
  "fields": {
    "card": 316,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1990,
  "fields": {
    "card": 316,
    "tag": 975
  }
},
{
  "model": "cards.cardtag",
  "pk": 1991,
  "fields": {
    "card": 317,
    "tag": 1220
  }
},
{
  "model": "cards.cardtag",
  "pk": 1992,
  "fields": {
    "card": 317,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 1993,
  "fields": {
    "card": 317,
    "tag": 916
  }
},
{
  "model": "cards.cardtag",
  "pk": 1994,
  "fields": {
    "card": 317,
    "tag": 908
  }
},
{
  "model": "cards.cardtag",
  "pk": 1995,
  "fields": {
    "card": 317,
    "tag": 22
  }
},
{
  "model": "cards.cardtag",
  "pk": 1996,
  "fields": {
    "card": 317,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1997,
  "fields": {
    "card": 318,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 1998,
  "fields": {
    "card": 318,
    "tag": 1062
  }
},
{
  "model": "cards.cardtag",
  "pk": 1999,
  "fields": {
    "card": 318,
    "tag": 15
  }
},
{
  "model": "cards.cardtag",
  "pk": 2000,
  "fields": {
    "card": 318,
    "tag": 756
  }
},
{
  "model": "cards.cardtag",
  "pk": 2001,
  "fields": {
    "card": 318,
    "tag": 1214
  }
},
{
  "model": "cards.cardtag",
  "pk": 2002,
  "fields": {
    "card": 318,
    "tag": 641
  }
},
{
  "model": "cards.cardtag",
  "pk": 2003,
  "fields": {
    "card": 318,
    "tag": 246
  }
},
{
  "model": "cards.cardtag",
  "pk": 2004,
  "fields": {
    "card": 319,
    "tag": 137
  }
},
{
  "model": "cards.cardtag",
  "pk": 2005,
  "fields": {
    "card": 319,
    "tag": 1277
  }
},
{
  "model": "cards.cardtag",
  "pk": 2006,
  "fields": {
    "card": 319,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2007,
  "fields": {
    "card": 319,
    "tag": 507
  }
},
{
  "model": "cards.cardtag",
  "pk": 2008,
  "fields": {
    "card": 319,
    "tag": 505
  }
},
{
  "model": "cards.cardtag",
  "pk": 2009,
  "fields": {
    "card": 319,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 2010,
  "fields": {
    "card": 320,
    "tag": 808
  }
},
{
  "model": "cards.cardtag",
  "pk": 2011,
  "fields": {
    "card": 320,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2012,
  "fields": {
    "card": 320,
    "tag": 73
  }
},
{
  "model": "cards.cardtag",
  "pk": 2013,
  "fields": {
    "card": 320,
    "tag": 539
  }
},
{
  "model": "cards.cardtag",
  "pk": 2014,
  "fields": {
    "card": 320,
    "tag": 1201
  }
},
{
  "model": "cards.cardtag",
  "pk": 2015,
  "fields": {
    "card": 320,
    "tag": 747
  }
},
{
  "model": "cards.cardtag",
  "pk": 2016,
  "fields": {
    "card": 320,
    "tag": 111
  }
},
{
  "model": "cards.cardtag",
  "pk": 2017,
  "fields": {
    "card": 321,
    "tag": 739
  }
},
{
  "model": "cards.cardtag",
  "pk": 2018,
  "fields": {
    "card": 321,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2019,
  "fields": {
    "card": 321,
    "tag": 501
  }
},
{
  "model": "cards.cardtag",
  "pk": 2020,
  "fields": {
    "card": 321,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 2021,
  "fields": {
    "card": 321,
    "tag": 980
  }
},
{
  "model": "cards.cardtag",
  "pk": 2022,
  "fields": {
    "card": 321,
    "tag": 1248
  }
},
{
  "model": "cards.cardtag",
  "pk": 2023,
  "fields": {
    "card": 321,
    "tag": 722
  }
},
{
  "model": "cards.cardtag",
  "pk": 2024,
  "fields": {
    "card": 321,
    "tag": 1038
  }
},
{
  "model": "cards.cardtag",
  "pk": 2025,
  "fields": {
    "card": 321,
    "tag": 209
  }
},
{
  "model": "cards.cardtag",
  "pk": 2026,
  "fields": {
    "card": 321,
    "tag": 598
  }
},
{
  "model": "cards.cardtag",
  "pk": 2027,
  "fields": {
    "card": 322,
    "tag": 877
  }
},
{
  "model": "cards.cardtag",
  "pk": 2028,
  "fields": {
    "card": 322,
    "tag": 1394
  }
},
{
  "model": "cards.cardtag",
  "pk": 2029,
  "fields": {
    "card": 322,
    "tag": 653
  }
},
{
  "model": "cards.cardtag",
  "pk": 2030,
  "fields": {
    "card": 322,
    "tag": 389
  }
},
{
  "model": "cards.cardtag",
  "pk": 2031,
  "fields": {
    "card": 322,
    "tag": 321
  }
},
{
  "model": "cards.cardtag",
  "pk": 2032,
  "fields": {
    "card": 322,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2033,
  "fields": {
    "card": 323,
    "tag": 837
  }
},
{
  "model": "cards.cardtag",
  "pk": 2034,
  "fields": {
    "card": 323,
    "tag": 209
  }
},
{
  "model": "cards.cardtag",
  "pk": 2035,
  "fields": {
    "card": 323,
    "tag": 1211
  }
},
{
  "model": "cards.cardtag",
  "pk": 2036,
  "fields": {
    "card": 323,
    "tag": 708
  }
},
{
  "model": "cards.cardtag",
  "pk": 2037,
  "fields": {
    "card": 323,
    "tag": 1105
  }
},
{
  "model": "cards.cardtag",
  "pk": 2038,
  "fields": {
    "card": 323,
    "tag": 1350
  }
},
{
  "model": "cards.cardtag",
  "pk": 2039,
  "fields": {
    "card": 323,
    "tag": 1336
  }
},
{
  "model": "cards.cardtag",
  "pk": 2040,
  "fields": {
    "card": 324,
    "tag": 1055
  }
},
{
  "model": "cards.cardtag",
  "pk": 2041,
  "fields": {
    "card": 324,
    "tag": 1238
  }
},
{
  "model": "cards.cardtag",
  "pk": 2042,
  "fields": {
    "card": 324,
    "tag": 754
  }
},
{
  "model": "cards.cardtag",
  "pk": 2043,
  "fields": {
    "card": 324,
    "tag": 989
  }
},
{
  "model": "cards.cardtag",
  "pk": 2044,
  "fields": {
    "card": 324,
    "tag": 560
  }
},
{
  "model": "cards.cardtag",
  "pk": 2045,
  "fields": {
    "card": 324,
    "tag": 576
  }
},
{
  "model": "cards.cardtag",
  "pk": 2046,
  "fields": {
    "card": 324,
    "tag": 236
  }
},
{
  "model": "cards.cardtag",
  "pk": 2047,
  "fields": {
    "card": 325,
    "tag": 106
  }
},
{
  "model": "cards.cardtag",
  "pk": 2048,
  "fields": {
    "card": 325,
    "tag": 89
  }
},
{
  "model": "cards.cardtag",
  "pk": 2049,
  "fields": {
    "card": 325,
    "tag": 606
  }
},
{
  "model": "cards.cardtag",
  "pk": 2050,
  "fields": {
    "card": 325,
    "tag": 150
  }
},
{
  "model": "cards.cardtag",
  "pk": 2051,
  "fields": {
    "card": 325,
    "tag": 1302
  }
},
{
  "model": "cards.cardtag",
  "pk": 2052,
  "fields": {
    "card": 325,
    "tag": 1139
  }
},
{
  "model": "cards.cardtag",
  "pk": 2053,
  "fields": {
    "card": 325,
    "tag": 765
  }
},
{
  "model": "cards.cardtag",
  "pk": 2054,
  "fields": {
    "card": 326,
    "tag": 1302
  }
},
{
  "model": "cards.cardtag",
  "pk": 2055,
  "fields": {
    "card": 326,
    "tag": 1218
  }
},
{
  "model": "cards.cardtag",
  "pk": 2056,
  "fields": {
    "card": 326,
    "tag": 1153
  }
},
{
  "model": "cards.cardtag",
  "pk": 2057,
  "fields": {
    "card": 326,
    "tag": 491
  }
},
{
  "model": "cards.cardtag",
  "pk": 2058,
  "fields": {
    "card": 326,
    "tag": 150
  }
},
{
  "model": "cards.cardtag",
  "pk": 2059,
  "fields": {
    "card": 326,
    "tag": 22
  }
},
{
  "model": "cards.cardtag",
  "pk": 2060,
  "fields": {
    "card": 327,
    "tag": 492
  }
},
{
  "model": "cards.cardtag",
  "pk": 2061,
  "fields": {
    "card": 327,
    "tag": 186
  }
},
{
  "model": "cards.cardtag",
  "pk": 2062,
  "fields": {
    "card": 327,
    "tag": 772
  }
},
{
  "model": "cards.cardtag",
  "pk": 2063,
  "fields": {
    "card": 327,
    "tag": 893
  }
},
{
  "model": "cards.cardtag",
  "pk": 2064,
  "fields": {
    "card": 327,
    "tag": 438
  }
},
{
  "model": "cards.cardtag",
  "pk": 2065,
  "fields": {
    "card": 327,
    "tag": 96
  }
},
{
  "model": "cards.cardtag",
  "pk": 2066,
  "fields": {
    "card": 328,
    "tag": 673
  }
},
{
  "model": "cards.cardtag",
  "pk": 2067,
  "fields": {
    "card": 328,
    "tag": 625
  }
},
{
  "model": "cards.cardtag",
  "pk": 2068,
  "fields": {
    "card": 328,
    "tag": 111
  }
},
{
  "model": "cards.cardtag",
  "pk": 2069,
  "fields": {
    "card": 328,
    "tag": 597
  }
},
{
  "model": "cards.cardtag",
  "pk": 2070,
  "fields": {
    "card": 328,
    "tag": 188
  }
},
{
  "model": "cards.cardtag",
  "pk": 2071,
  "fields": {
    "card": 328,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2072,
  "fields": {
    "card": 329,
    "tag": 59
  }
},
{
  "model": "cards.cardtag",
  "pk": 2073,
  "fields": {
    "card": 329,
    "tag": 599
  }
},
{
  "model": "cards.cardtag",
  "pk": 2074,
  "fields": {
    "card": 329,
    "tag": 1062
  }
},
{
  "model": "cards.cardtag",
  "pk": 2075,
  "fields": {
    "card": 329,
    "tag": 860
  }
},
{
  "model": "cards.cardtag",
  "pk": 2076,
  "fields": {
    "card": 329,
    "tag": 562
  }
},
{
  "model": "cards.cardtag",
  "pk": 2077,
  "fields": {
    "card": 329,
    "tag": 1166
  }
},
{
  "model": "cards.cardtag",
  "pk": 2078,
  "fields": {
    "card": 330,
    "tag": 328
  }
},
{
  "model": "cards.cardtag",
  "pk": 2079,
  "fields": {
    "card": 330,
    "tag": 1271
  }
},
{
  "model": "cards.cardtag",
  "pk": 2080,
  "fields": {
    "card": 330,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2081,
  "fields": {
    "card": 330,
    "tag": 1060
  }
},
{
  "model": "cards.cardtag",
  "pk": 2082,
  "fields": {
    "card": 330,
    "tag": 481
  }
},
{
  "model": "cards.cardtag",
  "pk": 2083,
  "fields": {
    "card": 330,
    "tag": 1
  }
},
{
  "model": "cards.cardtag",
  "pk": 2084,
  "fields": {
    "card": 331,
    "tag": 1399
  }
},
{
  "model": "cards.cardtag",
  "pk": 2085,
  "fields": {
    "card": 331,
    "tag": 235
  }
},
{
  "model": "cards.cardtag",
  "pk": 2086,
  "fields": {
    "card": 331,
    "tag": 1223
  }
},
{
  "model": "cards.cardtag",
  "pk": 2087,
  "fields": {
    "card": 331,
    "tag": 190
  }
},
{
  "model": "cards.cardtag",
  "pk": 2088,
  "fields": {
    "card": 331,
    "tag": 405
  }
},
{
  "model": "cards.cardtag",
  "pk": 2089,
  "fields": {
    "card": 331,
    "tag": 12
  }
},
{
  "model": "cards.cardtag",
  "pk": 2090,
  "fields": {
    "card": 331,
    "tag": 674
  }
},
{
  "model": "cards.cardtag",
  "pk": 2091,
  "fields": {
    "card": 332,
    "tag": 871
  }
},
{
  "model": "cards.cardtag",
  "pk": 2092,
  "fields": {
    "card": 332,
    "tag": 1098
  }
},
{
  "model": "cards.cardtag",
  "pk": 2093,
  "fields": {
    "card": 332,
    "tag": 906
  }
},
{
  "model": "cards.cardtag",
  "pk": 2094,
  "fields": {
    "card": 332,
    "tag": 511
  }
},
{
  "model": "cards.cardtag",
  "pk": 2095,
  "fields": {
    "card": 332,
    "tag": 85
  }
},
{
  "model": "cards.cardtag",
  "pk": 2096,
  "fields": {
    "card": 332,
    "tag": 1398
  }
},
{
  "model": "cards.cardtag",
  "pk": 2097,
  "fields": {
    "card": 332,
    "tag": 1092
  }
},
{
  "model": "cards.cardtag",
  "pk": 2098,
  "fields": {
    "card": 332,
    "tag": 248
  }
},
{
  "model": "cards.cardtag",
  "pk": 2099,
  "fields": {
    "card": 332,
    "tag": 333
  }
},
{
  "model": "cards.cardtag",
  "pk": 2100,
  "fields": {
    "card": 333,
    "tag": 630
  }
},
{
  "model": "cards.cardtag",
  "pk": 2101,
  "fields": {
    "card": 333,
    "tag": 1333
  }
},
{
  "model": "cards.cardtag",
  "pk": 2102,
  "fields": {
    "card": 333,
    "tag": 685
  }
},
{
  "model": "cards.cardtag",
  "pk": 2103,
  "fields": {
    "card": 333,
    "tag": 1174
  }
},
{
  "model": "cards.cardtag",
  "pk": 2104,
  "fields": {
    "card": 333,
    "tag": 62
  }
},
{
  "model": "cards.cardtag",
  "pk": 2105,
  "fields": {
    "card": 333,
    "tag": 845
  }
},
{
  "model": "cards.cardtag",
  "pk": 2106,
  "fields": {
    "card": 333,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2107,
  "fields": {
    "card": 334,
    "tag": 1228
  }
},
{
  "model": "cards.cardtag",
  "pk": 2108,
  "fields": {
    "card": 334,
    "tag": 1395
  }
},
{
  "model": "cards.cardtag",
  "pk": 2109,
  "fields": {
    "card": 334,
    "tag": 524
  }
},
{
  "model": "cards.cardtag",
  "pk": 2110,
  "fields": {
    "card": 334,
    "tag": 613
  }
},
{
  "model": "cards.cardtag",
  "pk": 2111,
  "fields": {
    "card": 334,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2112,
  "fields": {
    "card": 335,
    "tag": 1119
  }
},
{
  "model": "cards.cardtag",
  "pk": 2113,
  "fields": {
    "card": 335,
    "tag": 1218
  }
},
{
  "model": "cards.cardtag",
  "pk": 2114,
  "fields": {
    "card": 335,
    "tag": 553
  }
},
{
  "model": "cards.cardtag",
  "pk": 2115,
  "fields": {
    "card": 335,
    "tag": 1342
  }
},
{
  "model": "cards.cardtag",
  "pk": 2116,
  "fields": {
    "card": 335,
    "tag": 1302
  }
},
{
  "model": "cards.cardtag",
  "pk": 2117,
  "fields": {
    "card": 335,
    "tag": 22
  }
},
{
  "model": "cards.cardtag",
  "pk": 2118,
  "fields": {
    "card": 336,
    "tag": 1136
  }
},
{
  "model": "cards.cardtag",
  "pk": 2119,
  "fields": {
    "card": 336,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2120,
  "fields": {
    "card": 336,
    "tag": 747
  }
},
{
  "model": "cards.cardtag",
  "pk": 2121,
  "fields": {
    "card": 336,
    "tag": 649
  }
},
{
  "model": "cards.cardtag",
  "pk": 2122,
  "fields": {
    "card": 336,
    "tag": 1109
  }
},
{
  "model": "cards.cardtag",
  "pk": 2123,
  "fields": {
    "card": 336,
    "tag": 1205
  }
},
{
  "model": "cards.cardtag",
  "pk": 2124,
  "fields": {
    "card": 337,
    "tag": 59
  }
},
{
  "model": "cards.cardtag",
  "pk": 2125,
  "fields": {
    "card": 337,
    "tag": 677
  }
},
{
  "model": "cards.cardtag",
  "pk": 2126,
  "fields": {
    "card": 337,
    "tag": 772
  }
},
{
  "model": "cards.cardtag",
  "pk": 2127,
  "fields": {
    "card": 337,
    "tag": 219
  }
},
{
  "model": "cards.cardtag",
  "pk": 2128,
  "fields": {
    "card": 337,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2129,
  "fields": {
    "card": 337,
    "tag": 599
  }
},
{
  "model": "cards.cardtag",
  "pk": 2130,
  "fields": {
    "card": 338,
    "tag": 266
  }
},
{
  "model": "cards.cardtag",
  "pk": 2131,
  "fields": {
    "card": 338,
    "tag": 706
  }
},
{
  "model": "cards.cardtag",
  "pk": 2132,
  "fields": {
    "card": 338,
    "tag": 756
  }
},
{
  "model": "cards.cardtag",
  "pk": 2133,
  "fields": {
    "card": 338,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2134,
  "fields": {
    "card": 338,
    "tag": 1356
  }
},
{
  "model": "cards.cardtag",
  "pk": 2135,
  "fields": {
    "card": 338,
    "tag": 395
  }
},
{
  "model": "cards.cardtag",
  "pk": 2136,
  "fields": {
    "card": 339,
    "tag": 1309
  }
},
{
  "model": "cards.cardtag",
  "pk": 2137,
  "fields": {
    "card": 339,
    "tag": 1266
  }
},
{
  "model": "cards.cardtag",
  "pk": 2138,
  "fields": {
    "card": 339,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2139,
  "fields": {
    "card": 339,
    "tag": 900
  }
},
{
  "model": "cards.cardtag",
  "pk": 2140,
  "fields": {
    "card": 339,
    "tag": 934
  }
},
{
  "model": "cards.cardtag",
  "pk": 2141,
  "fields": {
    "card": 339,
    "tag": 1125
  }
},
{
  "model": "cards.cardtag",
  "pk": 2142,
  "fields": {
    "card": 340,
    "tag": 91
  }
},
{
  "model": "cards.cardtag",
  "pk": 2143,
  "fields": {
    "card": 340,
    "tag": 1266
  }
},
{
  "model": "cards.cardtag",
  "pk": 2144,
  "fields": {
    "card": 340,
    "tag": 1125
  }
},
{
  "model": "cards.cardtag",
  "pk": 2145,
  "fields": {
    "card": 340,
    "tag": 1076
  }
},
{
  "model": "cards.cardtag",
  "pk": 2146,
  "fields": {
    "card": 340,
    "tag": 28
  }
},
{
  "model": "cards.cardtag",
  "pk": 2147,
  "fields": {
    "card": 340,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2148,
  "fields": {
    "card": 341,
    "tag": 932
  }
},
{
  "model": "cards.cardtag",
  "pk": 2149,
  "fields": {
    "card": 341,
    "tag": 497
  }
},
{
  "model": "cards.cardtag",
  "pk": 2150,
  "fields": {
    "card": 341,
    "tag": 827
  }
},
{
  "model": "cards.cardtag",
  "pk": 2151,
  "fields": {
    "card": 341,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2152,
  "fields": {
    "card": 341,
    "tag": 706
  }
},
{
  "model": "cards.cardtag",
  "pk": 2153,
  "fields": {
    "card": 341,
    "tag": 1356
  }
},
{
  "model": "cards.cardtag",
  "pk": 2154,
  "fields": {
    "card": 342,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2155,
  "fields": {
    "card": 342,
    "tag": 468
  }
},
{
  "model": "cards.cardtag",
  "pk": 2156,
  "fields": {
    "card": 342,
    "tag": 766
  }
},
{
  "model": "cards.cardtag",
  "pk": 2157,
  "fields": {
    "card": 342,
    "tag": 589
  }
},
{
  "model": "cards.cardtag",
  "pk": 2158,
  "fields": {
    "card": 342,
    "tag": 290
  }
},
{
  "model": "cards.cardtag",
  "pk": 2159,
  "fields": {
    "card": 342,
    "tag": 315
  }
},
{
  "model": "cards.cardtag",
  "pk": 2160,
  "fields": {
    "card": 343,
    "tag": 677
  }
},
{
  "model": "cards.cardtag",
  "pk": 2161,
  "fields": {
    "card": 343,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2162,
  "fields": {
    "card": 343,
    "tag": 1183
  }
},
{
  "model": "cards.cardtag",
  "pk": 2163,
  "fields": {
    "card": 343,
    "tag": 400
  }
},
{
  "model": "cards.cardtag",
  "pk": 2164,
  "fields": {
    "card": 343,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 2165,
  "fields": {
    "card": 343,
    "tag": 871
  }
},
{
  "model": "cards.cardtag",
  "pk": 2166,
  "fields": {
    "card": 344,
    "tag": 400
  }
},
{
  "model": "cards.cardtag",
  "pk": 2167,
  "fields": {
    "card": 344,
    "tag": 747
  }
},
{
  "model": "cards.cardtag",
  "pk": 2168,
  "fields": {
    "card": 344,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2169,
  "fields": {
    "card": 344,
    "tag": 767
  }
},
{
  "model": "cards.cardtag",
  "pk": 2170,
  "fields": {
    "card": 344,
    "tag": 993
  }
},
{
  "model": "cards.cardtag",
  "pk": 2171,
  "fields": {
    "card": 344,
    "tag": 75
  }
},
{
  "model": "cards.cardtag",
  "pk": 2172,
  "fields": {
    "card": 345,
    "tag": 677
  }
},
{
  "model": "cards.cardtag",
  "pk": 2173,
  "fields": {
    "card": 345,
    "tag": 400
  }
},
{
  "model": "cards.cardtag",
  "pk": 2174,
  "fields": {
    "card": 345,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2175,
  "fields": {
    "card": 345,
    "tag": 884
  }
},
{
  "model": "cards.cardtag",
  "pk": 2176,
  "fields": {
    "card": 345,
    "tag": 747
  }
},
{
  "model": "cards.cardtag",
  "pk": 2177,
  "fields": {
    "card": 345,
    "tag": 1183
  }
},
{
  "model": "cards.cardtag",
  "pk": 2178,
  "fields": {
    "card": 346,
    "tag": 400
  }
},
{
  "model": "cards.cardtag",
  "pk": 2179,
  "fields": {
    "card": 346,
    "tag": 677
  }
},
{
  "model": "cards.cardtag",
  "pk": 2180,
  "fields": {
    "card": 346,
    "tag": 1183
  }
},
{
  "model": "cards.cardtag",
  "pk": 2181,
  "fields": {
    "card": 346,
    "tag": 747
  }
},
{
  "model": "cards.cardtag",
  "pk": 2182,
  "fields": {
    "card": 346,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2183,
  "fields": {
    "card": 346,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 2184,
  "fields": {
    "card": 347,
    "tag": 400
  }
},
{
  "model": "cards.cardtag",
  "pk": 2185,
  "fields": {
    "card": 347,
    "tag": 677
  }
},
{
  "model": "cards.cardtag",
  "pk": 2186,
  "fields": {
    "card": 347,
    "tag": 1183
  }
},
{
  "model": "cards.cardtag",
  "pk": 2187,
  "fields": {
    "card": 347,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2188,
  "fields": {
    "card": 347,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 2189,
  "fields": {
    "card": 347,
    "tag": 599
  }
},
{
  "model": "cards.cardtag",
  "pk": 2190,
  "fields": {
    "card": 348,
    "tag": 693
  }
},
{
  "model": "cards.cardtag",
  "pk": 2191,
  "fields": {
    "card": 348,
    "tag": 1023
  }
},
{
  "model": "cards.cardtag",
  "pk": 2192,
  "fields": {
    "card": 348,
    "tag": 1129
  }
},
{
  "model": "cards.cardtag",
  "pk": 2193,
  "fields": {
    "card": 348,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2194,
  "fields": {
    "card": 348,
    "tag": 266
  }
},
{
  "model": "cards.cardtag",
  "pk": 2195,
  "fields": {
    "card": 348,
    "tag": 628
  }
},
{
  "model": "cards.cardtag",
  "pk": 2196,
  "fields": {
    "card": 349,
    "tag": 652
  }
},
{
  "model": "cards.cardtag",
  "pk": 2197,
  "fields": {
    "card": 349,
    "tag": 1062
  }
},
{
  "model": "cards.cardtag",
  "pk": 2198,
  "fields": {
    "card": 349,
    "tag": 982
  }
},
{
  "model": "cards.cardtag",
  "pk": 2199,
  "fields": {
    "card": 349,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2200,
  "fields": {
    "card": 349,
    "tag": 1342
  }
},
{
  "model": "cards.cardtag",
  "pk": 2201,
  "fields": {
    "card": 349,
    "tag": 195
  }
},
{
  "model": "cards.cardtag",
  "pk": 2202,
  "fields": {
    "card": 349,
    "tag": 505
  }
},
{
  "model": "cards.cardtag",
  "pk": 2203,
  "fields": {
    "card": 350,
    "tag": 817
  }
},
{
  "model": "cards.cardtag",
  "pk": 2204,
  "fields": {
    "card": 350,
    "tag": 1355
  }
},
{
  "model": "cards.cardtag",
  "pk": 2205,
  "fields": {
    "card": 350,
    "tag": 176
  }
},
{
  "model": "cards.cardtag",
  "pk": 2206,
  "fields": {
    "card": 350,
    "tag": 1158
  }
},
{
  "model": "cards.cardtag",
  "pk": 2207,
  "fields": {
    "card": 350,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2208,
  "fields": {
    "card": 350,
    "tag": 838
  }
},
{
  "model": "cards.cardtag",
  "pk": 2209,
  "fields": {
    "card": 350,
    "tag": 1014
  }
},
{
  "model": "cards.cardtag",
  "pk": 2210,
  "fields": {
    "card": 351,
    "tag": 1239
  }
},
{
  "model": "cards.cardtag",
  "pk": 2211,
  "fields": {
    "card": 351,
    "tag": 482
  }
},
{
  "model": "cards.cardtag",
  "pk": 2212,
  "fields": {
    "card": 351,
    "tag": 255
  }
},
{
  "model": "cards.cardtag",
  "pk": 2213,
  "fields": {
    "card": 351,
    "tag": 1169
  }
},
{
  "model": "cards.cardtag",
  "pk": 2214,
  "fields": {
    "card": 351,
    "tag": 470
  }
},
{
  "model": "cards.cardtag",
  "pk": 2215,
  "fields": {
    "card": 351,
    "tag": 772
  }
},
{
  "model": "cards.cardtag",
  "pk": 2216,
  "fields": {
    "card": 352,
    "tag": 1023
  }
},
{
  "model": "cards.cardtag",
  "pk": 2217,
  "fields": {
    "card": 352,
    "tag": 706
  }
},
{
  "model": "cards.cardtag",
  "pk": 2218,
  "fields": {
    "card": 352,
    "tag": 266
  }
},
{
  "model": "cards.cardtag",
  "pk": 2219,
  "fields": {
    "card": 352,
    "tag": 1030
  }
},
{
  "model": "cards.cardtag",
  "pk": 2220,
  "fields": {
    "card": 352,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2221,
  "fields": {
    "card": 352,
    "tag": 337
  }
},
{
  "model": "cards.cardtag",
  "pk": 2222,
  "fields": {
    "card": 353,
    "tag": 288
  }
},
{
  "model": "cards.cardtag",
  "pk": 2223,
  "fields": {
    "card": 353,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2224,
  "fields": {
    "card": 353,
    "tag": 706
  }
},
{
  "model": "cards.cardtag",
  "pk": 2225,
  "fields": {
    "card": 353,
    "tag": 266
  }
},
{
  "model": "cards.cardtag",
  "pk": 2226,
  "fields": {
    "card": 353,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 2227,
  "fields": {
    "card": 353,
    "tag": 884
  }
},
{
  "model": "cards.cardtag",
  "pk": 2228,
  "fields": {
    "card": 354,
    "tag": 1304
  }
},
{
  "model": "cards.cardtag",
  "pk": 2229,
  "fields": {
    "card": 354,
    "tag": 648
  }
},
{
  "model": "cards.cardtag",
  "pk": 2230,
  "fields": {
    "card": 354,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2231,
  "fields": {
    "card": 354,
    "tag": 706
  }
},
{
  "model": "cards.cardtag",
  "pk": 2232,
  "fields": {
    "card": 354,
    "tag": 1276
  }
},
{
  "model": "cards.cardtag",
  "pk": 2233,
  "fields": {
    "card": 354,
    "tag": 835
  }
},
{
  "model": "cards.cardtag",
  "pk": 2234,
  "fields": {
    "card": 355,
    "tag": 541
  }
},
{
  "model": "cards.cardtag",
  "pk": 2235,
  "fields": {
    "card": 355,
    "tag": 274
  }
},
{
  "model": "cards.cardtag",
  "pk": 2236,
  "fields": {
    "card": 355,
    "tag": 1093
  }
},
{
  "model": "cards.cardtag",
  "pk": 2237,
  "fields": {
    "card": 355,
    "tag": 1106
  }
},
{
  "model": "cards.cardtag",
  "pk": 2238,
  "fields": {
    "card": 355,
    "tag": 876
  }
},
{
  "model": "cards.cardtag",
  "pk": 2239,
  "fields": {
    "card": 355,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2240,
  "fields": {
    "card": 356,
    "tag": 1183
  }
},
{
  "model": "cards.cardtag",
  "pk": 2241,
  "fields": {
    "card": 356,
    "tag": 677
  }
},
{
  "model": "cards.cardtag",
  "pk": 2242,
  "fields": {
    "card": 356,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2243,
  "fields": {
    "card": 356,
    "tag": 1157
  }
},
{
  "model": "cards.cardtag",
  "pk": 2244,
  "fields": {
    "card": 356,
    "tag": 36
  }
},
{
  "model": "cards.cardtag",
  "pk": 2245,
  "fields": {
    "card": 356,
    "tag": 974
  }
},
{
  "model": "cards.cardtag",
  "pk": 2246,
  "fields": {
    "card": 357,
    "tag": 663
  }
},
{
  "model": "cards.cardtag",
  "pk": 2247,
  "fields": {
    "card": 357,
    "tag": 683
  }
},
{
  "model": "cards.cardtag",
  "pk": 2248,
  "fields": {
    "card": 357,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2249,
  "fields": {
    "card": 357,
    "tag": 266
  }
},
{
  "model": "cards.cardtag",
  "pk": 2250,
  "fields": {
    "card": 357,
    "tag": 756
  }
},
{
  "model": "cards.cardtag",
  "pk": 2251,
  "fields": {
    "card": 357,
    "tag": 292
  }
},
{
  "model": "cards.cardtag",
  "pk": 2252,
  "fields": {
    "card": 358,
    "tag": 918
  }
},
{
  "model": "cards.cardtag",
  "pk": 2253,
  "fields": {
    "card": 358,
    "tag": 53
  }
},
{
  "model": "cards.cardtag",
  "pk": 2254,
  "fields": {
    "card": 358,
    "tag": 445
  }
},
{
  "model": "cards.cardtag",
  "pk": 2255,
  "fields": {
    "card": 358,
    "tag": 922
  }
},
{
  "model": "cards.cardtag",
  "pk": 2256,
  "fields": {
    "card": 358,
    "tag": 508
  }
},
{
  "model": "cards.cardtag",
  "pk": 2257,
  "fields": {
    "card": 358,
    "tag": 783
  }
},
{
  "model": "cards.cardtag",
  "pk": 2258,
  "fields": {
    "card": 358,
    "tag": 983
  }
},
{
  "model": "cards.cardtag",
  "pk": 2259,
  "fields": {
    "card": 358,
    "tag": 1324
  }
},
{
  "model": "cards.cardtag",
  "pk": 2260,
  "fields": {
    "card": 358,
    "tag": 528
  }
},
{
  "model": "cards.cardtag",
  "pk": 2261,
  "fields": {
    "card": 358,
    "tag": 24
  }
},
{
  "model": "cards.cardtag",
  "pk": 2262,
  "fields": {
    "card": 358,
    "tag": 647
  }
},
{
  "model": "cards.cardtag",
  "pk": 2263,
  "fields": {
    "card": 359,
    "tag": 1185
  }
},
{
  "model": "cards.cardtag",
  "pk": 2264,
  "fields": {
    "card": 359,
    "tag": 922
  }
},
{
  "model": "cards.cardtag",
  "pk": 2265,
  "fields": {
    "card": 359,
    "tag": 528
  }
},
{
  "model": "cards.cardtag",
  "pk": 2266,
  "fields": {
    "card": 359,
    "tag": 647
  }
},
{
  "model": "cards.cardtag",
  "pk": 2267,
  "fields": {
    "card": 359,
    "tag": 1383
  }
},
{
  "model": "cards.cardtag",
  "pk": 2268,
  "fields": {
    "card": 359,
    "tag": 918
  }
},
{
  "model": "cards.cardtag",
  "pk": 2269,
  "fields": {
    "card": 360,
    "tag": 234
  }
},
{
  "model": "cards.cardtag",
  "pk": 2270,
  "fields": {
    "card": 360,
    "tag": 822
  }
},
{
  "model": "cards.cardtag",
  "pk": 2271,
  "fields": {
    "card": 360,
    "tag": 1395
  }
},
{
  "model": "cards.cardtag",
  "pk": 2272,
  "fields": {
    "card": 360,
    "tag": 1004
  }
},
{
  "model": "cards.cardtag",
  "pk": 2273,
  "fields": {
    "card": 360,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2274,
  "fields": {
    "card": 361,
    "tag": 996
  }
},
{
  "model": "cards.cardtag",
  "pk": 2275,
  "fields": {
    "card": 361,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 2276,
  "fields": {
    "card": 361,
    "tag": 477
  }
},
{
  "model": "cards.cardtag",
  "pk": 2277,
  "fields": {
    "card": 361,
    "tag": 820
  }
},
{
  "model": "cards.cardtag",
  "pk": 2278,
  "fields": {
    "card": 361,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2279,
  "fields": {
    "card": 362,
    "tag": 612
  }
},
{
  "model": "cards.cardtag",
  "pk": 2280,
  "fields": {
    "card": 362,
    "tag": 721
  }
},
{
  "model": "cards.cardtag",
  "pk": 2281,
  "fields": {
    "card": 362,
    "tag": 1293
  }
},
{
  "model": "cards.cardtag",
  "pk": 2282,
  "fields": {
    "card": 362,
    "tag": 1001
  }
},
{
  "model": "cards.cardtag",
  "pk": 2283,
  "fields": {
    "card": 362,
    "tag": 1048
  }
},
{
  "model": "cards.cardtag",
  "pk": 2284,
  "fields": {
    "card": 362,
    "tag": 193
  }
},
{
  "model": "cards.cardtag",
  "pk": 2285,
  "fields": {
    "card": 363,
    "tag": 421
  }
},
{
  "model": "cards.cardtag",
  "pk": 2286,
  "fields": {
    "card": 363,
    "tag": 873
  }
},
{
  "model": "cards.cardtag",
  "pk": 2287,
  "fields": {
    "card": 363,
    "tag": 851
  }
},
{
  "model": "cards.cardtag",
  "pk": 2288,
  "fields": {
    "card": 363,
    "tag": 1261
  }
},
{
  "model": "cards.cardtag",
  "pk": 2289,
  "fields": {
    "card": 363,
    "tag": 345
  }
},
{
  "model": "cards.cardtag",
  "pk": 2290,
  "fields": {
    "card": 363,
    "tag": 603
  }
},
{
  "model": "cards.cardtag",
  "pk": 2291,
  "fields": {
    "card": 363,
    "tag": 307
  }
},
{
  "model": "cards.cardtag",
  "pk": 2292,
  "fields": {
    "card": 364,
    "tag": 874
  }
},
{
  "model": "cards.cardtag",
  "pk": 2293,
  "fields": {
    "card": 364,
    "tag": 158
  }
},
{
  "model": "cards.cardtag",
  "pk": 2294,
  "fields": {
    "card": 364,
    "tag": 395
  }
},
{
  "model": "cards.cardtag",
  "pk": 2295,
  "fields": {
    "card": 364,
    "tag": 77
  }
},
{
  "model": "cards.cardtag",
  "pk": 2296,
  "fields": {
    "card": 364,
    "tag": 266
  }
},
{
  "model": "cards.cardtag",
  "pk": 2297,
  "fields": {
    "card": 364,
    "tag": 1286
  }
},
{
  "model": "cards.cardtag",
  "pk": 2298,
  "fields": {
    "card": 365,
    "tag": 872
  }
},
{
  "model": "cards.cardtag",
  "pk": 2299,
  "fields": {
    "card": 365,
    "tag": 1224
  }
},
{
  "model": "cards.cardtag",
  "pk": 2300,
  "fields": {
    "card": 365,
    "tag": 233
  }
},
{
  "model": "cards.cardtag",
  "pk": 2301,
  "fields": {
    "card": 365,
    "tag": 534
  }
},
{
  "model": "cards.cardtag",
  "pk": 2302,
  "fields": {
    "card": 365,
    "tag": 1191
  }
},
{
  "model": "cards.cardtag",
  "pk": 2303,
  "fields": {
    "card": 365,
    "tag": 871
  }
},
{
  "model": "cards.cardtag",
  "pk": 2304,
  "fields": {
    "card": 365,
    "tag": 709
  }
},
{
  "model": "cards.cardtag",
  "pk": 2305,
  "fields": {
    "card": 365,
    "tag": 786
  }
},
{
  "model": "cards.cardtag",
  "pk": 2306,
  "fields": {
    "card": 365,
    "tag": 1259
  }
},
{
  "model": "cards.cardtag",
  "pk": 2307,
  "fields": {
    "card": 365,
    "tag": 273
  }
},
{
  "model": "cards.cardtag",
  "pk": 2308,
  "fields": {
    "card": 365,
    "tag": 108
  }
},
{
  "model": "cards.cardtag",
  "pk": 2309,
  "fields": {
    "card": 365,
    "tag": 1307
  }
},
{
  "model": "cards.cardtag",
  "pk": 2310,
  "fields": {
    "card": 366,
    "tag": 852
  }
},
{
  "model": "cards.cardtag",
  "pk": 2311,
  "fields": {
    "card": 366,
    "tag": 102
  }
},
{
  "model": "cards.cardtag",
  "pk": 2312,
  "fields": {
    "card": 366,
    "tag": 786
  }
},
{
  "model": "cards.cardtag",
  "pk": 2313,
  "fields": {
    "card": 366,
    "tag": 1259
  }
},
{
  "model": "cards.cardtag",
  "pk": 2314,
  "fields": {
    "card": 366,
    "tag": 888
  }
},
{
  "model": "cards.cardtag",
  "pk": 2315,
  "fields": {
    "card": 366,
    "tag": 650
  }
},
{
  "model": "cards.cardtag",
  "pk": 2316,
  "fields": {
    "card": 366,
    "tag": 66
  }
},
{
  "model": "cards.cardtag",
  "pk": 2317,
  "fields": {
    "card": 366,
    "tag": 444
  }
},
{
  "model": "cards.cardtag",
  "pk": 2318,
  "fields": {
    "card": 366,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 2319,
  "fields": {
    "card": 367,
    "tag": 1185
  }
},
{
  "model": "cards.cardtag",
  "pk": 2320,
  "fields": {
    "card": 367,
    "tag": 845
  }
},
{
  "model": "cards.cardtag",
  "pk": 2321,
  "fields": {
    "card": 367,
    "tag": 886
  }
},
{
  "model": "cards.cardtag",
  "pk": 2322,
  "fields": {
    "card": 367,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2323,
  "fields": {
    "card": 367,
    "tag": 239
  }
},
{
  "model": "cards.cardtag",
  "pk": 2324,
  "fields": {
    "card": 367,
    "tag": 1174
  }
},
{
  "model": "cards.cardtag",
  "pk": 2325,
  "fields": {
    "card": 368,
    "tag": 1101
  }
},
{
  "model": "cards.cardtag",
  "pk": 2326,
  "fields": {
    "card": 368,
    "tag": 69
  }
},
{
  "model": "cards.cardtag",
  "pk": 2327,
  "fields": {
    "card": 368,
    "tag": 187
  }
},
{
  "model": "cards.cardtag",
  "pk": 2328,
  "fields": {
    "card": 368,
    "tag": 263
  }
},
{
  "model": "cards.cardtag",
  "pk": 2329,
  "fields": {
    "card": 368,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2330,
  "fields": {
    "card": 368,
    "tag": 1170
  }
},
{
  "model": "cards.cardtag",
  "pk": 2331,
  "fields": {
    "card": 369,
    "tag": 1219
  }
},
{
  "model": "cards.cardtag",
  "pk": 2332,
  "fields": {
    "card": 369,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 2333,
  "fields": {
    "card": 369,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2334,
  "fields": {
    "card": 369,
    "tag": 1294
  }
},
{
  "model": "cards.cardtag",
  "pk": 2335,
  "fields": {
    "card": 369,
    "tag": 1346
  }
},
{
  "model": "cards.cardtag",
  "pk": 2336,
  "fields": {
    "card": 369,
    "tag": 711
  }
},
{
  "model": "cards.cardtag",
  "pk": 2337,
  "fields": {
    "card": 369,
    "tag": 948
  }
},
{
  "model": "cards.cardtag",
  "pk": 2338,
  "fields": {
    "card": 370,
    "tag": 538
  }
},
{
  "model": "cards.cardtag",
  "pk": 2339,
  "fields": {
    "card": 370,
    "tag": 246
  }
},
{
  "model": "cards.cardtag",
  "pk": 2340,
  "fields": {
    "card": 370,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2341,
  "fields": {
    "card": 370,
    "tag": 712
  }
},
{
  "model": "cards.cardtag",
  "pk": 2342,
  "fields": {
    "card": 370,
    "tag": 1062
  }
},
{
  "model": "cards.cardtag",
  "pk": 2343,
  "fields": {
    "card": 370,
    "tag": 376
  }
},
{
  "model": "cards.cardtag",
  "pk": 2344,
  "fields": {
    "card": 371,
    "tag": 1020
  }
},
{
  "model": "cards.cardtag",
  "pk": 2345,
  "fields": {
    "card": 371,
    "tag": 696
  }
},
{
  "model": "cards.cardtag",
  "pk": 2346,
  "fields": {
    "card": 371,
    "tag": 468
  }
},
{
  "model": "cards.cardtag",
  "pk": 2347,
  "fields": {
    "card": 371,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2348,
  "fields": {
    "card": 371,
    "tag": 119
  }
},
{
  "model": "cards.cardtag",
  "pk": 2349,
  "fields": {
    "card": 371,
    "tag": 21
  }
},
{
  "model": "cards.cardtag",
  "pk": 2350,
  "fields": {
    "card": 371,
    "tag": 828
  }
},
{
  "model": "cards.cardtag",
  "pk": 2351,
  "fields": {
    "card": 372,
    "tag": 612
  }
},
{
  "model": "cards.cardtag",
  "pk": 2352,
  "fields": {
    "card": 372,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2353,
  "fields": {
    "card": 372,
    "tag": 1395
  }
},
{
  "model": "cards.cardtag",
  "pk": 2354,
  "fields": {
    "card": 372,
    "tag": 1293
  }
},
{
  "model": "cards.cardtag",
  "pk": 2355,
  "fields": {
    "card": 372,
    "tag": 22
  }
},
{
  "model": "cards.cardtag",
  "pk": 2356,
  "fields": {
    "card": 373,
    "tag": 1085
  }
},
{
  "model": "cards.cardtag",
  "pk": 2357,
  "fields": {
    "card": 373,
    "tag": 683
  }
},
{
  "model": "cards.cardtag",
  "pk": 2358,
  "fields": {
    "card": 373,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2359,
  "fields": {
    "card": 373,
    "tag": 1293
  }
},
{
  "model": "cards.cardtag",
  "pk": 2360,
  "fields": {
    "card": 373,
    "tag": 756
  }
},
{
  "model": "cards.cardtag",
  "pk": 2361,
  "fields": {
    "card": 373,
    "tag": 1004
  }
},
{
  "model": "cards.cardtag",
  "pk": 2362,
  "fields": {
    "card": 374,
    "tag": 268
  }
},
{
  "model": "cards.cardtag",
  "pk": 2363,
  "fields": {
    "card": 374,
    "tag": 68
  }
},
{
  "model": "cards.cardtag",
  "pk": 2364,
  "fields": {
    "card": 374,
    "tag": 864
  }
},
{
  "model": "cards.cardtag",
  "pk": 2365,
  "fields": {
    "card": 374,
    "tag": 740
  }
},
{
  "model": "cards.cardtag",
  "pk": 2366,
  "fields": {
    "card": 374,
    "tag": 726
  }
},
{
  "model": "cards.cardtag",
  "pk": 2367,
  "fields": {
    "card": 374,
    "tag": 786
  }
},
{
  "model": "cards.cardtag",
  "pk": 2368,
  "fields": {
    "card": 374,
    "tag": 1259
  }
},
{
  "model": "cards.cardtag",
  "pk": 2369,
  "fields": {
    "card": 375,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2370,
  "fields": {
    "card": 375,
    "tag": 599
  }
},
{
  "model": "cards.cardtag",
  "pk": 2371,
  "fields": {
    "card": 375,
    "tag": 951
  }
},
{
  "model": "cards.cardtag",
  "pk": 2372,
  "fields": {
    "card": 375,
    "tag": 1008
  }
},
{
  "model": "cards.cardtag",
  "pk": 2373,
  "fields": {
    "card": 375,
    "tag": 78
  }
},
{
  "model": "cards.cardtag",
  "pk": 2374,
  "fields": {
    "card": 375,
    "tag": 715
  }
},
{
  "model": "cards.cardtag",
  "pk": 2375,
  "fields": {
    "card": 376,
    "tag": 1291
  }
},
{
  "model": "cards.cardtag",
  "pk": 2376,
  "fields": {
    "card": 376,
    "tag": 994
  }
},
{
  "model": "cards.cardtag",
  "pk": 2377,
  "fields": {
    "card": 376,
    "tag": 219
  }
},
{
  "model": "cards.cardtag",
  "pk": 2378,
  "fields": {
    "card": 376,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2379,
  "fields": {
    "card": 376,
    "tag": 717
  }
},
{
  "model": "cards.cardtag",
  "pk": 2380,
  "fields": {
    "card": 376,
    "tag": 376
  }
},
{
  "model": "cards.cardtag",
  "pk": 2381,
  "fields": {
    "card": 377,
    "tag": 1062
  }
},
{
  "model": "cards.cardtag",
  "pk": 2382,
  "fields": {
    "card": 377,
    "tag": 538
  }
},
{
  "model": "cards.cardtag",
  "pk": 2383,
  "fields": {
    "card": 377,
    "tag": 347
  }
},
{
  "model": "cards.cardtag",
  "pk": 2384,
  "fields": {
    "card": 377,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2385,
  "fields": {
    "card": 377,
    "tag": 292
  }
},
{
  "model": "cards.cardtag",
  "pk": 2386,
  "fields": {
    "card": 377,
    "tag": 1330
  }
},
{
  "model": "cards.cardtag",
  "pk": 2387,
  "fields": {
    "card": 378,
    "tag": 687
  }
},
{
  "model": "cards.cardtag",
  "pk": 2388,
  "fields": {
    "card": 378,
    "tag": 722
  }
},
{
  "model": "cards.cardtag",
  "pk": 2389,
  "fields": {
    "card": 378,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2390,
  "fields": {
    "card": 378,
    "tag": 778
  }
},
{
  "model": "cards.cardtag",
  "pk": 2391,
  "fields": {
    "card": 378,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 2392,
  "fields": {
    "card": 378,
    "tag": 841
  }
},
{
  "model": "cards.cardtag",
  "pk": 2393,
  "fields": {
    "card": 379,
    "tag": 105
  }
},
{
  "model": "cards.cardtag",
  "pk": 2394,
  "fields": {
    "card": 379,
    "tag": 1076
  }
},
{
  "model": "cards.cardtag",
  "pk": 2395,
  "fields": {
    "card": 379,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2396,
  "fields": {
    "card": 379,
    "tag": 1125
  }
},
{
  "model": "cards.cardtag",
  "pk": 2397,
  "fields": {
    "card": 379,
    "tag": 669
  }
},
{
  "model": "cards.cardtag",
  "pk": 2398,
  "fields": {
    "card": 379,
    "tag": 563
  }
},
{
  "model": "cards.cardtag",
  "pk": 2399,
  "fields": {
    "card": 380,
    "tag": 1266
  }
},
{
  "model": "cards.cardtag",
  "pk": 2400,
  "fields": {
    "card": 380,
    "tag": 1217
  }
},
{
  "model": "cards.cardtag",
  "pk": 2401,
  "fields": {
    "card": 380,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2402,
  "fields": {
    "card": 380,
    "tag": 105
  }
},
{
  "model": "cards.cardtag",
  "pk": 2403,
  "fields": {
    "card": 380,
    "tag": 660
  }
},
{
  "model": "cards.cardtag",
  "pk": 2404,
  "fields": {
    "card": 380,
    "tag": 1076
  }
},
{
  "model": "cards.cardtag",
  "pk": 2405,
  "fields": {
    "card": 381,
    "tag": 1302
  }
},
{
  "model": "cards.cardtag",
  "pk": 2406,
  "fields": {
    "card": 381,
    "tag": 1218
  }
},
{
  "model": "cards.cardtag",
  "pk": 2407,
  "fields": {
    "card": 381,
    "tag": 150
  }
},
{
  "model": "cards.cardtag",
  "pk": 2408,
  "fields": {
    "card": 381,
    "tag": 491
  }
},
{
  "model": "cards.cardtag",
  "pk": 2409,
  "fields": {
    "card": 381,
    "tag": 1170
  }
},
{
  "model": "cards.cardtag",
  "pk": 2410,
  "fields": {
    "card": 381,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2411,
  "fields": {
    "card": 381,
    "tag": 194
  }
},
{
  "model": "cards.cardtag",
  "pk": 2412,
  "fields": {
    "card": 382,
    "tag": 261
  }
},
{
  "model": "cards.cardtag",
  "pk": 2413,
  "fields": {
    "card": 382,
    "tag": 207
  }
},
{
  "model": "cards.cardtag",
  "pk": 2414,
  "fields": {
    "card": 382,
    "tag": 805
  }
},
{
  "model": "cards.cardtag",
  "pk": 2415,
  "fields": {
    "card": 382,
    "tag": 1386
  }
},
{
  "model": "cards.cardtag",
  "pk": 2416,
  "fields": {
    "card": 382,
    "tag": 476
  }
},
{
  "model": "cards.cardtag",
  "pk": 2417,
  "fields": {
    "card": 382,
    "tag": 956
  }
},
{
  "model": "cards.cardtag",
  "pk": 2418,
  "fields": {
    "card": 383,
    "tag": 1281
  }
},
{
  "model": "cards.cardtag",
  "pk": 2419,
  "fields": {
    "card": 383,
    "tag": 1216
  }
},
{
  "model": "cards.cardtag",
  "pk": 2420,
  "fields": {
    "card": 383,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2421,
  "fields": {
    "card": 383,
    "tag": 111
  }
},
{
  "model": "cards.cardtag",
  "pk": 2422,
  "fields": {
    "card": 383,
    "tag": 744
  }
},
{
  "model": "cards.cardtag",
  "pk": 2423,
  "fields": {
    "card": 383,
    "tag": 173
  }
},
{
  "model": "cards.cardtag",
  "pk": 2424,
  "fields": {
    "card": 384,
    "tag": 1035
  }
},
{
  "model": "cards.cardtag",
  "pk": 2425,
  "fields": {
    "card": 384,
    "tag": 992
  }
},
{
  "model": "cards.cardtag",
  "pk": 2426,
  "fields": {
    "card": 384,
    "tag": 1323
  }
},
{
  "model": "cards.cardtag",
  "pk": 2427,
  "fields": {
    "card": 384,
    "tag": 756
  }
},
{
  "model": "cards.cardtag",
  "pk": 2428,
  "fields": {
    "card": 384,
    "tag": 664
  }
},
{
  "model": "cards.cardtag",
  "pk": 2429,
  "fields": {
    "card": 384,
    "tag": 683
  }
},
{
  "model": "cards.cardtag",
  "pk": 2430,
  "fields": {
    "card": 384,
    "tag": 395
  }
},
{
  "model": "cards.cardtag",
  "pk": 2431,
  "fields": {
    "card": 385,
    "tag": 676
  }
},
{
  "model": "cards.cardtag",
  "pk": 2432,
  "fields": {
    "card": 385,
    "tag": 1293
  }
},
{
  "model": "cards.cardtag",
  "pk": 2433,
  "fields": {
    "card": 385,
    "tag": 1012
  }
},
{
  "model": "cards.cardtag",
  "pk": 2434,
  "fields": {
    "card": 385,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2435,
  "fields": {
    "card": 386,
    "tag": 424
  }
},
{
  "model": "cards.cardtag",
  "pk": 2436,
  "fields": {
    "card": 386,
    "tag": 952
  }
},
{
  "model": "cards.cardtag",
  "pk": 2437,
  "fields": {
    "card": 386,
    "tag": 1255
  }
},
{
  "model": "cards.cardtag",
  "pk": 2438,
  "fields": {
    "card": 386,
    "tag": 706
  }
},
{
  "model": "cards.cardtag",
  "pk": 2439,
  "fields": {
    "card": 386,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2440,
  "fields": {
    "card": 386,
    "tag": 395
  }
},
{
  "model": "cards.cardtag",
  "pk": 2441,
  "fields": {
    "card": 387,
    "tag": 766
  }
},
{
  "model": "cards.cardtag",
  "pk": 2442,
  "fields": {
    "card": 387,
    "tag": 290
  }
},
{
  "model": "cards.cardtag",
  "pk": 2443,
  "fields": {
    "card": 387,
    "tag": 589
  }
},
{
  "model": "cards.cardtag",
  "pk": 2444,
  "fields": {
    "card": 387,
    "tag": 1095
  }
},
{
  "model": "cards.cardtag",
  "pk": 2445,
  "fields": {
    "card": 387,
    "tag": 468
  }
},
{
  "model": "cards.cardtag",
  "pk": 2446,
  "fields": {
    "card": 387,
    "tag": 817
  }
},
{
  "model": "cards.cardtag",
  "pk": 2447,
  "fields": {
    "card": 388,
    "tag": 413
  }
},
{
  "model": "cards.cardtag",
  "pk": 2448,
  "fields": {
    "card": 388,
    "tag": 898
  }
},
{
  "model": "cards.cardtag",
  "pk": 2449,
  "fields": {
    "card": 388,
    "tag": 266
  }
},
{
  "model": "cards.cardtag",
  "pk": 2450,
  "fields": {
    "card": 388,
    "tag": 683
  }
},
{
  "model": "cards.cardtag",
  "pk": 2451,
  "fields": {
    "card": 388,
    "tag": 494
  }
},
{
  "model": "cards.cardtag",
  "pk": 2452,
  "fields": {
    "card": 388,
    "tag": 1106
  }
},
{
  "model": "cards.cardtag",
  "pk": 2453,
  "fields": {
    "card": 389,
    "tag": 1285
  }
},
{
  "model": "cards.cardtag",
  "pk": 2454,
  "fields": {
    "card": 389,
    "tag": 168
  }
},
{
  "model": "cards.cardtag",
  "pk": 2455,
  "fields": {
    "card": 389,
    "tag": 758
  }
},
{
  "model": "cards.cardtag",
  "pk": 2456,
  "fields": {
    "card": 389,
    "tag": 1302
  }
},
{
  "model": "cards.cardtag",
  "pk": 2457,
  "fields": {
    "card": 389,
    "tag": 559
  }
},
{
  "model": "cards.cardtag",
  "pk": 2458,
  "fields": {
    "card": 389,
    "tag": 1174
  }
},
{
  "model": "cards.cardtag",
  "pk": 2459,
  "fields": {
    "card": 389,
    "tag": 364
  }
},
{
  "model": "cards.cardtag",
  "pk": 2460,
  "fields": {
    "card": 390,
    "tag": 1056
  }
},
{
  "model": "cards.cardtag",
  "pk": 2461,
  "fields": {
    "card": 390,
    "tag": 786
  }
},
{
  "model": "cards.cardtag",
  "pk": 2462,
  "fields": {
    "card": 390,
    "tag": 1397
  }
},
{
  "model": "cards.cardtag",
  "pk": 2463,
  "fields": {
    "card": 390,
    "tag": 144
  }
},
{
  "model": "cards.cardtag",
  "pk": 2464,
  "fields": {
    "card": 390,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2465,
  "fields": {
    "card": 390,
    "tag": 1202
  }
},
{
  "model": "cards.cardtag",
  "pk": 2466,
  "fields": {
    "card": 391,
    "tag": 1075
  }
},
{
  "model": "cards.cardtag",
  "pk": 2467,
  "fields": {
    "card": 391,
    "tag": 468
  }
},
{
  "model": "cards.cardtag",
  "pk": 2468,
  "fields": {
    "card": 391,
    "tag": 1168
  }
},
{
  "model": "cards.cardtag",
  "pk": 2469,
  "fields": {
    "card": 391,
    "tag": 41
  }
},
{
  "model": "cards.cardtag",
  "pk": 2470,
  "fields": {
    "card": 391,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2471,
  "fields": {
    "card": 391,
    "tag": 794
  }
},
{
  "model": "cards.cardtag",
  "pk": 2472,
  "fields": {
    "card": 392,
    "tag": 947
  }
},
{
  "model": "cards.cardtag",
  "pk": 2473,
  "fields": {
    "card": 392,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2474,
  "fields": {
    "card": 392,
    "tag": 759
  }
},
{
  "model": "cards.cardtag",
  "pk": 2475,
  "fields": {
    "card": 392,
    "tag": 624
  }
},
{
  "model": "cards.cardtag",
  "pk": 2476,
  "fields": {
    "card": 392,
    "tag": 217
  }
},
{
  "model": "cards.cardtag",
  "pk": 2477,
  "fields": {
    "card": 392,
    "tag": 1010
  }
},
{
  "model": "cards.cardtag",
  "pk": 2478,
  "fields": {
    "card": 393,
    "tag": 1183
  }
},
{
  "model": "cards.cardtag",
  "pk": 2479,
  "fields": {
    "card": 393,
    "tag": 677
  }
},
{
  "model": "cards.cardtag",
  "pk": 2480,
  "fields": {
    "card": 393,
    "tag": 400
  }
},
{
  "model": "cards.cardtag",
  "pk": 2481,
  "fields": {
    "card": 393,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2482,
  "fields": {
    "card": 393,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 2483,
  "fields": {
    "card": 393,
    "tag": 1146
  }
},
{
  "model": "cards.cardtag",
  "pk": 2484,
  "fields": {
    "card": 394,
    "tag": 697
  }
},
{
  "model": "cards.cardtag",
  "pk": 2485,
  "fields": {
    "card": 394,
    "tag": 295
  }
},
{
  "model": "cards.cardtag",
  "pk": 2486,
  "fields": {
    "card": 394,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 2487,
  "fields": {
    "card": 394,
    "tag": 1179
  }
},
{
  "model": "cards.cardtag",
  "pk": 2488,
  "fields": {
    "card": 394,
    "tag": 274
  }
},
{
  "model": "cards.cardtag",
  "pk": 2489,
  "fields": {
    "card": 394,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2490,
  "fields": {
    "card": 395,
    "tag": 288
  }
},
{
  "model": "cards.cardtag",
  "pk": 2491,
  "fields": {
    "card": 395,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 2492,
  "fields": {
    "card": 395,
    "tag": 706
  }
},
{
  "model": "cards.cardtag",
  "pk": 2493,
  "fields": {
    "card": 395,
    "tag": 1192
  }
},
{
  "model": "cards.cardtag",
  "pk": 2494,
  "fields": {
    "card": 395,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2495,
  "fields": {
    "card": 395,
    "tag": 395
  }
},
{
  "model": "cards.cardtag",
  "pk": 2496,
  "fields": {
    "card": 396,
    "tag": 244
  }
},
{
  "model": "cards.cardtag",
  "pk": 2497,
  "fields": {
    "card": 396,
    "tag": 1276
  }
},
{
  "model": "cards.cardtag",
  "pk": 2498,
  "fields": {
    "card": 396,
    "tag": 683
  }
},
{
  "model": "cards.cardtag",
  "pk": 2499,
  "fields": {
    "card": 396,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2500,
  "fields": {
    "card": 396,
    "tag": 892
  }
},
{
  "model": "cards.cardtag",
  "pk": 2501,
  "fields": {
    "card": 396,
    "tag": 884
  }
},
{
  "model": "cards.cardtag",
  "pk": 2502,
  "fields": {
    "card": 397,
    "tag": 865
  }
},
{
  "model": "cards.cardtag",
  "pk": 2503,
  "fields": {
    "card": 397,
    "tag": 1296
  }
},
{
  "model": "cards.cardtag",
  "pk": 2504,
  "fields": {
    "card": 397,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2505,
  "fields": {
    "card": 397,
    "tag": 191
  }
},
{
  "model": "cards.cardtag",
  "pk": 2506,
  "fields": {
    "card": 397,
    "tag": 259
  }
},
{
  "model": "cards.cardtag",
  "pk": 2507,
  "fields": {
    "card": 397,
    "tag": 478
  }
},
{
  "model": "cards.cardtag",
  "pk": 2508,
  "fields": {
    "card": 398,
    "tag": 693
  }
},
{
  "model": "cards.cardtag",
  "pk": 2509,
  "fields": {
    "card": 398,
    "tag": 266
  }
},
{
  "model": "cards.cardtag",
  "pk": 2510,
  "fields": {
    "card": 398,
    "tag": 756
  }
},
{
  "model": "cards.cardtag",
  "pk": 2511,
  "fields": {
    "card": 398,
    "tag": 706
  }
},
{
  "model": "cards.cardtag",
  "pk": 2512,
  "fields": {
    "card": 398,
    "tag": 282
  }
},
{
  "model": "cards.cardtag",
  "pk": 2513,
  "fields": {
    "card": 398,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2514,
  "fields": {
    "card": 399,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2515,
  "fields": {
    "card": 399,
    "tag": 1062
  }
},
{
  "model": "cards.cardtag",
  "pk": 2516,
  "fields": {
    "card": 399,
    "tag": 256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2517,
  "fields": {
    "card": 399,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 2518,
  "fields": {
    "card": 399,
    "tag": 218
  }
},
{
  "model": "cards.cardtag",
  "pk": 2519,
  "fields": {
    "card": 399,
    "tag": 677
  }
},
{
  "model": "cards.cardtag",
  "pk": 2520,
  "fields": {
    "card": 400,
    "tag": 1286
  }
},
{
  "model": "cards.cardtag",
  "pk": 2521,
  "fields": {
    "card": 400,
    "tag": 871
  }
},
{
  "model": "cards.cardtag",
  "pk": 2522,
  "fields": {
    "card": 400,
    "tag": 766
  }
},
{
  "model": "cards.cardtag",
  "pk": 2523,
  "fields": {
    "card": 400,
    "tag": 290
  }
},
{
  "model": "cards.cardtag",
  "pk": 2524,
  "fields": {
    "card": 400,
    "tag": 589
  }
},
{
  "model": "cards.cardtag",
  "pk": 2525,
  "fields": {
    "card": 400,
    "tag": 1266
  }
},
{
  "model": "cards.cardtag",
  "pk": 2526,
  "fields": {
    "card": 400,
    "tag": 28
  }
},
{
  "model": "cards.cardtag",
  "pk": 2527,
  "fields": {
    "card": 401,
    "tag": 105
  }
},
{
  "model": "cards.cardtag",
  "pk": 2528,
  "fields": {
    "card": 401,
    "tag": 289
  }
},
{
  "model": "cards.cardtag",
  "pk": 2529,
  "fields": {
    "card": 401,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2530,
  "fields": {
    "card": 401,
    "tag": 338
  }
},
{
  "model": "cards.cardtag",
  "pk": 2531,
  "fields": {
    "card": 401,
    "tag": 1076
  }
},
{
  "model": "cards.cardtag",
  "pk": 2532,
  "fields": {
    "card": 401,
    "tag": 1193
  }
},
{
  "model": "cards.cardtag",
  "pk": 2533,
  "fields": {
    "card": 402,
    "tag": 262
  }
},
{
  "model": "cards.cardtag",
  "pk": 2534,
  "fields": {
    "card": 402,
    "tag": 494
  }
},
{
  "model": "cards.cardtag",
  "pk": 2535,
  "fields": {
    "card": 402,
    "tag": 1106
  }
},
{
  "model": "cards.cardtag",
  "pk": 2536,
  "fields": {
    "card": 402,
    "tag": 327
  }
},
{
  "model": "cards.cardtag",
  "pk": 2537,
  "fields": {
    "card": 402,
    "tag": 298
  }
},
{
  "model": "cards.cardtag",
  "pk": 2538,
  "fields": {
    "card": 402,
    "tag": 712
  }
},
{
  "model": "cards.cardtag",
  "pk": 2539,
  "fields": {
    "card": 403,
    "tag": 136
  }
},
{
  "model": "cards.cardtag",
  "pk": 2540,
  "fields": {
    "card": 403,
    "tag": 658
  }
},
{
  "model": "cards.cardtag",
  "pk": 2541,
  "fields": {
    "card": 403,
    "tag": 714
  }
},
{
  "model": "cards.cardtag",
  "pk": 2542,
  "fields": {
    "card": 403,
    "tag": 844
  }
},
{
  "model": "cards.cardtag",
  "pk": 2543,
  "fields": {
    "card": 403,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2544,
  "fields": {
    "card": 403,
    "tag": 142
  }
},
{
  "model": "cards.cardtag",
  "pk": 2545,
  "fields": {
    "card": 404,
    "tag": 105
  }
},
{
  "model": "cards.cardtag",
  "pk": 2546,
  "fields": {
    "card": 404,
    "tag": 1352
  }
},
{
  "model": "cards.cardtag",
  "pk": 2547,
  "fields": {
    "card": 404,
    "tag": 1266
  }
},
{
  "model": "cards.cardtag",
  "pk": 2548,
  "fields": {
    "card": 404,
    "tag": 245
  }
},
{
  "model": "cards.cardtag",
  "pk": 2549,
  "fields": {
    "card": 404,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2550,
  "fields": {
    "card": 405,
    "tag": 240
  }
},
{
  "model": "cards.cardtag",
  "pk": 2551,
  "fields": {
    "card": 405,
    "tag": 441
  }
},
{
  "model": "cards.cardtag",
  "pk": 2552,
  "fields": {
    "card": 405,
    "tag": 646
  }
},
{
  "model": "cards.cardtag",
  "pk": 2553,
  "fields": {
    "card": 405,
    "tag": 397
  }
},
{
  "model": "cards.cardtag",
  "pk": 2554,
  "fields": {
    "card": 405,
    "tag": 291
  }
},
{
  "model": "cards.cardtag",
  "pk": 2555,
  "fields": {
    "card": 405,
    "tag": 879
  }
},
{
  "model": "cards.cardtag",
  "pk": 2556,
  "fields": {
    "card": 405,
    "tag": 764
  }
},
{
  "model": "cards.cardtag",
  "pk": 2557,
  "fields": {
    "card": 405,
    "tag": 1381
  }
},
{
  "model": "cards.cardtag",
  "pk": 2558,
  "fields": {
    "card": 405,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2559,
  "fields": {
    "card": 406,
    "tag": 1204
  }
},
{
  "model": "cards.cardtag",
  "pk": 2560,
  "fields": {
    "card": 406,
    "tag": 115
  }
},
{
  "model": "cards.cardtag",
  "pk": 2561,
  "fields": {
    "card": 406,
    "tag": 764
  }
},
{
  "model": "cards.cardtag",
  "pk": 2562,
  "fields": {
    "card": 406,
    "tag": 490
  }
},
{
  "model": "cards.cardtag",
  "pk": 2563,
  "fields": {
    "card": 406,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2564,
  "fields": {
    "card": 406,
    "tag": 1059
  }
},
{
  "model": "cards.cardtag",
  "pk": 2565,
  "fields": {
    "card": 407,
    "tag": 1266
  }
},
{
  "model": "cards.cardtag",
  "pk": 2566,
  "fields": {
    "card": 407,
    "tag": 133
  }
},
{
  "model": "cards.cardtag",
  "pk": 2567,
  "fields": {
    "card": 407,
    "tag": 1076
  }
},
{
  "model": "cards.cardtag",
  "pk": 2568,
  "fields": {
    "card": 407,
    "tag": 105
  }
},
{
  "model": "cards.cardtag",
  "pk": 2569,
  "fields": {
    "card": 407,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2570,
  "fields": {
    "card": 408,
    "tag": 53
  }
},
{
  "model": "cards.cardtag",
  "pk": 2571,
  "fields": {
    "card": 408,
    "tag": 364
  }
},
{
  "model": "cards.cardtag",
  "pk": 2572,
  "fields": {
    "card": 408,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 2573,
  "fields": {
    "card": 408,
    "tag": 954
  }
},
{
  "model": "cards.cardtag",
  "pk": 2574,
  "fields": {
    "card": 408,
    "tag": 1026
  }
},
{
  "model": "cards.cardtag",
  "pk": 2575,
  "fields": {
    "card": 408,
    "tag": 1370
  }
},
{
  "model": "cards.cardtag",
  "pk": 2576,
  "fields": {
    "card": 409,
    "tag": 471
  }
},
{
  "model": "cards.cardtag",
  "pk": 2577,
  "fields": {
    "card": 409,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2578,
  "fields": {
    "card": 409,
    "tag": 1249
  }
},
{
  "model": "cards.cardtag",
  "pk": 2579,
  "fields": {
    "card": 409,
    "tag": 884
  }
},
{
  "model": "cards.cardtag",
  "pk": 2580,
  "fields": {
    "card": 409,
    "tag": 7
  }
},
{
  "model": "cards.cardtag",
  "pk": 2581,
  "fields": {
    "card": 409,
    "tag": 1021
  }
},
{
  "model": "cards.cardtag",
  "pk": 2582,
  "fields": {
    "card": 410,
    "tag": 706
  }
},
{
  "model": "cards.cardtag",
  "pk": 2583,
  "fields": {
    "card": 410,
    "tag": 1142
  }
},
{
  "model": "cards.cardtag",
  "pk": 2584,
  "fields": {
    "card": 410,
    "tag": 827
  }
},
{
  "model": "cards.cardtag",
  "pk": 2585,
  "fields": {
    "card": 410,
    "tag": 756
  }
},
{
  "model": "cards.cardtag",
  "pk": 2586,
  "fields": {
    "card": 410,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2587,
  "fields": {
    "card": 410,
    "tag": 1035
  }
},
{
  "model": "cards.cardtag",
  "pk": 2588,
  "fields": {
    "card": 410,
    "tag": 690
  }
},
{
  "model": "cards.cardtag",
  "pk": 2589,
  "fields": {
    "card": 410,
    "tag": 1044
  }
},
{
  "model": "cards.cardtag",
  "pk": 2590,
  "fields": {
    "card": 411,
    "tag": 706
  }
},
{
  "model": "cards.cardtag",
  "pk": 2591,
  "fields": {
    "card": 411,
    "tag": 275
  }
},
{
  "model": "cards.cardtag",
  "pk": 2592,
  "fields": {
    "card": 411,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2593,
  "fields": {
    "card": 411,
    "tag": 664
  }
},
{
  "model": "cards.cardtag",
  "pk": 2594,
  "fields": {
    "card": 411,
    "tag": 1356
  }
},
{
  "model": "cards.cardtag",
  "pk": 2595,
  "fields": {
    "card": 411,
    "tag": 827
  }
},
{
  "model": "cards.cardtag",
  "pk": 2596,
  "fields": {
    "card": 412,
    "tag": 1344
  }
},
{
  "model": "cards.cardtag",
  "pk": 2597,
  "fields": {
    "card": 412,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 2598,
  "fields": {
    "card": 412,
    "tag": 1293
  }
},
{
  "model": "cards.cardtag",
  "pk": 2599,
  "fields": {
    "card": 412,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2600,
  "fields": {
    "card": 412,
    "tag": 908
  }
},
{
  "model": "cards.cardtag",
  "pk": 2601,
  "fields": {
    "card": 412,
    "tag": 531
  }
},
{
  "model": "cards.cardtag",
  "pk": 2602,
  "fields": {
    "card": 413,
    "tag": 343
  }
},
{
  "model": "cards.cardtag",
  "pk": 2603,
  "fields": {
    "card": 413,
    "tag": 502
  }
},
{
  "model": "cards.cardtag",
  "pk": 2604,
  "fields": {
    "card": 413,
    "tag": 1137
  }
},
{
  "model": "cards.cardtag",
  "pk": 2605,
  "fields": {
    "card": 413,
    "tag": 112
  }
},
{
  "model": "cards.cardtag",
  "pk": 2606,
  "fields": {
    "card": 413,
    "tag": 801
  }
},
{
  "model": "cards.cardtag",
  "pk": 2607,
  "fields": {
    "card": 413,
    "tag": 132
  }
},
{
  "model": "cards.cardtag",
  "pk": 2608,
  "fields": {
    "card": 414,
    "tag": 1101
  }
},
{
  "model": "cards.cardtag",
  "pk": 2609,
  "fields": {
    "card": 414,
    "tag": 373
  }
},
{
  "model": "cards.cardtag",
  "pk": 2610,
  "fields": {
    "card": 414,
    "tag": 406
  }
},
{
  "model": "cards.cardtag",
  "pk": 2611,
  "fields": {
    "card": 414,
    "tag": 200
  }
},
{
  "model": "cards.cardtag",
  "pk": 2612,
  "fields": {
    "card": 414,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2613,
  "fields": {
    "card": 415,
    "tag": 691
  }
},
{
  "model": "cards.cardtag",
  "pk": 2614,
  "fields": {
    "card": 415,
    "tag": 944
  }
},
{
  "model": "cards.cardtag",
  "pk": 2615,
  "fields": {
    "card": 415,
    "tag": 1165
  }
},
{
  "model": "cards.cardtag",
  "pk": 2616,
  "fields": {
    "card": 415,
    "tag": 1139
  }
},
{
  "model": "cards.cardtag",
  "pk": 2617,
  "fields": {
    "card": 415,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2618,
  "fields": {
    "card": 416,
    "tag": 924
  }
},
{
  "model": "cards.cardtag",
  "pk": 2619,
  "fields": {
    "card": 416,
    "tag": 1366
  }
},
{
  "model": "cards.cardtag",
  "pk": 2620,
  "fields": {
    "card": 416,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2621,
  "fields": {
    "card": 416,
    "tag": 1302
  }
},
{
  "model": "cards.cardtag",
  "pk": 2622,
  "fields": {
    "card": 416,
    "tag": 1034
  }
},
{
  "model": "cards.cardtag",
  "pk": 2623,
  "fields": {
    "card": 416,
    "tag": 1225
  }
},
{
  "model": "cards.cardtag",
  "pk": 2624,
  "fields": {
    "card": 417,
    "tag": 915
  }
},
{
  "model": "cards.cardtag",
  "pk": 2625,
  "fields": {
    "card": 417,
    "tag": 971
  }
},
{
  "model": "cards.cardtag",
  "pk": 2626,
  "fields": {
    "card": 417,
    "tag": 1064
  }
},
{
  "model": "cards.cardtag",
  "pk": 2627,
  "fields": {
    "card": 417,
    "tag": 503
  }
},
{
  "model": "cards.cardtag",
  "pk": 2628,
  "fields": {
    "card": 417,
    "tag": 734
  }
},
{
  "model": "cards.cardtag",
  "pk": 2629,
  "fields": {
    "card": 417,
    "tag": 1256
  }
},
{
  "model": "cards.cardtag",
  "pk": 2630,
  "fields": {
    "card": 418,
    "tag": 635
  }
},
{
  "model": "cards.cardtag",
  "pk": 2631,
  "fields": {
    "card": 418,
    "tag": 639
  }
},
{
  "model": "cards.cardtag",
  "pk": 2632,
  "fields": {
    "card": 418,
    "tag": 1227
  }
},
{
  "model": "cards.cardtag",
  "pk": 2633,
  "fields": {
    "card": 418,
    "tag": 895
  }
},
{
  "model": "cards.cardtag",
  "pk": 2634,
  "fields": {
    "card": 418,
    "tag": 887
  }
},
{
  "model": "cards.cardtag",
  "pk": 2635,
  "fields": {
    "card": 418,
    "tag": 360
  }
},
{
  "model": "cards.cardtag",
  "pk": 2636,
  "fields": {
    "card": 418,
    "tag": 946
  }
},
{
  "model": "cards.cardtag",
  "pk": 2637,
  "fields": {
    "card": 418,
    "tag": 931
  }
},
{
  "model": "cards.cardtag",
  "pk": 2638,
  "fields": {
    "card": 418,
    "tag": 1025
  }
},
{
  "model": "cards.cardtag",
  "pk": 2639,
  "fields": {
    "card": 419,
    "tag": 694
  }
},
{
  "model": "cards.cardtag",
  "pk": 2640,
  "fields": {
    "card": 419,
    "tag": 304
  }
},
{
  "model": "cards.cardtag",
  "pk": 2641,
  "fields": {
    "card": 419,
    "tag": 984
  }
},
{
  "model": "cards.cardtag",
  "pk": 2642,
  "fields": {
    "card": 419,
    "tag": 633
  }
},
{
  "model": "cards.cardtag",
  "pk": 2643,
  "fields": {
    "card": 419,
    "tag": 222
  }
},
{
  "model": "cards.cardtag",
  "pk": 2644,
  "fields": {
    "card": 419,
    "tag": 341
  }
},
{
  "model": "cards.cardtag",
  "pk": 2645,
  "fields": {
    "card": 419,
    "tag": 548
  }
},
{
  "model": "cards.cardtag",
  "pk": 2646,
  "fields": {
    "card": 420,
    "tag": 525
  }
},
{
  "model": "cards.cardtag",
  "pk": 2647,
  "fields": {
    "card": 420,
    "tag": 737
  }
},
{
  "model": "cards.cardtag",
  "pk": 2648,
  "fields": {
    "card": 420,
    "tag": 1151
  }
},
{
  "model": "cards.cardtag",
  "pk": 2649,
  "fields": {
    "card": 420,
    "tag": 1197
  }
},
{
  "model": "cards.cardtag",
  "pk": 2650,
  "fields": {
    "card": 420,
    "tag": 666
  }
},
{
  "model": "cards.cardtag",
  "pk": 2651,
  "fields": {
    "card": 420,
    "tag": 826
  }
},
{
  "model": "cards.cardtag",
  "pk": 2652,
  "fields": {
    "card": 420,
    "tag": 716
  }
},
{
  "model": "cards.cardtag",
  "pk": 2653,
  "fields": {
    "card": 421,
    "tag": 88
  }
},
{
  "model": "cards.cardtag",
  "pk": 2654,
  "fields": {
    "card": 421,
    "tag": 716
  }
},
{
  "model": "cards.cardtag",
  "pk": 2655,
  "fields": {
    "card": 421,
    "tag": 1058
  }
},
{
  "model": "cards.cardtag",
  "pk": 2656,
  "fields": {
    "card": 421,
    "tag": 1039
  }
},
{
  "model": "cards.cardtag",
  "pk": 2657,
  "fields": {
    "card": 421,
    "tag": 19
  }
},
{
  "model": "cards.cardtag",
  "pk": 2658,
  "fields": {
    "card": 422,
    "tag": 701
  }
},
{
  "model": "cards.cardtag",
  "pk": 2659,
  "fields": {
    "card": 422,
    "tag": 716
  }
},
{
  "model": "cards.cardtag",
  "pk": 2660,
  "fields": {
    "card": 422,
    "tag": 1115
  }
},
{
  "model": "cards.cardtag",
  "pk": 2661,
  "fields": {
    "card": 422,
    "tag": 19
  }
},
{
  "model": "cards.cardtag",
  "pk": 2662,
  "fields": {
    "card": 422,
    "tag": 1107
  }
},
{
  "model": "cards.cardtag",
  "pk": 2663,
  "fields": {
    "card": 422,
    "tag": 826
  }
},
{
  "model": "cards.cardtag",
  "pk": 2664,
  "fields": {
    "card": 423,
    "tag": 716
  }
},
{
  "model": "cards.cardtag",
  "pk": 2665,
  "fields": {
    "card": 423,
    "tag": 859
  }
},
{
  "model": "cards.cardtag",
  "pk": 2666,
  "fields": {
    "card": 423,
    "tag": 1181
  }
},
{
  "model": "cards.cardtag",
  "pk": 2667,
  "fields": {
    "card": 423,
    "tag": 19
  }
},
{
  "model": "cards.cardtag",
  "pk": 2668,
  "fields": {
    "card": 423,
    "tag": 464
  }
},
{
  "model": "cards.cardtag",
  "pk": 2669,
  "fields": {
    "card": 423,
    "tag": 826
  }
},
{
  "model": "cards.cardtag",
  "pk": 2670,
  "fields": {
    "card": 424,
    "tag": 65
  }
},
{
  "model": "cards.cardtag",
  "pk": 2671,
  "fields": {
    "card": 424,
    "tag": 593
  }
},
{
  "model": "cards.cardtag",
  "pk": 2672,
  "fields": {
    "card": 424,
    "tag": 19
  }
},
{
  "model": "cards.cardtag",
  "pk": 2673,
  "fields": {
    "card": 424,
    "tag": 716
  }
},
{
  "model": "cards.cardtag",
  "pk": 2674,
  "fields": {
    "card": 424,
    "tag": 1151
  }
},
{
  "model": "cards.cardtag",
  "pk": 2675,
  "fields": {
    "card": 424,
    "tag": 949
  }
},
{
  "model": "cards.cardtag",
  "pk": 2676,
  "fields": {
    "card": 425,
    "tag": 894
  }
},
{
  "model": "cards.cardtag",
  "pk": 2677,
  "fields": {
    "card": 425,
    "tag": 19
  }
},
{
  "model": "cards.cardtag",
  "pk": 2678,
  "fields": {
    "card": 425,
    "tag": 159
  }
},
{
  "model": "cards.cardtag",
  "pk": 2679,
  "fields": {
    "card": 425,
    "tag": 716
  }
},
{
  "model": "cards.cardtag",
  "pk": 2680,
  "fields": {
    "card": 425,
    "tag": 407
  }
},
{
  "model": "cards.cardtag",
  "pk": 2681,
  "fields": {
    "card": 425,
    "tag": 1365
  }
},
{
  "model": "cards.cardtag",
  "pk": 2682,
  "fields": {
    "card": 426,
    "tag": 894
  }
},
{
  "model": "cards.cardtag",
  "pk": 2683,
  "fields": {
    "card": 426,
    "tag": 988
  }
},
{
  "model": "cards.cardtag",
  "pk": 2684,
  "fields": {
    "card": 426,
    "tag": 510
  }
},
{
  "model": "cards.cardtag",
  "pk": 2685,
  "fields": {
    "card": 426,
    "tag": 342
  }
},
{
  "model": "cards.cardtag",
  "pk": 2686,
  "fields": {
    "card": 426,
    "tag": 792
  }
},
{
  "model": "cards.cardtag",
  "pk": 2687,
  "fields": {
    "card": 426,
    "tag": 1222
  }
},
{
  "model": "cards.cardtag",
  "pk": 2688,
  "fields": {
    "card": 426,
    "tag": 680
  }
},
{
  "model": "cards.cardtag",
  "pk": 2689,
  "fields": {
    "card": 426,
    "tag": 1144
  }
},
{
  "model": "cards.cardtag",
  "pk": 2690,
  "fields": {
    "card": 427,
    "tag": 899
  }
},
{
  "model": "cards.cardtag",
  "pk": 2691,
  "fields": {
    "card": 427,
    "tag": 197
  }
},
{
  "model": "cards.cardtag",
  "pk": 2692,
  "fields": {
    "card": 427,
    "tag": 633
  }
},
{
  "model": "cards.cardtag",
  "pk": 2693,
  "fields": {
    "card": 427,
    "tag": 65
  }
},
{
  "model": "cards.cardtag",
  "pk": 2694,
  "fields": {
    "card": 427,
    "tag": 1354
  }
},
{
  "model": "cards.cardtag",
  "pk": 2695,
  "fields": {
    "card": 427,
    "tag": 19
  }
},
{
  "model": "cards.cardtag",
  "pk": 2696,
  "fields": {
    "card": 428,
    "tag": 42
  }
},
{
  "model": "cards.cardtag",
  "pk": 2697,
  "fields": {
    "card": 428,
    "tag": 636
  }
},
{
  "model": "cards.cardtag",
  "pk": 2698,
  "fields": {
    "card": 428,
    "tag": 1230
  }
},
{
  "model": "cards.cardtag",
  "pk": 2699,
  "fields": {
    "card": 428,
    "tag": 688
  }
},
{
  "model": "cards.cardtag",
  "pk": 2700,
  "fields": {
    "card": 428,
    "tag": 19
  }
},
{
  "model": "cards.cardtag",
  "pk": 2701,
  "fields": {
    "card": 429,
    "tag": 374
  }
},
{
  "model": "cards.cardtag",
  "pk": 2702,
  "fields": {
    "card": 429,
    "tag": 870
  }
},
{
  "model": "cards.cardtag",
  "pk": 2703,
  "fields": {
    "card": 429,
    "tag": 911
  }
},
{
  "model": "cards.cardtag",
  "pk": 2704,
  "fields": {
    "card": 429,
    "tag": 430
  }
},
{
  "model": "cards.cardtag",
  "pk": 2705,
  "fields": {
    "card": 429,
    "tag": 19
  }
},
{
  "model": "cards.cardtag",
  "pk": 2706,
  "fields": {
    "card": 429,
    "tag": 1090
  }
},
{
  "model": "cards.cardtag",
  "pk": 2707,
  "fields": {
    "card": 430,
    "tag": 19
  }
},
{
  "model": "cards.cardtag",
  "pk": 2708,
  "fields": {
    "card": 430,
    "tag": 798
  }
},
{
  "model": "cards.cardtag",
  "pk": 2709,
  "fields": {
    "card": 430,
    "tag": 458
  }
},
{
  "model": "cards.cardtag",
  "pk": 2710,
  "fields": {
    "card": 430,
    "tag": 1237
  }
},
{
  "model": "cards.cardtag",
  "pk": 2711,
  "fields": {
    "card": 430,
    "tag": 530
  }
},
{
  "model": "cards.cardtag",
  "pk": 2712,
  "fields": {
    "card": 430,
    "tag": 1268
  }
},
{
  "model": "cards.cardtag",
  "pk": 2713,
  "fields": {
    "card": 431,
    "tag": 810
  }
},
{
  "model": "cards.cardtag",
  "pk": 2714,
  "fields": {
    "card": 431,
    "tag": 636
  }
},
{
  "model": "cards.cardtag",
  "pk": 2715,
  "fields": {
    "card": 431,
    "tag": 716
  }
},
{
  "model": "cards.cardtag",
  "pk": 2716,
  "fields": {
    "card": 431,
    "tag": 19
  }
},
{
  "model": "cards.cardtag",
  "pk": 2717,
  "fields": {
    "card": 431,
    "tag": 871
  }
},
{
  "model": "cards.cardtag",
  "pk": 2718,
  "fields": {
    "card": 431,
    "tag": 776
  }
},
{
  "model": "cards.cardtag",
  "pk": 2719,
  "fields": {
    "card": 432,
    "tag": 636
  }
},
{
  "model": "cards.cardtag",
  "pk": 2720,
  "fields": {
    "card": 432,
    "tag": 35
  }
},
{
  "model": "cards.cardtag",
  "pk": 2721,
  "fields": {
    "card": 432,
    "tag": 810
  }
},
{
  "model": "cards.cardtag",
  "pk": 2722,
  "fields": {
    "card": 432,
    "tag": 19
  }
},
{
  "model": "cards.cardtag",
  "pk": 2723,
  "fields": {
    "card": 432,
    "tag": 716
  }
},
{
  "model": "cards.cardtag",
  "pk": 2724,
  "fields": {
    "card": 433,
    "tag": 1285
  }
},
{
  "model": "cards.cardtag",
  "pk": 2725,
  "fields": {
    "card": 433,
    "tag": 226
  }
},
{
  "model": "cards.cardtag",
  "pk": 2726,
  "fields": {
    "card": 433,
    "tag": 636
  }
},
{
  "model": "cards.cardtag",
  "pk": 2727,
  "fields": {
    "card": 433,
    "tag": 662
  }
},
{
  "model": "cards.cardtag",
  "pk": 2728,
  "fields": {
    "card": 433,
    "tag": 911
  }
},
{
  "model": "cards.cardtag",
  "pk": 2729,
  "fields": {
    "card": 433,
    "tag": 689
  }
},
{
  "model": "cards.cardtag",
  "pk": 2730,
  "fields": {
    "card": 433,
    "tag": 19
  }
},
{
  "model": "cards.cardtag",
  "pk": 2731,
  "fields": {
    "card": 434,
    "tag": 911
  }
},
{
  "model": "cards.cardtag",
  "pk": 2732,
  "fields": {
    "card": 434,
    "tag": 19
  }
},
{
  "model": "cards.cardtag",
  "pk": 2733,
  "fields": {
    "card": 434,
    "tag": 981
  }
},
{
  "model": "cards.cardtag",
  "pk": 2734,
  "fields": {
    "card": 434,
    "tag": 976
  }
},
{
  "model": "cards.cardtag",
  "pk": 2735,
  "fields": {
    "card": 434,
    "tag": 353
  }
},
{
  "model": "cards.cardtag",
  "pk": 2736,
  "fields": {
    "card": 434,
    "tag": 965
  }
},
{
  "model": "cards.cardtag",
  "pk": 2737,
  "fields": {
    "card": 434,
    "tag": 621
  }
},
{
  "model": "cards.cardtag",
  "pk": 2738,
  "fields": {
    "card": 435,
    "tag": 911
  }
},
{
  "model": "cards.cardtag",
  "pk": 2739,
  "fields": {
    "card": 435,
    "tag": 981
  }
},
{
  "model": "cards.cardtag",
  "pk": 2740,
  "fields": {
    "card": 435,
    "tag": 1114
  }
},
{
  "model": "cards.cardtag",
  "pk": 2741,
  "fields": {
    "card": 435,
    "tag": 177
  }
},
{
  "model": "cards.cardtag",
  "pk": 2742,
  "fields": {
    "card": 435,
    "tag": 19
  }
},
{
  "model": "cards.cardtag",
  "pk": 2743,
  "fields": {
    "card": 435,
    "tag": 645
  }
},
{
  "model": "cards.cardtag",
  "pk": 2744,
  "fields": {
    "card": 436,
    "tag": 226
  }
},
{
  "model": "cards.cardtag",
  "pk": 2745,
  "fields": {
    "card": 436,
    "tag": 45
  }
},
{
  "model": "cards.cardtag",
  "pk": 2746,
  "fields": {
    "card": 436,
    "tag": 602
  }
},
{
  "model": "cards.cardtag",
  "pk": 2747,
  "fields": {
    "card": 436,
    "tag": 93
  }
},
{
  "model": "cards.cardtag",
  "pk": 2748,
  "fields": {
    "card": 436,
    "tag": 716
  }
},
{
  "model": "cards.cardtag",
  "pk": 2749,
  "fields": {
    "card": 436,
    "tag": 19
  }
},
{
  "model": "cards.cardtag",
  "pk": 2750,
  "fields": {
    "card": 437,
    "tag": 226
  }
},
{
  "model": "cards.cardtag",
  "pk": 2751,
  "fields": {
    "card": 437,
    "tag": 1372
  }
},
{
  "model": "cards.cardtag",
  "pk": 2752,
  "fields": {
    "card": 437,
    "tag": 923
  }
},
{
  "model": "cards.cardtag",
  "pk": 2753,
  "fields": {
    "card": 437,
    "tag": 1162
  }
},
{
  "model": "cards.cardtag",
  "pk": 2754,
  "fields": {
    "card": 437,
    "tag": 317
  }
},
{
  "model": "cards.cardtag",
  "pk": 2755,
  "fields": {
    "card": 437,
    "tag": 19
  }
},
{
  "model": "cards.cardtag",
  "pk": 2756,
  "fields": {
    "card": 438,
    "tag": 393
  }
},
{
  "model": "cards.cardtag",
  "pk": 2757,
  "fields": {
    "card": 438,
    "tag": 101
  }
},
{
  "model": "cards.cardtag",
  "pk": 2758,
  "fields": {
    "card": 438,
    "tag": 546
  }
},
{
  "model": "cards.cardtag",
  "pk": 2759,
  "fields": {
    "card": 438,
    "tag": 335
  }
},
{
  "model": "cards.cardtag",
  "pk": 2760,
  "fields": {
    "card": 438,
    "tag": 391
  }
},
{
  "model": "cards.cardtag",
  "pk": 2761,
  "fields": {
    "card": 438,
    "tag": 871
  }
},
{
  "model": "cards.cardtag",
  "pk": 2762,
  "fields": {
    "card": 439,
    "tag": 542
  }
},
{
  "model": "cards.cardtag",
  "pk": 2763,
  "fields": {
    "card": 439,
    "tag": 1126
  }
},
{
  "model": "cards.cardtag",
  "pk": 2764,
  "fields": {
    "card": 439,
    "tag": 1316
  }
},
{
  "model": "cards.cardtag",
  "pk": 2765,
  "fields": {
    "card": 439,
    "tag": 821
  }
},
{
  "model": "cards.cardtag",
  "pk": 2766,
  "fields": {
    "card": 439,
    "tag": 672
  }
},
{
  "model": "cards.cardtag",
  "pk": 2767,
  "fields": {
    "card": 439,
    "tag": 730
  }
},
{
  "model": "cards.cardtag",
  "pk": 2768,
  "fields": {
    "card": 439,
    "tag": 716
  }
},
{
  "model": "cards.cardtag",
  "pk": 2769,
  "fields": {
    "card": 440,
    "tag": 835
  }
},
{
  "model": "cards.cardtag",
  "pk": 2770,
  "fields": {
    "card": 440,
    "tag": 1126
  }
},
{
  "model": "cards.cardtag",
  "pk": 2771,
  "fields": {
    "card": 440,
    "tag": 178
  }
},
{
  "model": "cards.cardtag",
  "pk": 2772,
  "fields": {
    "card": 440,
    "tag": 287
  }
},
{
  "model": "cards.cardtag",
  "pk": 2773,
  "fields": {
    "card": 440,
    "tag": 177
  }
},
{
  "model": "cards.cardtag",
  "pk": 2774,
  "fields": {
    "card": 440,
    "tag": 716
  }
},
{
  "model": "cards.cardtag",
  "pk": 2775,
  "fields": {
    "card": 441,
    "tag": 672
  }
},
{
  "model": "cards.cardtag",
  "pk": 2776,
  "fields": {
    "card": 441,
    "tag": 88
  }
},
{
  "model": "cards.cardtag",
  "pk": 2777,
  "fields": {
    "card": 441,
    "tag": 835
  }
},
{
  "model": "cards.cardtag",
  "pk": 2778,
  "fields": {
    "card": 441,
    "tag": 716
  }
},
{
  "model": "cards.cardtag",
  "pk": 2779,
  "fields": {
    "card": 442,
    "tag": 637
  }
},
{
  "model": "cards.cardtag",
  "pk": 2780,
  "fields": {
    "card": 442,
    "tag": 615
  }
},
{
  "model": "cards.cardtag",
  "pk": 2781,
  "fields": {
    "card": 442,
    "tag": 821
  }
},
{
  "model": "cards.cardtag",
  "pk": 2782,
  "fields": {
    "card": 442,
    "tag": 1126
  }
},
{
  "model": "cards.cardtag",
  "pk": 2783,
  "fields": {
    "card": 442,
    "tag": 19
  }
},
{
  "model": "cards.cardtag",
  "pk": 2784,
  "fields": {
    "card": 442,
    "tag": 716
  }
},
{
  "model": "cards.cardtag",
  "pk": 2785,
  "fields": {
    "card": 443,
    "tag": 489
  }
},
{
  "model": "cards.cardtag",
  "pk": 2786,
  "fields": {
    "card": 443,
    "tag": 165
  }
},
{
  "model": "cards.cardtag",
  "pk": 2787,
  "fields": {
    "card": 443,
    "tag": 152
  }
},
{
  "model": "cards.cardtag",
  "pk": 2788,
  "fields": {
    "card": 443,
    "tag": 773
  }
},
{
  "model": "cards.cardtag",
  "pk": 2789,
  "fields": {
    "card": 443,
    "tag": 19
  }
},
{
  "model": "cards.cardtag",
  "pk": 2790,
  "fields": {
    "card": 443,
    "tag": 305
  }
},
{
  "model": "cards.cardtag",
  "pk": 2791,
  "fields": {
    "card": 444,
    "tag": 104
  }
},
{
  "model": "cards.cardtag",
  "pk": 2792,
  "fields": {
    "card": 444,
    "tag": 1285
  }
},
{
  "model": "cards.cardtag",
  "pk": 2793,
  "fields": {
    "card": 444,
    "tag": 1151
  }
},
{
  "model": "cards.cardtag",
  "pk": 2794,
  "fields": {
    "card": 444,
    "tag": 737
  }
},
{
  "model": "cards.cardtag",
  "pk": 2795,
  "fields": {
    "card": 444,
    "tag": 107
  }
},
{
  "model": "cards.cardtag",
  "pk": 2796,
  "fields": {
    "card": 444,
    "tag": 241
  }
},
{
  "model": "cards.cardtag",
  "pk": 2797,
  "fields": {
    "card": 444,
    "tag": 19
  }
},
{
  "model": "cards.cardtag",
  "pk": 2798,
  "fields": {
    "card": 445,
    "tag": 451
  }
},
{
  "model": "cards.cardtag",
  "pk": 2799,
  "fields": {
    "card": 445,
    "tag": 197
  }
},
{
  "model": "cards.cardtag",
  "pk": 2800,
  "fields": {
    "card": 445,
    "tag": 287
  }
},
{
  "model": "cards.cardtag",
  "pk": 2801,
  "fields": {
    "card": 445,
    "tag": 19
  }
},
{
  "model": "cards.cardtag",
  "pk": 2802,
  "fields": {
    "card": 445,
    "tag": 1389
  }
},
{
  "model": "cards.cardtag",
  "pk": 2803,
  "fields": {
    "card": 445,
    "tag": 3
  }
},
{
  "model": "cards.cardtag",
  "pk": 2804,
  "fields": {
    "card": 446,
    "tag": 399
  }
},
{
  "model": "cards.cardtag",
  "pk": 2805,
  "fields": {
    "card": 446,
    "tag": 452
  }
},
{
  "model": "cards.cardtag",
  "pk": 2806,
  "fields": {
    "card": 446,
    "tag": 883
  }
},
{
  "model": "cards.cardtag",
  "pk": 2807,
  "fields": {
    "card": 446,
    "tag": 716
  }
},
{
  "model": "cards.cardtag",
  "pk": 2808,
  "fields": {
    "card": 446,
    "tag": 391
  }
},
{
  "model": "cards.cardtag",
  "pk": 2809,
  "fields": {
    "card": 446,
    "tag": 769
  }
},
{
  "model": "cards.cardtag",
  "pk": 2810,
  "fields": {
    "card": 447,
    "tag": 169
  }
},
{
  "model": "cards.cardtag",
  "pk": 2811,
  "fields": {
    "card": 447,
    "tag": 716
  }
},
{
  "model": "cards.cardtag",
  "pk": 2812,
  "fields": {
    "card": 447,
    "tag": 19
  }
},
{
  "model": "cards.cardtag",
  "pk": 2813,
  "fields": {
    "card": 447,
    "tag": 772
  }
},
{
  "model": "cards.cardtag",
  "pk": 2814,
  "fields": {
    "card": 447,
    "tag": 464
  }
},
{
  "model": "cards.cardtag",
  "pk": 2815,
  "fields": {
    "card": 447,
    "tag": 737
  }
},
{
  "model": "cards.cardtag",
  "pk": 2816,
  "fields": {
    "card": 447,
    "tag": 1151
  }
},
{
  "model": "cards.cardtag",
  "pk": 2817,
  "fields": {
    "card": 448,
    "tag": 670
  }
},
{
  "model": "cards.cardtag",
  "pk": 2818,
  "fields": {
    "card": 448,
    "tag": 54
  }
},
{
  "model": "cards.cardtag",
  "pk": 2819,
  "fields": {
    "card": 448,
    "tag": 785
  }
},
{
  "model": "cards.cardtag",
  "pk": 2820,
  "fields": {
    "card": 448,
    "tag": 797
  }
},
{
  "model": "cards.cardtag",
  "pk": 2821,
  "fields": {
    "card": 448,
    "tag": 540
  }
},
{
  "model": "cards.cardtag",
  "pk": 2822,
  "fields": {
    "card": 448,
    "tag": 301
  }
},
{
  "model": "cards.cardtag",
  "pk": 2823,
  "fields": {
    "card": 448,
    "tag": 19
  }
},
{
  "model": "cards.cardtag",
  "pk": 2824,
  "fields": {
    "card": 449,
    "tag": 617
  }
},
{
  "model": "cards.cardtag",
  "pk": 2825,
  "fields": {
    "card": 449,
    "tag": 867
  }
},
{
  "model": "cards.cardtag",
  "pk": 2826,
  "fields": {
    "card": 449,
    "tag": 47
  }
},
{
  "model": "cards.cardtag",
  "pk": 2827,
  "fields": {
    "card": 449,
    "tag": 1173
  }
},
{
  "model": "cards.cardtag",
  "pk": 2828,
  "fields": {
    "card": 449,
    "tag": 940
  }
},
{
  "model": "cards.cardtag",
  "pk": 2829,
  "fields": {
    "card": 449,
    "tag": 414
  }
},
{
  "model": "cards.cardtag",
  "pk": 2830,
  "fields": {
    "card": 449,
    "tag": 869
  }
},
{
  "model": "cards.cardtag",
  "pk": 2831,
  "fields": {
    "card": 449,
    "tag": 1246
  }
},
{
  "model": "cards.cardtag",
  "pk": 2832,
  "fields": {
    "card": 449,
    "tag": 19
  }
},
{
  "model": "cards.cardtag",
  "pk": 2833,
  "fields": {
    "card": 450,
    "tag": 1293
  }
},
{
  "model": "cards.cardtag",
  "pk": 2834,
  "fields": {
    "card": 450,
    "tag": 449
  }
},
{
  "model": "cards.cardtag",
  "pk": 2835,
  "fields": {
    "card": 450,
    "tag": 980
  }
},
{
  "model": "cards.cardtag",
  "pk": 2836,
  "fields": {
    "card": 450,
    "tag": 1087
  }
},
{
  "model": "cards.cardtag",
  "pk": 2837,
  "fields": {
    "card": 450,
    "tag": 716
  }
},
{
  "model": "cards.cardtag",
  "pk": 2838,
  "fields": {
    "card": 450,
    "tag": 1154
  }
},
{
  "model": "cards.cardtag",
  "pk": 2839,
  "fields": {
    "card": 451,
    "tag": 1293
  }
},
{
  "model": "cards.cardtag",
  "pk": 2840,
  "fields": {
    "card": 451,
    "tag": 536
  }
},
{
  "model": "cards.cardtag",
  "pk": 2841,
  "fields": {
    "card": 451,
    "tag": 316
  }
},
{
  "model": "cards.cardtag",
  "pk": 2842,
  "fields": {
    "card": 451,
    "tag": 19
  }
},
{
  "model": "cards.cardtag",
  "pk": 2843,
  "fields": {
    "card": 452,
    "tag": 216
  }
},
{
  "model": "cards.cardtag",
  "pk": 2844,
  "fields": {
    "card": 452,
    "tag": 58
  }
},
{
  "model": "cards.cardtag",
  "pk": 2845,
  "fields": {
    "card": 452,
    "tag": 1229
  }
},
{
  "model": "cards.cardtag",
  "pk": 2846,
  "fields": {
    "card": 452,
    "tag": 717
  }
},
{
  "model": "cards.cardtag",
  "pk": 2847,
  "fields": {
    "card": 452,
    "tag": 525
  }
},
{
  "model": "cards.cardtag",
  "pk": 2848,
  "fields": {
    "card": 452,
    "tag": 716
  }
},
{
  "model": "cards.cardtag",
  "pk": 2849,
  "fields": {
    "card": 453,
    "tag": 1292
  }
},
{
  "model": "cards.cardtag",
  "pk": 2850,
  "fields": {
    "card": 453,
    "tag": 435
  }
},
{
  "model": "cards.cardtag",
  "pk": 2851,
  "fields": {
    "card": 453,
    "tag": 216
  }
},
{
  "model": "cards.cardtag",
  "pk": 2852,
  "fields": {
    "card": 453,
    "tag": 512
  }
},
{
  "model": "cards.cardtag",
  "pk": 2853,
  "fields": {
    "card": 453,
    "tag": 1000
  }
},
{
  "model": "cards.cardtag",
  "pk": 2854,
  "fields": {
    "card": 453,
    "tag": 1236
  }
},
{
  "model": "cards.cardtag",
  "pk": 2855,
  "fields": {
    "card": 453,
    "tag": 230
  }
},
{
  "model": "cards.cardtag",
  "pk": 2856,
  "fields": {
    "card": 453,
    "tag": 716
  }
},
{
  "model": "cards.cardtag",
  "pk": 2857,
  "fields": {
    "card": 453,
    "tag": 19
  }
},
{
  "model": "cards.cardtag",
  "pk": 2858,
  "fields": {
    "card": 454,
    "tag": 1252
  }
},
{
  "model": "cards.cardtag",
  "pk": 2859,
  "fields": {
    "card": 454,
    "tag": 201
  }
},
{
  "model": "cards.cardtag",
  "pk": 2860,
  "fields": {
    "card": 454,
    "tag": 216
  }
},
{
  "model": "cards.cardtag",
  "pk": 2861,
  "fields": {
    "card": 454,
    "tag": 110
  }
},
{
  "model": "cards.cardtag",
  "pk": 2862,
  "fields": {
    "card": 454,
    "tag": 809
  }
},
{
  "model": "cards.cardtag",
  "pk": 2863,
  "fields": {
    "card": 454,
    "tag": 1268
  }
},
{
  "model": "cards.cardtag",
  "pk": 2864,
  "fields": {
    "card": 455,
    "tag": 1268
  }
},
{
  "model": "cards.cardtag",
  "pk": 2865,
  "fields": {
    "card": 455,
    "tag": 212
  }
},
{
  "model": "cards.cardtag",
  "pk": 2866,
  "fields": {
    "card": 455,
    "tag": 911
  }
},
{
  "model": "cards.cardtag",
  "pk": 2867,
  "fields": {
    "card": 455,
    "tag": 1120
  }
},
{
  "model": "cards.cardtag",
  "pk": 2868,
  "fields": {
    "card": 455,
    "tag": 644
  }
},
{
  "model": "cards.cardtag",
  "pk": 2869,
  "fields": {
    "card": 455,
    "tag": 19
  }
},
{
  "model": "cards.cardtag",
  "pk": 2870,
  "fields": {
    "card": 455,
    "tag": 1126
  }
},
{
  "model": "cards.cardtag",
  "pk": 2871,
  "fields": {
    "card": 455,
    "tag": 1198
  }
},
{
  "model": "cards.category",
  "pk": 1,
  "fields": {
    "name": "Linux"
  }
},
{
  "model": "cards.category",
  "pk": 2,
  "fields": {
    "name": "SQL"
  }
},
{
  "model": "cards.category",
  "pk": 3,
  "fields": {
    "name": "general"
  }
},
{
  "model": "cards.category",
  "pk": 4,
  "fields": {
    "name": "JavaScript"
  }
},
{
  "model": "cards.category",
  "pk": 5,
  "fields": {
    "name": "General"
  }
},
{
  "model": "cards.category",
  "pk": 6,
  "fields": {
    "name": "Programming"
  }
},
{
  "model": "cards.category",
  "pk": 7,
  "fields": {
    "name": "Python"
  }
}
]